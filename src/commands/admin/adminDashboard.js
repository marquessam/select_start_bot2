import { 
    SlashCommandBuilder, 
    EmbedBuilder, 
    ActionRowBuilder, 
    StringSelectMenuBuilder,
    ButtonBuilder,
    ButtonStyle,
    ComponentType,
    ModalBuilder,
    TextInputBuilder,
    TextInputStyle,
    PermissionFlagsBits
} from 'discord.js';
import { User } from '../../models/User.js';
import { Challenge } from '../../models/Challenge.js';
import { ArcadeBoard } from '../../models/ArcadeBoard.js';
import { Poll } from '../../models/Poll.js';
import retroAPI from '../../services/retroAPI.js';
import { config } from '../../config/config.js';

// Constants
const MEMBER_ROLE_ID = '1316292690870014002';

export default {
    data: new SlashCommandBuilder()
        .setName('admin')
        .setDescription('Admin dashboard for managing all aspects of the community')
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild) // Require admin permissions
        // Challenge Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('challenge')
                .setDescription('Manage monthly and shadow challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('create')
                        .setDescription('Create or replace a monthly challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('shadow')
                        .setDescription('Add or edit a shadow challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('toggle')
                        .setDescription('Toggle shadow challenge visibility')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View current challenge details')
                )
        )
        
        // Arcade Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('arcade')
                .setDescription('Manage arcade boards and racing challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('add')
                        .setDescription('Add an arcade board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('racing')
                        .setDescription('Set up a racing challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('tiebreaker')
                        .setDescription('Create a tiebreaker board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Award points for a completed board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('announce')
                        .setDescription('Announce a board to the community')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View and manage existing boards')
                )
        )
        
        // User Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('user')
                .setDescription('Manage users, registrations, and awards')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('register')
                        .setDescription('Register a user')
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to register')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('unregister')
                        .setDescription('Unregister a user')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to unregister')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('purge')
                        .setDescription('Completely remove a user registration')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to purge')
                            .setRequired(true))
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to purge (optional)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Give a community award to a user')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('title')
                            .setDescription('The title of the award')
                            .setRequired(true))
                        .addIntegerOption(option =>
                            option.setName('points')
                            .setDescription('Number of points for this award')
                            .setRequired(true)
                            .setMinValue(1))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('awards')
                        .setDescription('View user awards')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('clear')
                        .setDescription('Clear nominations or awards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('reset')
                        .setDescription('Reset user achievements')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('RetroAchievements username')
                            .setRequired(true))
                )
        )
        
        // Voting Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('voting')
                .setDescription('Manage voting processes')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('start')
                        .setDescription('Start a voting poll')
                        .addChannelOption(option =>
                            option.setName('channel')
                            .setDescription('The channel to create the poll announcement in')
                            .setRequired(true))
                        .addChannelOption(option =>
                            option.setName('results_channel')
                            .setDescription('The channel to announce results in (defaults to same channel)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('cancel')
                        .setDescription('Cancel an active voting poll')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('status')
                        .setDescription('Check status of current voting')
                )
        )
        
        // System Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('system')
                .setDescription('System-level operations')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('update')
                        .setDescription('Force an update of all stats and leaderboards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('suggestions')
                        .setDescription('Manage community suggestions')
                )
        )
        
        // Info display subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('info')
                .setDescription('Display shareable information')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('arcade')
                        .setDescription('Display arcade board information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('challenges')
                        .setDescription('Display challenge information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('overview')
                        .setDescription('Display community overview')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('commands')
                        .setDescription('Display available commands')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('rules')
                        .setDescription('Display community rules')
                )
        ),

    async execute(interaction) {
        // Check if user has admin role
        if (!interaction.member.roles.cache.has(config.bot.roles.admin)) {
            return interaction.reply({
                content: 'You do not have permission to use this command.',
                ephemeral: true
            });
        }

        await interaction.deferReply({ ephemeral: true });

        try {
            // Extract subcommand group and subcommand
            const subcommandGroup = interaction.options.getSubcommandGroup();
            const subcommand = interaction.options.getSubcommand();
            
            // Route to the appropriate handler based on subcommand group and subcommand
            switch (subcommandGroup) {
                case 'challenge':
                    await this.handleChallengeCommand(interaction, subcommand);
                    break;
                case 'arcade':
                    await this.handleArcadeCommand(interaction, subcommand);
                    break;
                case 'user':
                    await this.handleUserCommand(interaction, subcommand);
                    break;
                case 'voting':
                    await this.handleVotingCommand(interaction, subcommand);
                    break;
                case 'system':
                    await this.handleSystemCommand(interaction, subcommand);
                    break;
                case 'info':
                    await this.handleInfoCommand(interaction, subcommand);
                    break;
                default:
                    await interaction.editReply('Invalid subcommand group.');
            }
        } catch (error) {
            console.error('Error executing admin command:', error);
            await interaction.editReply('An error occurred while processing your request.');
        }
    },

    // CHALLENGE MANAGEMENT HANDLERS
    async handleChallengeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'create':
                await this.handleCreateChallenge(interaction);
                break;
            case 'shadow':
                await this.handleShadowChallenge(interaction);
                break;
            case 'toggle':
                await this.handleToggleShadow(interaction);
                break;
            case 'view':
                await this.handleViewChallenge(interaction);
                break;
            default:
                await interaction.editReply('Invalid challenge subcommand.');
        }
    },

    async handleCreateChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Create Monthly Challenge')
            .setColor('#32CD32')
            .setDescription('Use this form to create or replace a monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'How to Find Achievement IDs',
                    value: 'Go to the game page on RetroAchievements, hover over an achievement, and note the ID number in the URL.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('create_challenge_form')
                    .setLabel('Open Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ®')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'create_challenge_form') {
                    // Create modal for challenge creation
                    const modal = new ModalBuilder()
                        .setCustomId('create_challenge_modal')
                        .setTitle('Create Monthly Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add year input
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Create date for the first of the specified month
                            const challengeDate = new Date(year, month - 1, 1);

                            // Check if a challenge already exists for this month
                            const existingChallenge = await Challenge.findOneAndDelete({
                                date: {
                                    $gte: challengeDate,
                                    $lt: new Date(year, month, 1)
                                }
                            });

                            // Create new challenge
                            const challenge = new Challenge({
                                date: challengeDate,
                                monthly_challange_gameid: gameId,
                                monthly_challange_progression_achievements: progressionAchievements,
                                monthly_challange_win_achievements: winAchievements,
                                monthly_challange_game_total: totalAchievements,
                                shadow_challange_revealed: false // Keep shadow challenge hidden by default
                            });

                            await challenge.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Monthly Challenge Created')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (existingChallenge) {
                                resultEmbed.setDescription(`Monthly challenge replaced for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: existingChallenge.monthly_challange_gameid.toString() },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Monthly challenge created for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('add_shadow')
                                        .setLabel('Add Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ‘¥'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'add_shadow') {
                                        await this.handleShadowChallenge(resultI, { month, year });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error creating challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while creating the challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to create a challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleShadowChallenge(interaction, prefilledData = null) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Shadow Challenge')
            .setColor('#9932CC') // Dark purple
            .setDescription('Use this form to add or edit a shadow challenge for a specific month.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'Shadow Challenge Rules',
                    value: 'Shadow challenges are hidden mysteries that players can discover by guessing or playing the challenge games. They automatically reveal for past months.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('shadow_challenge_form')
                    .setLabel('Open Shadow Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸ‘¥')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'shadow_challenge_form') {
                    // Create modal for shadow challenge
                    const modal = new ModalBuilder()
                        .setCustomId('shadow_challenge_modal')
                        .setTitle('Add Shadow Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input with prefilled data if available
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.month) {
                        monthInput.setValue(prefilledData.month.toString());
                    } else {
                        // Default to current month
                        const now = new Date();
                        monthInput.setValue((now.getMonth() + 1).toString());
                    }

                    // Add year input with prefilled data if available
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.year) {
                        yearInput.setValue(prefilledData.year.toString());
                    } else {
                        // Default to current year
                        const now = new Date();
                        yearInput.setValue(now.getFullYear().toString());
                    }

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get date range for the specified month
                            const monthStart = new Date(year, month - 1, 1);
                            const nextMonthStart = new Date(year, month, 1);

                            // Find the target challenge
                            const targetChallenge = await Challenge.findOne({
                                date: {
                                    $gte: monthStart,
                                    $lt: nextMonthStart
                                }
                            });

                            if (!targetChallenge) {
                                return modalSubmission.editReply(`No challenge exists for ${month}/${year}. Create a monthly challenge first using /admin challenge create.`);
                            }

                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Check if there's an existing shadow game to be replaced
                            let replacedShadowGame = null;
                            if (targetChallenge.shadow_challange_gameid) {
                                try {
                                    const oldGameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
                                    replacedShadowGame = oldGameInfo.title;
                                } catch (error) {
                                    console.error('Error fetching old shadow game info:', error);
                                    replacedShadowGame = targetChallenge.shadow_challange_gameid;
                                }
                            }

                            // Update the challenge with shadow game information
                            targetChallenge.shadow_challange_gameid = gameId;
                            targetChallenge.shadow_challange_progression_achievements = progressionAchievements;
                            targetChallenge.shadow_challange_win_achievements = winAchievements;
                            targetChallenge.shadow_challange_game_total = totalAchievements;
                            
                            // Automatically reveal shadow games for past months
                            const now = new Date();
                            if (month < now.getMonth() + 1 || year < now.getFullYear()) {
                                targetChallenge.shadow_challange_revealed = true;
                            } else if (!targetChallenge.shadow_challange_revealed) {
                                // For current or future months, keep shadow games hidden by default
                                targetChallenge.shadow_challange_revealed = false;
                            }

                            await targetChallenge.save();

                            // Get month name for display
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Determine if it was auto-revealed
                            const autoRevealed = (month < now.getMonth() + 1 || year < now.getFullYear());
                            
                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#9932CC') // Dark purple for shadow challenges
                                .setTitle('Shadow Challenge Added')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (replacedShadowGame) {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} replaced`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: replacedShadowGame },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} created`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() },
                                { name: 'Visibility', value: targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden' + (autoRevealed ? ' (Auto-revealed as past challenge)' : '') }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('toggle_shadow')
                                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'toggle_shadow') {
                                        await this.handleToggleShadow(resultI, { month, year, force: true });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding shadow challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the shadow challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a shadow challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleToggleShadow(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            let force = options?.force || false;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                const now = new Date();
                month = now.getMonth() + 1; // 1-indexed month
                year = now.getFullYear();
            }
            
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the target challenge
            const targetChallenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!targetChallenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            if (!targetChallenge.shadow_challange_gameid) {
                return interaction.editReply(`No shadow challenge has been set for ${month}/${year}.`);
            }

            // Toggle the visibility
            targetChallenge.shadow_challange_revealed = !targetChallenge.shadow_challange_revealed;
            await targetChallenge.save();

            // Get game info for the response
            const gameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
            
            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Create response embed
            const resultEmbed = new EmbedBuilder()
                .setColor(targetChallenge.shadow_challange_revealed ? '#00FF00' : '#FF0000') // Green for revealed, red for hidden
                .setTitle(`Shadow Challenge ${targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden'}`)
                .setDescription(`The shadow challenge for ${monthName} ${year} is now ${targetChallenge.shadow_challange_revealed ? 'REVEALED' : 'HIDDEN'}.`)
                .setTimestamp();

            if (targetChallenge.shadow_challange_revealed) {
                resultEmbed.addFields(
                    { name: 'Game', value: gameInfo.title },
                    { name: 'Required Progression Achievements', value: targetChallenge.shadow_challange_progression_achievements.length.toString() },
                    { name: 'Required Win Achievements', value: targetChallenge.shadow_challange_win_achievements.length > 0 ? targetChallenge.shadow_challange_win_achievements.length.toString() : 'None' }
                );
                
                if (gameInfo.imageIcon) {
                    resultEmbed.setThumbnail(`https://retroachievements.org${gameInfo.imageIcon}`);
                }
            }

            // Add action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow_again')
                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                    new ButtonBuilder()
                        .setCustomId('view_challenge')
                        .setLabel('View Challenge Details')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ”')
                );

            // If we're force-updating from another command, use editReply
            // Otherwise, use standard reply
            if (force) {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            } else {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            }

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'toggle_shadow_again') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    } else if (i.customId === 'view_challenge') {
                        await this.handleViewChallenge(i, { month, year });
                    }
                }
            });

        } catch (error) {
            console.error('Error toggling shadow challenge visibility:', error);
            await interaction.editReply('An error occurred while toggling the shadow challenge visibility. Please try again.');
        }
    },

    async handleViewChallenge(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                // Open a form to select month/year
                const embed = new EmbedBuilder()
                    .setTitle('View Challenge Details')
                    .setColor('#3498DB')
                    .setDescription('Please select which challenge you want to view.')
                    .addFields(
                        {
                            name: 'Options',
                            value: 'You can view the current month\'s challenge or select a specific month.'
                        }
                    );

                // Create buttons
                const row = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('view_current_challenge')
                            .setLabel('Current Month')
                            .setStyle(ButtonStyle.Primary)
                            .setEmoji('ðŸ“…'),
                        new ButtonBuilder()
                            .setCustomId('select_month_challenge')
                            .setLabel('Select Month')
                            .setStyle(ButtonStyle.Secondary)
                            .setEmoji('ðŸ”')
                    );

                await interaction.editReply({
                    embeds: [embed],
                    components: [row]
                });

                // Set up collector for the buttons
                const message = await interaction.fetchReply();
                const buttonCollector = message.createMessageComponentCollector({
                    componentType: ComponentType.Button,
                    time: 300000 // 5 minutes timeout
                });

                buttonCollector.on('collect', async i => {
                    if (i.user.id === interaction.user.id) {
                        await i.deferUpdate();

                        if (i.customId === 'view_current_challenge') {
                            // Use current month
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                            
                            // Continue with viewing the challenge
                            await this.displayChallengeDetails(i, month, year);
                            
                            // Stop the collector
                            buttonCollector.stop();
                        } else if (i.customId === 'select_month_challenge') {
                            // Show modal to select month/year
                            const modal = new ModalBuilder()
                                .setCustomId('select_challenge_month_modal')
                                .setTitle('Select Challenge Month');

                            // Add month input
                            const monthInput = new TextInputBuilder()
                                .setCustomId('month')
                                .setLabel('Month (1-12)')
                                .setPlaceholder('Example: 5 (for May)')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add year input
                            const yearInput = new TextInputBuilder()
                                .setCustomId('year')
                                .setLabel('Year')
                                .setPlaceholder('Example: 2025')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add inputs to modal
                            const monthRow = new ActionRowBuilder().addComponents(monthInput);
                            const yearRow = new ActionRowBuilder().addComponents(yearInput);

                            modal.addComponents(monthRow, yearRow);

                            // Show the modal
                            await i.showModal(modal);

                            try {
                                // Wait for modal submission
                                const modalSubmission = await i.awaitModalSubmit({
                                    time: 300000 // 5 minutes to fill out the form
                                });

                                await modalSubmission.deferUpdate();

                                // Extract values from the modal
                                month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                                year = parseInt(modalSubmission.fields.getTextInputValue('year'));

                                // Validate inputs
                                if (isNaN(month) || month < 1 || month > 12) {
                                    return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                                }

                                if (isNaN(year) || year < 2000 || year > 2100) {
                                    return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                                }

                                // Continue with viewing the challenge
                                await this.displayChallengeDetails(modalSubmission, month, year);
                                
                                // Stop the collector
                                buttonCollector.stop();

                            } catch (modalError) {
                                console.error('Error handling modal submission:', modalError);
                                // Modal timed out or was cancelled
                            }
                        }
                    }
                });

                // Let the function end here and let the collector handle the rest
                return;
            }

            // If we have month/year, display the challenge
            await this.displayChallengeDetails(interaction, month, year);

        } catch (error) {
            console.error('Error viewing challenge:', error);
            await interaction.editReply('An error occurred while viewing the challenge. Please try again.');
        }
    },

    async displayChallengeDetails(interaction, month, year) {
        try {
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the challenge
            const challenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!challenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Get game info for monthly challenge
            let monthlyGameInfo = null;
            if (challenge.monthly_challange_gameid) {
                monthlyGameInfo = await retroAPI.getGameInfo(challenge.monthly_challange_gameid);
            }

            // Get game info for shadow challenge if revealed
            let shadowGameInfo = null;
            if (challenge.shadow_challange_gameid && challenge.shadow_challange_revealed) {
                shadowGameInfo = await retroAPI.getGameInfo(challenge.shadow_challange_gameid);
            }

            // Create main embed
            const embed = new EmbedBuilder()
                .setTitle(`Challenge Details: ${monthName} ${year}`)
                .setColor('#3498DB')
                .setDescription(`Here are the details for the ${monthName} ${year} challenges:`)
                .setTimestamp();

            // Add monthly challenge info
            if (monthlyGameInfo) {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: `**Game:** ${monthlyGameInfo.title}\n` +
                          `**Required Progression Achievements:** ${challenge.monthly_challange_progression_achievements.length}\n` +
                          `**Required Win Achievements:** ${challenge.monthly_challange_win_achievements.length}\n` +
                          `**Total Achievements:** ${challenge.monthly_challange_game_total}\n` +
                          `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.monthly_challange_gameid})`
                });

                if (monthlyGameInfo.imageIcon) {
                    embed.setThumbnail(`https://retroachievements.org${monthlyGameInfo.imageIcon}`);
                }
            } else {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: 'No monthly challenge set.'
                });
            }

            // Add shadow challenge info
            if (challenge.shadow_challange_gameid) {
                if (challenge.shadow_challange_revealed && shadowGameInfo) {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (REVEALED)',
                        value: `**Game:** ${shadowGameInfo.title}\n` +
                              `**Required Progression Achievements:** ${challenge.shadow_challange_progression_achievements.length}\n` +
                              `**Required Win Achievements:** ${challenge.shadow_challange_win_achievements.length}\n` +
                              `**Total Achievements:** ${challenge.shadow_challange_game_total}\n` +
                              `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.shadow_challange_gameid})`
                    });
                } else {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (HIDDEN)',
                        value: 'Shadow challenge exists but is currently hidden.\n' +
                              `Use \`/admin challenge toggle\` to reveal it.`
                    });
                }
            } else {
                embed.addFields({
                    name: 'ðŸ‘¥ Shadow Challenge',
                    value: 'No shadow challenge set.\n' +
                          `Use \`/admin challenge shadow\` to add one.`
                });
            }

            // Create action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('edit_monthly')
                        .setLabel('Edit Monthly Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('ðŸ†'),
                    new ButtonBuilder()
                        .setCustomId('edit_shadow')
                        .setLabel(challenge.shadow_challange_gameid ? 'Edit Shadow Challenge' : 'Add Shadow Challenge')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ‘¥')
                );

            // Add toggle button if shadow challenge exists
            if (challenge.shadow_challange_gameid) {
                actionRow.addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow')
                        .setLabel(challenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji(challenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸')
                );
            }

            await interaction.editReply({
                embeds: [embed],
                components: [actionRow]
            });

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'edit_monthly') {
                        await this.handleCreateChallenge(i);
                    } else if (i.customId === 'edit_shadow') {
                        await this.handleShadowChallenge(i, { month, year });
                    } else if (i.customId === 'toggle_shadow') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    }
                }
            });

        } catch (error) {
            console.error('Error displaying challenge details:', error);
            await interaction.editReply('An error occurred while retrieving challenge details. Please try again.');
        }
    },

    // ARCADE MANAGEMENT HANDLERS
    async handleArcadeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'add':
                await this.handleAddArcadeBoard(interaction);
                break;
            case 'racing':
                await this.handleAddRacingChallenge(interaction);
                break;
            case 'tiebreaker':
                await this.handleAddTiebreaker(interaction);
                break;
            case 'award':
                await this.handleAwardPoints(interaction);
                break;
            case 'announce':
                await this.handleAnnounceBoard(interaction);
                break;
            case 'view':
                await this.handleViewBoards(interaction);
                break;
            default:
                await interaction.editReply('Invalid arcade subcommand.');
        }
    },

    async handleAddArcadeBoard(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Arcade Board')
            .setColor('#9B59B6') // Purple
            .setDescription('Use this form to add a new arcade board to the community.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Board ID (unique identifier)\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description'
                },
                {
                    name: 'How to Find IDs',
                    value: '**Game ID**: The number at the end of the game URL on RetroAchievements\n**Leaderboard ID**: The number at the end of the leaderboard URL'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_arcade_form')
                    .setLabel('Open Arcade Board Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ¯')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_arcade_form') {
                    // Create modal for arcade board
                    const modal = new ModalBuilder()
                        .setCustomId('add_arcade_modal')
                        .setTitle('Add Arcade Board');

                    // Add board ID input
                    const boardIdInput = new TextInputBuilder()
                        .setCustomId('board_id')
                        .setLabel('Board ID (unique identifier)')
                        .setPlaceholder('Example: sonic3-special-stages')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this arcade board challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add inputs to modal
                    const boardIdRow = new ActionRowBuilder().addComponents(boardIdInput);
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);

                    modal.addComponents(boardIdRow, gameIdRow, leaderboardIdRow, descriptionRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const boardId = modalSubmission.fields.getTextInputValue('board_id');
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        try {
                            // Check if board ID already exists
                            const existingBoard = await ArcadeBoard.findOne({ boardId });
                            if (existingBoard) {
                                return modalSubmission.editReply(`A board with ID "${boardId}" already exists.`);
                            }

                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Create new board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'arcade',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description
                            });

                            await newBoard.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Arcade Board Added')
                                .setDescription(`Successfully added "${gameInfo.title}" arcade board!`)
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .addFields(
                                    { name: 'Board ID', value: boardId },
                                    { name: 'Game', value: gameInfo.title },
                                    { name: 'Console', value: gameInfo.consoleName || 'Unknown' },
                                    { name: 'Description', value: description }
                                )
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_board')
                                        .setLabel('Announce Board')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_board') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding arcade board:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the arcade board. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add an arcade board.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddRacingChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Racing Challenge')
            .setColor('#FF9900') // Orange
            .setDescription('Use this form to set up a monthly racing challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Track Name\nâ€¢ Description\nâ€¢ Month and Year (optional, defaults to current month)'
                },
                {
                    name: 'Racing Challenge Rules',
                    value: 'Racing challenges are monthly competitions where players compete on time-based leaderboards. The top 3 players will receive community points.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_racing_form')
                    .setLabel('Open Racing Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_racing_form') {
                    // Create modal for racing challenge
                    const modal = new ModalBuilder()
                        .setCustomId('add_racing_modal')
                        .setTitle('Add Racing Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add track name input
                    const trackNameInput = new TextInputBuilder()
                        .setCustomId('track_name')
                        .setLabel('Track Name')
                        .setPlaceholder('Example: Rainbow Road')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this racing challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add month/year input
                    const monthYearInput = new TextInputBuilder()
                        .setCustomId('month_year')
                        .setLabel('Month and Year (optional, MM/YYYY format)')
                        .setPlaceholder('Example: 05/2025 (defaults to current month)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const trackNameRow = new ActionRowBuilder().addComponents(trackNameInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthYearInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, trackNameRow, descriptionRow, monthYearRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const trackName = modalSubmission.fields.getTextInputValue('track_name');
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const monthYearInput = modalSubmission.fields.getTextInputValue('month_year');

                        // Parse month and year
                        let month, year;
                        if (monthYearInput && monthYearInput.trim()) {
                            const parts = monthYearInput.split('/');
                            if (parts.length === 2) {
                                month = parseInt(parts[0]);
                                year = parseInt(parts[1]);
                            } else {
                                // Invalid format, use current month/year
                                const now = new Date();
                                month = now.getMonth() + 1;
                                year = now.getFullYear();
                            }
                        } else {
                            // No input, use current month/year
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                        }

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Calculate start and end dates
                            // Start at beginning of specified month
                            const startDate = new Date(year, month - 1, 1);
                            
                            // End at the end of the specified month (23:59:59 on the last day)
                            const endDate = new Date(year, month, 0, 23, 59, 59);
                            
                            // Check if a racing challenge already exists for this month
                            const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                            const existingChallenge = await ArcadeBoard.findOne({
                                boardType: 'racing',
                                monthKey
                            });

                            if (existingChallenge) {
                                return modalSubmission.editReply(`A racing challenge already exists for ${monthKey}.`);
                            }

                            // Generate a unique board ID specifically for racing
                            // This format ensures no overlap with regular arcade boards
                            const boardId = `racing-${monthKey}`;

                            // Get the full game title and console name
                            const gameFull = `${gameInfo.title} (${gameInfo.consoleName})`;

                            // Create new racing board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'racing',
                                leaderboardId,
                                gameId,
                                gameTitle: gameFull,
                                trackName,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate,
                                endDate,
                                monthKey
                            });

                            await newBoard.save();

                            // Get month name for response
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF9900') // Orange for racing
                                .setTitle(`Racing Challenge Created: ${monthName} ${year}`)
                                .setDescription(
                                    `**Game:** ${gameFull}\n` +
                                    `**Track:** ${trackName}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Challenge Period:** ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `The top 3 players at the end of the month will receive award points!`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_racing')
                                        .setLabel('Announce Racing Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_racing') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding racing challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the racing challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a racing challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddTiebreaker(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Tiebreaker')
            .setColor('#FF0000') // Red
            .setDescription('Use this form to create a tiebreaker leaderboard for the monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description\nâ€¢ End Date (YYYY-MM-DD format)'
                },
                {
                    name: 'Tiebreaker Rules',
                    value: 'Tiebreakers are used to resolve ties in the monthly challenge leaderboard. Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_tiebreaker_form')
                    .setLabel('Open Tiebreaker Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('âš”ï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_tiebreaker_form') {
                    // Create modal for tiebreaker
                    const modal = new ModalBuilder()
                        .setCustomId('add_tiebreaker_modal')
                        .setTitle('Add Tiebreaker');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this tiebreaker challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add end date input
                    const endDateInput = new TextInputBuilder()
                        .setCustomId('end_date')
                        .setLabel('End Date (YYYY-MM-DD format)')
                        .setPlaceholder('Example: 2025-05-31')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const endDateRow = new ActionRowBuilder().addComponents(endDateInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, descriptionRow, endDateRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const endDateStr = modalSubmission.fields.getTextInputValue('end_date');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        // Parse end date
                        const endDate = new Date(endDateStr);
                        if (isNaN(endDate.getTime())) {
                            return modalSubmission.editReply('Invalid end date format. Please use YYYY-MM-DD.');
                        }

                        // Set end time to 23:59:59
                        endDate.setHours(23, 59, 59);

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Check if an active tiebreaker already exists
                            const now = new Date();
                            const activeTiebreaker = await ArcadeBoard.findOne({
                                boardType: 'tiebreaker',
                                startDate: { $lte: now },
                                endDate: { $gte: now }
                            });

                            if (activeTiebreaker) {
                                return modalSubmission.editReply('An active tiebreaker already exists. Please end it before creating a new one.');
                            }

                            // Generate a unique board ID based on month and year
                            const monthYear = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}`;
                            const boardId = `tiebreaker-${monthYear}`;

                            // Create new tiebreaker board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'tiebreaker',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate: now,
                                endDate,
                                // Add monthKey for consistency with racing challenges
                                monthKey: monthYear
                            });

                            await newBoard.save();

                            // Get the month name
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[now.getMonth()];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF0000') // Red for tiebreaker
                                .setTitle(`âš”ï¸ Tiebreaker Created: ${monthName} ${now.getFullYear()}`)
                                .setDescription(
                                    `**Game:** ${gameInfo.title}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Tiebreaker Period:** ${now.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `This tiebreaker will be used to resolve ties in the ${monthName} monthly challenge leaderboard. ` +
                                    `Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_tiebreaker')
                                        .setLabel('Announce Tiebreaker')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_tiebreaker') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding tiebreaker:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the tiebreaker. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a tiebreaker.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAwardPoints(interaction) {
        // Create select board form
        const embed = new EmbedBuilder()
            .setTitle('Award Points')
            .setColor('#32CD32') // Lime green
            .setDescription('Select a board to award points for.')
            .addFields(
                {
                    name: 'Award Points',
                    value: 'You can award points for completed racing challenges or arcade boards. For racing challenges, points are awarded to the top 3 players. For arcade boards, points are awarded annually.'
                }
            );

        // Find all racing boards and tiebreakers
        const racingBoards = await ArcadeBoard.find({ 
            boardType: 'racing',
            pointsAwarded: { $ne: true } // Only show boards that haven't been awarded points yet
        }).sort({ startDate: -1 });

        // Create options for racing boards
        const boardOptions = racingBoards.map(board => {
            const monthYear = board.monthKey || 'Unknown Date';
            return {
                label: `Racing: ${board.gameTitle}${board.trackName ? ` - ${board.trackName}` : ''}`,
                description: `${monthYear}`,
                value: `racing-${board.boardId}`
            };
        });

        // Add option for annual arcade awards if any arcade boards exist
        const arcadeBoards = await ArcadeBoard.find({ boardType: 'arcade' });
        if (arcadeBoards.length > 0) {
            boardOptions.push({
                label: 'Annual Arcade Awards',
                description: 'Award points for all arcade boards for the current year',
                value: 'arcade-annual'
            });
        }

        // Create dropdown if we have options
        if (boardOptions.length === 0) {
            return interaction.editReply('No eligible boards found for awarding points. All racing challenges have already been awarded points, or no racing challenges exist.');
        }

        // Create the dropdown
        const row = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('select_board_for_award')
                    .setPlaceholder('Select a board to award points')
                    .addOptions(boardOptions)
            );

        // Send the selection menu
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the dropdown selection
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.StringSelect,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                await i.deferUpdate();
                
                const selectedValue = i.values[0];
                
                if (selectedValue.startsWith('racing-')) {
                    // Extract board ID
                    const boardId = selectedValue.substring(7);
                    await this.awardRacingPoints(i, boardId);
                } else if (selectedValue === 'arcade-annual') {
                    await this.awardArcadePoints(i);
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        StringSelectMenuBuilder.from(row.components[0])
                            .setDisabled(true)
                            .setPlaceholder('Selection timed out')
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This selection has expired. Please run the command again if you still need to award points.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling dropdown:', error);
                }
            }
        });
    },

    async awardRacingPoints(interaction, boardId) {
        try {
            // Find the racing board
            const racingBoard = await ArcadeBoard.findOne({ 
                boardId,
                boardType: 'racing'
            });

            if (!racingBoard) {
                return interaction.editReply(`Racing board with ID "${boardId}" not found.`);
            }

            // Check if points have already been awarded
            if (racingBoard.pointsAwarded) {
                return interaction.editReply(`Points have already been awarded for this racing challenge.`);
            }

            // Check if the racing challenge has ended
            const now = new Date();
            if (racingBoard.endDate > now) {
                return interaction.editReply(`This racing challenge hasn't ended yet. It ends on ${racingBoard.endDate.toLocaleDateString()}.`);
            }

            // Create selection form for manual or automatic awarding
            const embed = new EmbedBuilder()
                .setTitle(`Award Points: ${racingBoard.gameTitle}${racingBoard.trackName ? ` - ${racingBoard.trackName}` : ''}`)
                .setColor('#FF9900') // Orange for racing
                .setDescription('Choose how to award points for this racing challenge.')
                .addFields(
                    {
                        name: 'Board Details',
                        value: `**Game:** ${racingBoard.gameTitle}\n` +
                               `**Track:** ${racingBoard.trackName || 'N/A'}\n` +
                               `**Period:** ${racingBoard.startDate.toLocaleDateString()} to ${racingBoard.endDate.toLocaleDateString()}`
                    },
                    {
                        name: 'Award Options',
                        value: 'You can award points automatically based on the current leaderboard standings, or manually specify winners if needed.'
                    }
                );

            // Create the selection buttons
            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('award_auto')
                        .setLabel('Award Automatically')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('ðŸ†'),
                    new ButtonBuilder()
                        .setCustomId('award_manual')
                        .setLabel('Award Manually')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('âœï¸'),
                    new ButtonBuilder()
                        .setCustomId('cancel_award')
                        .setLabel('Cancel')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('âŒ')
                );

            await interaction.editReply({
                embeds: [embed],
                components: [row]
            });

            // Set up collector for the button selection
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'award_auto') {
                        // Award points automatically based on leaderboard
                        await this.awardRacingPointsAuto(i, racingBoard);
                    } else if (i.customId === 'award_manual') {
                        // Show form for manual awards
                        await this.awardRacingPointsManual(i, racingBoard);
                    } else if (i.customId === 'cancel_award') {
                        await i.editReply({
                            content: 'Awarding points cancelled.',
                            embeds: [],
                            components: []
                        });
                    }
                }
            });
        } catch (error) {
            console.error('Error awarding racing points:', error);
            await interaction.editReply('An error occurred while processing the racing awards. Please try again.');
        }
    },

    async awardRacingPointsAuto(interaction, racingBoard) {
        try {
            // Show loading message
            await interaction.editReply({
                content: 'Fetching leaderboard entries... This may take a moment.',
                embeds: [],
                components: []
            });

            // Fetch leaderboard entries from RetroAchievements
            let allEntries;
            try {
                allEntries = await retroAPI.getLeaderboardEntries(racingBoard.leaderboardId, 0, 1000);
                
                if (!allEntries || allEntries.length === 0) {
                    return interaction.editReply('No leaderboard entries found for this racing board.');
                }
            } catch (fetchError) {
                console.error('Error fetching leaderboard entries:', fetchError);
                return interaction.editReply('Error fetching leaderboard entries. Please try again or use manual award option.');
            }

            // Get all registered users
            const users = await User.find({ isActive: true });
            
            // Create mapping of RA usernames (lowercase) to canonical usernames
            const registeredUsers = new Map();
            for (const user of users) {
                registeredUsers.set(user.raUsername.toLowerCase(), user);
            }
            
            // Filter entries to only show registered users
            const filteredEntries = allEntries.filter(entry => 
                entry.User && registeredUsers.has(entry.User.toLowerCase())
            );

            if (filteredEntries.length === 0) {
                return interaction.editReply('No registered users found in the leaderboard for this racing board.');
            }

            // Track awarded points and results
            const results = [];
            
            // Award points to the top 3 finishers
            const pointsDistribution = [3, 2, 1]; // 1st, 2nd, 3rd place
            
            for (let i = 0; i < Math.min(3, filteredEntries.length); i++) {
                const entry = filteredEntries[i];
                const pointsToAward = pointsDistribution[i];
                const userObj = registeredUsers.get(entry.User.toLowerCase());
                
                if (userObj) {
                    // Add community award
                    const monthName = racingBoard.startDate.toLocaleString('default', { month: 'long' });
                    const year = racingBoard.startDate.getFullYear();
                    const placement = i === 0 ? '1st' : (i === 1 ? '2nd' : '3rd');
                    
                    // Include track name in award if available
                    const trackDisplay = racingBoard.trackName 
                        ? ` - ${racingBoard.trackName}`
                        : '';
                        
                    const gameDisplay = `${racingBoard.gameTitle}${trackDisplay}`;
                    
                    const awardTitle = `${placement} Place in ${monthName} ${year} Racing: ${gameDisplay}`;
                    
                    userObj.communityAwards.push({
                        title: awardTitle,
                        points: pointsToAward,
                        awardedAt: new Date(),
                        awardedBy: interaction.user.tag
                    });
                    
                    await userObj.save();
                    
                    // Record result
                    results.push({
                        username: entry.User,
                        rank: i + 1,
                        time: entry.TrackTime,
                        points: pointsToAward
                    });
                }
            }
            
            // Update the racing board to mark points as awarded and store results
            racingBoard.pointsAwarded = true;
            racingBoard.results = results;
            await racingBoard.save();
            
            // Create response embed
            const resultEmbed = new EmbedBuilder()
                .setColor('#00FF00') // Green for success
                .setTitle('Racing Points Awarded')
                .setDescription(`Successfully awarded points for ${racingBoard.gameTitle}${racingBoard.trackName ? ` - ${racingBoard.trackName}` : ''} racing challenge!`)
                .setTimestamp();
                
            // Add results to embed
            const resultsField = results.map(result => 
                `${result.rank}. **${result.username}** (${result.time}): ${result.points} point${result.points !== 1 ? 's' : ''}`
            ).join('\n');
            
            resultEmbed.addFields({ 
                name: 'Results',
                value: resultsField || 'No results found.' 
            });
            
            // Add navigation button
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('view_boards')
                        .setLabel('View All Boards')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ”')
                );
            
            await interaction.editReply({
                content: null,
                embeds: [resultEmbed],
                components: [actionRow]
            });
            
            // Set up collector for the navigation button
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'view_boards') {
                        await this.handleViewBoards(i);
                    }
                }
            });
        } catch (error) {
            console.error('Error auto-awarding racing points:', error);
            await interaction.editReply('An error occurred while automatically awarding racing points. Please try again or use the manual award option.');
        }
    },

    async awardRacingPointsManual(interaction, racingBoard) {
        try {
            // Create modal for manual racing awards
            const modal = new ModalBuilder()
                .setCustomId('manual_racing_awards_modal')
                .setTitle('Manual Racing Awards');

            // Add first place input
            const firstPlaceInput = new TextInputBuilder()
                .setCustomId('first_place')
                .setLabel('First Place Username (3 points)')
                .setPlaceholder('RetroAchievements username')
                .setStyle(TextInputStyle.Short)
                .setRequired(true);

            // Add second place input
            const secondPlaceInput = new TextInputBuilder()
                .setCustomId('second_place')
                .setLabel('Second Place Username (2 points, optional)')
                .setPlaceholder('RetroAchievements username')
                .setStyle(TextInputStyle.Short)
                .setRequired(false);

            // Add third place input
            const thirdPlaceInput = new TextInputBuilder()
                .setCustomId('third_place')
                .setLabel('Third Place Username (1 point, optional)')
                .setPlaceholder('RetroAchievements username')
                .setStyle(TextInputStyle.Short)
                .setRequired(false);

            // Add time inputs (optional)
            const firstTimeInput = new TextInputBuilder()
                .setCustomId('first_time')
                .setLabel('First Place Time/Score (optional)')
                .setPlaceholder('e.g., 1:23.456 or 12345')
                .setStyle(TextInputStyle.Short)
                .setRequired(false);

            const secondTimeInput = new TextInputBuilder()
                .setCustomId('second_time')
                .setLabel('Second Place Time/Score (optional)')
                .setPlaceholder('e.g., 1:23.456 or 12345')
                .setStyle(TextInputStyle.Short)
                .setRequired(false);

            // Add inputs to modal
            const firstPlaceRow = new ActionRowBuilder().addComponents(firstPlaceInput);
            const secondPlaceRow = new ActionRowBuilder().addComponents(secondPlaceInput);
            const thirdPlaceRow = new ActionRowBuilder().addComponents(thirdPlaceInput);
            const firstTimeRow = new ActionRowBuilder().addComponents(firstTimeInput);
            const secondTimeRow = new ActionRowBuilder().addComponents(secondTimeInput);

            modal.addComponents(firstPlaceRow, secondPlaceRow, thirdPlaceRow, firstTimeRow, secondTimeRow);

            // Show the modal
            await interaction.showModal(modal);

            try {
                // Wait for modal submission
                const modalSubmission = await interaction.awaitModalSubmit({
                    time: 300000 // 5 minutes to fill out the form
                });

                await modalSubmission.deferUpdate();

                // Extract values from the modal
                const username1 = modalSubmission.fields.getTextInputValue('first_place');
                const username2 = modalSubmission.fields.getTextInputValue('second_place');
                const username3 = modalSubmission.fields.getTextInputValue('third_place');
                const time1 = modalSubmission.fields.getTextInputValue('first_time') || 'Manual Entry';
                const time2 = modalSubmission.fields.getTextInputValue('second_time') || 'Manual Entry';
                const time3 = 'Manual Entry'; // Third time is not included in the form due to Discord's 5 field limit

                // Create results array and track awarded users
                const results = [];
                const awardedUsers = [];
                
                // Get month abbreviation and year for award title
                const startDate = new Date(racingBoard.startDate);
                const monthAbbrev = startDate.toLocaleString('default', { month: 'short' });
                const year = startDate.getFullYear();
                
                // Award points configuration
                const pointsDistribution = [3, 2, 1]; // 1st, 2nd, 3rd place
                const placements = ['1st place', '2nd place', '3rd place'];
                
                // Process the usernames
                const usernames = [username1, username2, username3].filter(Boolean);
                const times = [time1, time2, time3];
                
                // Award points to each user
                for (let i = 0; i < usernames.length && i < 3; i++) {
                    try {
                        // Find the user (case-insensitive)
                        const user = await User.findOne({
                            raUsername: { $regex: new RegExp(`^${usernames[i]}import { 
    SlashCommandBuilder, 
    EmbedBuilder, 
    ActionRowBuilder, 
    StringSelectMenuBuilder,
    ButtonBuilder,
    ButtonStyle,
    ComponentType,
    ModalBuilder,
    TextInputBuilder,
    TextInputStyle,
    PermissionFlagsBits
} from 'discord.js';
import { User } from '../../models/User.js';
import { Challenge } from '../../models/Challenge.js';
import { ArcadeBoard } from '../../models/ArcadeBoard.js';
import { Poll } from '../../models/Poll.js';
import retroAPI from '../../services/retroAPI.js';
import { config } from '../../config/config.js';

// Constants
const MEMBER_ROLE_ID = '1316292690870014002';

export default {
    data: new SlashCommandBuilder()
        .setName('admin')
        .setDescription('Admin dashboard for managing all aspects of the community')
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild) // Require admin permissions
        // Challenge Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('challenge')
                .setDescription('Manage monthly and shadow challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('create')
                        .setDescription('Create or replace a monthly challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('shadow')
                        .setDescription('Add or edit a shadow challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('toggle')
                        .setDescription('Toggle shadow challenge visibility')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View current challenge details')
                )
        )
        
        // Arcade Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('arcade')
                .setDescription('Manage arcade boards and racing challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('add')
                        .setDescription('Add an arcade board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('racing')
                        .setDescription('Set up a racing challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('tiebreaker')
                        .setDescription('Create a tiebreaker board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Award points for a completed board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('announce')
                        .setDescription('Announce a board to the community')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View and manage existing boards')
                )
        )
        
        // User Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('user')
                .setDescription('Manage users, registrations, and awards')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('register')
                        .setDescription('Register a user')
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to register')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('unregister')
                        .setDescription('Unregister a user')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to unregister')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('purge')
                        .setDescription('Completely remove a user registration')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to purge')
                            .setRequired(true))
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to purge (optional)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Give a community award to a user')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('title')
                            .setDescription('The title of the award')
                            .setRequired(true))
                        .addIntegerOption(option =>
                            option.setName('points')
                            .setDescription('Number of points for this award')
                            .setRequired(true)
                            .setMinValue(1))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('awards')
                        .setDescription('View user awards')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('clear')
                        .setDescription('Clear nominations or awards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('reset')
                        .setDescription('Reset user achievements')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('RetroAchievements username')
                            .setRequired(true))
                )
        )
        
        // Voting Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('voting')
                .setDescription('Manage voting processes')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('start')
                        .setDescription('Start a voting poll')
                        .addChannelOption(option =>
                            option.setName('channel')
                            .setDescription('The channel to create the poll announcement in')
                            .setRequired(true))
                        .addChannelOption(option =>
                            option.setName('results_channel')
                            .setDescription('The channel to announce results in (defaults to same channel)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('cancel')
                        .setDescription('Cancel an active voting poll')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('status')
                        .setDescription('Check status of current voting')
                )
        )
        
        // System Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('system')
                .setDescription('System-level operations')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('update')
                        .setDescription('Force an update of all stats and leaderboards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('suggestions')
                        .setDescription('Manage community suggestions')
                )
        )
        
        // Info display subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('info')
                .setDescription('Display shareable information')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('arcade')
                        .setDescription('Display arcade board information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('challenges')
                        .setDescription('Display challenge information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('overview')
                        .setDescription('Display community overview')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('commands')
                        .setDescription('Display available commands')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('rules')
                        .setDescription('Display community rules')
                )
        ),

    async execute(interaction) {
        // Check if user has admin role
        if (!interaction.member.roles.cache.has(config.bot.roles.admin)) {
            return interaction.reply({
                content: 'You do not have permission to use this command.',
                ephemeral: true
            });
        }

        await interaction.deferReply({ ephemeral: true });

        try {
            // Extract subcommand group and subcommand
            const subcommandGroup = interaction.options.getSubcommandGroup();
            const subcommand = interaction.options.getSubcommand();
            
            // Route to the appropriate handler based on subcommand group and subcommand
            switch (subcommandGroup) {
                case 'challenge':
                    await this.handleChallengeCommand(interaction, subcommand);
                    break;
                case 'arcade':
                    await this.handleArcadeCommand(interaction, subcommand);
                    break;
                case 'user':
                    await this.handleUserCommand(interaction, subcommand);
                    break;
                case 'voting':
                    await this.handleVotingCommand(interaction, subcommand);
                    break;
                case 'system':
                    await this.handleSystemCommand(interaction, subcommand);
                    break;
                case 'info':
                    await this.handleInfoCommand(interaction, subcommand);
                    break;
                default:
                    await interaction.editReply('Invalid subcommand group.');
            }
        } catch (error) {
            console.error('Error executing admin command:', error);
            await interaction.editReply('An error occurred while processing your request.');
        }
    },

    // CHALLENGE MANAGEMENT HANDLERS
    async handleChallengeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'create':
                await this.handleCreateChallenge(interaction);
                break;
            case 'shadow':
                await this.handleShadowChallenge(interaction);
                break;
            case 'toggle':
                await this.handleToggleShadow(interaction);
                break;
            case 'view':
                await this.handleViewChallenge(interaction);
                break;
            default:
                await interaction.editReply('Invalid challenge subcommand.');
        }
    },

    async handleCreateChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Create Monthly Challenge')
            .setColor('#32CD32')
            .setDescription('Use this form to create or replace a monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'How to Find Achievement IDs',
                    value: 'Go to the game page on RetroAchievements, hover over an achievement, and note the ID number in the URL.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('create_challenge_form')
                    .setLabel('Open Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ®')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'create_challenge_form') {
                    // Create modal for challenge creation
                    const modal = new ModalBuilder()
                        .setCustomId('create_challenge_modal')
                        .setTitle('Create Monthly Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add year input
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Create date for the first of the specified month
                            const challengeDate = new Date(year, month - 1, 1);

                            // Check if a challenge already exists for this month
                            const existingChallenge = await Challenge.findOneAndDelete({
                                date: {
                                    $gte: challengeDate,
                                    $lt: new Date(year, month, 1)
                                }
                            });

                            // Create new challenge
                            const challenge = new Challenge({
                                date: challengeDate,
                                monthly_challange_gameid: gameId,
                                monthly_challange_progression_achievements: progressionAchievements,
                                monthly_challange_win_achievements: winAchievements,
                                monthly_challange_game_total: totalAchievements,
                                shadow_challange_revealed: false // Keep shadow challenge hidden by default
                            });

                            await challenge.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Monthly Challenge Created')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (existingChallenge) {
                                resultEmbed.setDescription(`Monthly challenge replaced for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: existingChallenge.monthly_challange_gameid.toString() },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Monthly challenge created for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('add_shadow')
                                        .setLabel('Add Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ‘¥'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'add_shadow') {
                                        await this.handleShadowChallenge(resultI, { month, year });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error creating challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while creating the challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to create a challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleShadowChallenge(interaction, prefilledData = null) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Shadow Challenge')
            .setColor('#9932CC') // Dark purple
            .setDescription('Use this form to add or edit a shadow challenge for a specific month.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'Shadow Challenge Rules',
                    value: 'Shadow challenges are hidden mysteries that players can discover by guessing or playing the challenge games. They automatically reveal for past months.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('shadow_challenge_form')
                    .setLabel('Open Shadow Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸ‘¥')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'shadow_challenge_form') {
                    // Create modal for shadow challenge
                    const modal = new ModalBuilder()
                        .setCustomId('shadow_challenge_modal')
                        .setTitle('Add Shadow Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input with prefilled data if available
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.month) {
                        monthInput.setValue(prefilledData.month.toString());
                    } else {
                        // Default to current month
                        const now = new Date();
                        monthInput.setValue((now.getMonth() + 1).toString());
                    }

                    // Add year input with prefilled data if available
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.year) {
                        yearInput.setValue(prefilledData.year.toString());
                    } else {
                        // Default to current year
                        const now = new Date();
                        yearInput.setValue(now.getFullYear().toString());
                    }

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get date range for the specified month
                            const monthStart = new Date(year, month - 1, 1);
                            const nextMonthStart = new Date(year, month, 1);

                            // Find the target challenge
                            const targetChallenge = await Challenge.findOne({
                                date: {
                                    $gte: monthStart,
                                    $lt: nextMonthStart
                                }
                            });

                            if (!targetChallenge) {
                                return modalSubmission.editReply(`No challenge exists for ${month}/${year}. Create a monthly challenge first using /admin challenge create.`);
                            }

                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Check if there's an existing shadow game to be replaced
                            let replacedShadowGame = null;
                            if (targetChallenge.shadow_challange_gameid) {
                                try {
                                    const oldGameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
                                    replacedShadowGame = oldGameInfo.title;
                                } catch (error) {
                                    console.error('Error fetching old shadow game info:', error);
                                    replacedShadowGame = targetChallenge.shadow_challange_gameid;
                                }
                            }

                            // Update the challenge with shadow game information
                            targetChallenge.shadow_challange_gameid = gameId;
                            targetChallenge.shadow_challange_progression_achievements = progressionAchievements;
                            targetChallenge.shadow_challange_win_achievements = winAchievements;
                            targetChallenge.shadow_challange_game_total = totalAchievements;
                            
                            // Automatically reveal shadow games for past months
                            const now = new Date();
                            if (month < now.getMonth() + 1 || year < now.getFullYear()) {
                                targetChallenge.shadow_challange_revealed = true;
                            } else if (!targetChallenge.shadow_challange_revealed) {
                                // For current or future months, keep shadow games hidden by default
                                targetChallenge.shadow_challange_revealed = false;
                            }

                            await targetChallenge.save();

                            // Get month name for display
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Determine if it was auto-revealed
                            const autoRevealed = (month < now.getMonth() + 1 || year < now.getFullYear());
                            
                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#9932CC') // Dark purple for shadow challenges
                                .setTitle('Shadow Challenge Added')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (replacedShadowGame) {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} replaced`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: replacedShadowGame },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} created`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() },
                                { name: 'Visibility', value: targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden' + (autoRevealed ? ' (Auto-revealed as past challenge)' : '') }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('toggle_shadow')
                                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'toggle_shadow') {
                                        await this.handleToggleShadow(resultI, { month, year, force: true });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding shadow challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the shadow challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a shadow challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleToggleShadow(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            let force = options?.force || false;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                const now = new Date();
                month = now.getMonth() + 1; // 1-indexed month
                year = now.getFullYear();
            }
            
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the target challenge
            const targetChallenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!targetChallenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            if (!targetChallenge.shadow_challange_gameid) {
                return interaction.editReply(`No shadow challenge has been set for ${month}/${year}.`);
            }

            // Toggle the visibility
            targetChallenge.shadow_challange_revealed = !targetChallenge.shadow_challange_revealed;
            await targetChallenge.save();

            // Get game info for the response
            const gameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
            
            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Create response embed
            const resultEmbed = new EmbedBuilder()
                .setColor(targetChallenge.shadow_challange_revealed ? '#00FF00' : '#FF0000') // Green for revealed, red for hidden
                .setTitle(`Shadow Challenge ${targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden'}`)
                .setDescription(`The shadow challenge for ${monthName} ${year} is now ${targetChallenge.shadow_challange_revealed ? 'REVEALED' : 'HIDDEN'}.`)
                .setTimestamp();

            if (targetChallenge.shadow_challange_revealed) {
                resultEmbed.addFields(
                    { name: 'Game', value: gameInfo.title },
                    { name: 'Required Progression Achievements', value: targetChallenge.shadow_challange_progression_achievements.length.toString() },
                    { name: 'Required Win Achievements', value: targetChallenge.shadow_challange_win_achievements.length > 0 ? targetChallenge.shadow_challange_win_achievements.length.toString() : 'None' }
                );
                
                if (gameInfo.imageIcon) {
                    resultEmbed.setThumbnail(`https://retroachievements.org${gameInfo.imageIcon}`);
                }
            }

            // Add action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow_again')
                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                    new ButtonBuilder()
                        .setCustomId('view_challenge')
                        .setLabel('View Challenge Details')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ”')
                );

            // If we're force-updating from another command, use editReply
            // Otherwise, use standard reply
            if (force) {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            } else {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            }

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'toggle_shadow_again') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    } else if (i.customId === 'view_challenge') {
                        await this.handleViewChallenge(i, { month, year });
                    }
                }
            });

        } catch (error) {
            console.error('Error toggling shadow challenge visibility:', error);
            await interaction.editReply('An error occurred while toggling the shadow challenge visibility. Please try again.');
        }
    },

    async handleViewChallenge(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                // Open a form to select month/year
                const embed = new EmbedBuilder()
                    .setTitle('View Challenge Details')
                    .setColor('#3498DB')
                    .setDescription('Please select which challenge you want to view.')
                    .addFields(
                        {
                            name: 'Options',
                            value: 'You can view the current month\'s challenge or select a specific month.'
                        }
                    );

                // Create buttons
                const row = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('view_current_challenge')
                            .setLabel('Current Month')
                            .setStyle(ButtonStyle.Primary)
                            .setEmoji('ðŸ“…'),
                        new ButtonBuilder()
                            .setCustomId('select_month_challenge')
                            .setLabel('Select Month')
                            .setStyle(ButtonStyle.Secondary)
                            .setEmoji('ðŸ”')
                    );

                await interaction.editReply({
                    embeds: [embed],
                    components: [row]
                });

                // Set up collector for the buttons
                const message = await interaction.fetchReply();
                const buttonCollector = message.createMessageComponentCollector({
                    componentType: ComponentType.Button,
                    time: 300000 // 5 minutes timeout
                });

                buttonCollector.on('collect', async i => {
                    if (i.user.id === interaction.user.id) {
                        await i.deferUpdate();

                        if (i.customId === 'view_current_challenge') {
                            // Use current month
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                            
                            // Continue with viewing the challenge
                            await this.displayChallengeDetails(i, month, year);
                            
                            // Stop the collector
                            buttonCollector.stop();
                        } else if (i.customId === 'select_month_challenge') {
                            // Show modal to select month/year
                            const modal = new ModalBuilder()
                                .setCustomId('select_challenge_month_modal')
                                .setTitle('Select Challenge Month');

                            // Add month input
                            const monthInput = new TextInputBuilder()
                                .setCustomId('month')
                                .setLabel('Month (1-12)')
                                .setPlaceholder('Example: 5 (for May)')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add year input
                            const yearInput = new TextInputBuilder()
                                .setCustomId('year')
                                .setLabel('Year')
                                .setPlaceholder('Example: 2025')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add inputs to modal
                            const monthRow = new ActionRowBuilder().addComponents(monthInput);
                            const yearRow = new ActionRowBuilder().addComponents(yearInput);

                            modal.addComponents(monthRow, yearRow);

                            // Show the modal
                            await i.showModal(modal);

                            try {
                                // Wait for modal submission
                                const modalSubmission = await i.awaitModalSubmit({
                                    time: 300000 // 5 minutes to fill out the form
                                });

                                await modalSubmission.deferUpdate();

                                // Extract values from the modal
                                month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                                year = parseInt(modalSubmission.fields.getTextInputValue('year'));

                                // Validate inputs
                                if (isNaN(month) || month < 1 || month > 12) {
                                    return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                                }

                                if (isNaN(year) || year < 2000 || year > 2100) {
                                    return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                                }

                                // Continue with viewing the challenge
                                await this.displayChallengeDetails(modalSubmission, month, year);
                                
                                // Stop the collector
                                buttonCollector.stop();

                            } catch (modalError) {
                                console.error('Error handling modal submission:', modalError);
                                // Modal timed out or was cancelled
                            }
                        }
                    }
                });

                // Let the function end here and let the collector handle the rest
                return;
            }

            // If we have month/year, display the challenge
            await this.displayChallengeDetails(interaction, month, year);

        } catch (error) {
            console.error('Error viewing challenge:', error);
            await interaction.editReply('An error occurred while viewing the challenge. Please try again.');
        }
    },

    async displayChallengeDetails(interaction, month, year) {
        try {
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the challenge
            const challenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!challenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Get game info for monthly challenge
            let monthlyGameInfo = null;
            if (challenge.monthly_challange_gameid) {
                monthlyGameInfo = await retroAPI.getGameInfo(challenge.monthly_challange_gameid);
            }

            // Get game info for shadow challenge if revealed
            let shadowGameInfo = null;
            if (challenge.shadow_challange_gameid && challenge.shadow_challange_revealed) {
                shadowGameInfo = await retroAPI.getGameInfo(challenge.shadow_challange_gameid);
            }

            // Create main embed
            const embed = new EmbedBuilder()
                .setTitle(`Challenge Details: ${monthName} ${year}`)
                .setColor('#3498DB')
                .setDescription(`Here are the details for the ${monthName} ${year} challenges:`)
                .setTimestamp();

            // Add monthly challenge info
            if (monthlyGameInfo) {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: `**Game:** ${monthlyGameInfo.title}\n` +
                          `**Required Progression Achievements:** ${challenge.monthly_challange_progression_achievements.length}\n` +
                          `**Required Win Achievements:** ${challenge.monthly_challange_win_achievements.length}\n` +
                          `**Total Achievements:** ${challenge.monthly_challange_game_total}\n` +
                          `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.monthly_challange_gameid})`
                });

                if (monthlyGameInfo.imageIcon) {
                    embed.setThumbnail(`https://retroachievements.org${monthlyGameInfo.imageIcon}`);
                }
            } else {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: 'No monthly challenge set.'
                });
            }

            // Add shadow challenge info
            if (challenge.shadow_challange_gameid) {
                if (challenge.shadow_challange_revealed && shadowGameInfo) {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (REVEALED)',
                        value: `**Game:** ${shadowGameInfo.title}\n` +
                              `**Required Progression Achievements:** ${challenge.shadow_challange_progression_achievements.length}\n` +
                              `**Required Win Achievements:** ${challenge.shadow_challange_win_achievements.length}\n` +
                              `**Total Achievements:** ${challenge.shadow_challange_game_total}\n` +
                              `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.shadow_challange_gameid})`
                    });
                } else {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (HIDDEN)',
                        value: 'Shadow challenge exists but is currently hidden.\n' +
                              `Use \`/admin challenge toggle\` to reveal it.`
                    });
                }
            } else {
                embed.addFields({
                    name: 'ðŸ‘¥ Shadow Challenge',
                    value: 'No shadow challenge set.\n' +
                          `Use \`/admin challenge shadow\` to add one.`
                });
            }

            // Create action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('edit_monthly')
                        .setLabel('Edit Monthly Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('ðŸ†'),
                    new ButtonBuilder()
                        .setCustomId('edit_shadow')
                        .setLabel(challenge.shadow_challange_gameid ? 'Edit Shadow Challenge' : 'Add Shadow Challenge')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ‘¥')
                );

            // Add toggle button if shadow challenge exists
            if (challenge.shadow_challange_gameid) {
                actionRow.addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow')
                        .setLabel(challenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji(challenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸')
                );
            }

            await interaction.editReply({
                embeds: [embed],
                components: [actionRow]
            });

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'edit_monthly') {
                        await this.handleCreateChallenge(i);
                    } else if (i.customId === 'edit_shadow') {
                        await this.handleShadowChallenge(i, { month, year });
                    } else if (i.customId === 'toggle_shadow') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    }
                }
            });

        } catch (error) {
            console.error('Error displaying challenge details:', error);
            await interaction.editReply('An error occurred while retrieving challenge details. Please try again.');
        }
    },

    // ARCADE MANAGEMENT HANDLERS
    async handleArcadeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'add':
                await this.handleAddArcadeBoard(interaction);
                break;
            case 'racing':
                await this.handleAddRacingChallenge(interaction);
                break;
            case 'tiebreaker':
                await this.handleAddTiebreaker(interaction);
                break;
            case 'award':
                await this.handleAwardPoints(interaction);
                break;
            case 'announce':
                await this.handleAnnounceBoard(interaction);
                break;
            case 'view':
                await this.handleViewBoards(interaction);
                break;
            default:
                await interaction.editReply('Invalid arcade subcommand.');
        }
    },

    async handleAddArcadeBoard(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Arcade Board')
            .setColor('#9B59B6') // Purple
            .setDescription('Use this form to add a new arcade board to the community.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Board ID (unique identifier)\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description'
                },
                {
                    name: 'How to Find IDs',
                    value: '**Game ID**: The number at the end of the game URL on RetroAchievements\n**Leaderboard ID**: The number at the end of the leaderboard URL'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_arcade_form')
                    .setLabel('Open Arcade Board Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ¯')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_arcade_form') {
                    // Create modal for arcade board
                    const modal = new ModalBuilder()
                        .setCustomId('add_arcade_modal')
                        .setTitle('Add Arcade Board');

                    // Add board ID input
                    const boardIdInput = new TextInputBuilder()
                        .setCustomId('board_id')
                        .setLabel('Board ID (unique identifier)')
                        .setPlaceholder('Example: sonic3-special-stages')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this arcade board challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add inputs to modal
                    const boardIdRow = new ActionRowBuilder().addComponents(boardIdInput);
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);

                    modal.addComponents(boardIdRow, gameIdRow, leaderboardIdRow, descriptionRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const boardId = modalSubmission.fields.getTextInputValue('board_id');
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        try {
                            // Check if board ID already exists
                            const existingBoard = await ArcadeBoard.findOne({ boardId });
                            if (existingBoard) {
                                return modalSubmission.editReply(`A board with ID "${boardId}" already exists.`);
                            }

                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Create new board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'arcade',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description
                            });

                            await newBoard.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Arcade Board Added')
                                .setDescription(`Successfully added "${gameInfo.title}" arcade board!`)
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .addFields(
                                    { name: 'Board ID', value: boardId },
                                    { name: 'Game', value: gameInfo.title },
                                    { name: 'Console', value: gameInfo.consoleName || 'Unknown' },
                                    { name: 'Description', value: description }
                                )
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_board')
                                        .setLabel('Announce Board')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_board') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding arcade board:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the arcade board. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add an arcade board.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddRacingChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Racing Challenge')
            .setColor('#FF9900') // Orange
            .setDescription('Use this form to set up a monthly racing challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Track Name\nâ€¢ Description\nâ€¢ Month and Year (optional, defaults to current month)'
                },
                {
                    name: 'Racing Challenge Rules',
                    value: 'Racing challenges are monthly competitions where players compete on time-based leaderboards. The top 3 players will receive community points.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_racing_form')
                    .setLabel('Open Racing Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_racing_form') {
                    // Create modal for racing challenge
                    const modal = new ModalBuilder()
                        .setCustomId('add_racing_modal')
                        .setTitle('Add Racing Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add track name input
                    const trackNameInput = new TextInputBuilder()
                        .setCustomId('track_name')
                        .setLabel('Track Name')
                        .setPlaceholder('Example: Rainbow Road')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this racing challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add month/year input
                    const monthYearInput = new TextInputBuilder()
                        .setCustomId('month_year')
                        .setLabel('Month and Year (optional, MM/YYYY format)')
                        .setPlaceholder('Example: 05/2025 (defaults to current month)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const trackNameRow = new ActionRowBuilder().addComponents(trackNameInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthYearInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, trackNameRow, descriptionRow, monthYearRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const trackName = modalSubmission.fields.getTextInputValue('track_name');
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const monthYearInput = modalSubmission.fields.getTextInputValue('month_year');

                        // Parse month and year
                        let month, year;
                        if (monthYearInput && monthYearInput.trim()) {
                            const parts = monthYearInput.split('/');
                            if (parts.length === 2) {
                                month = parseInt(parts[0]);
                                year = parseInt(parts[1]);
                            } else {
                                // Invalid format, use current month/year
                                const now = new Date();
                                month = now.getMonth() + 1;
                                year = now.getFullYear();
                            }
                        } else {
                            // No input, use current month/year
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                        }

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Calculate start and end dates
                            // Start at beginning of specified month
                            const startDate = new Date(year, month - 1, 1);
                            
                            // End at the end of the specified month (23:59:59 on the last day)
                            const endDate = new Date(year, month, 0, 23, 59, 59);
                            
                            // Check if a racing challenge already exists for this month
                            const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                            const existingChallenge = await ArcadeBoard.findOne({
                                boardType: 'racing',
                                monthKey
                            });

                            if (existingChallenge) {
                                return modalSubmission.editReply(`A racing challenge already exists for ${monthKey}.`);
                            }

                            // Generate a unique board ID specifically for racing
                            // This format ensures no overlap with regular arcade boards
                            const boardId = `racing-${monthKey}`;

                            // Get the full game title and console name
                            const gameFull = `${gameInfo.title} (${gameInfo.consoleName})`;

                            // Create new racing board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'racing',
                                leaderboardId,
                                gameId,
                                gameTitle: gameFull,
                                trackName,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate,
                                endDate,
                                monthKey
                            });

                            await newBoard.save();

                            // Get month name for response
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF9900') // Orange for racing
                                .setTitle(`Racing Challenge Created: ${monthName} ${year}`)
                                .setDescription(
                                    `**Game:** ${gameFull}\n` +
                                    `**Track:** ${trackName}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Challenge Period:** ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `The top 3 players at the end of the month will receive award points!`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_racing')
                                        .setLabel('Announce Racing Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_racing') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding racing challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the racing challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a racing challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddTiebreaker(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Tiebreaker')
            .setColor('#FF0000') // Red
            .setDescription('Use this form to create a tiebreaker leaderboard for the monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description\nâ€¢ End Date (YYYY-MM-DD format)'
                },
                {
                    name: 'Tiebreaker Rules',
                    value: 'Tiebreakers are used to resolve ties in the monthly challenge leaderboard. Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_tiebreaker_form')
                    .setLabel('Open Tiebreaker Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('âš”ï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_tiebreaker_form') {
                    // Create modal for tiebreaker
                    const modal = new ModalBuilder()
                        .setCustomId('add_tiebreaker_modal')
                        .setTitle('Add Tiebreaker');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this tiebreaker challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add end date input
                    const endDateInput = new TextInputBuilder()
                        .setCustomId('end_date')
                        .setLabel('End Date (YYYY-MM-DD format)')
                        .setPlaceholder('Example: 2025-05-31')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const endDateRow = new ActionRowBuilder().addComponents(endDateInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, descriptionRow, endDateRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const endDateStr = modalSubmission.fields.getTextInputValue('end_date');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        // Parse end date
                        const endDate = new Date(endDateStr);
                        if (isNaN(endDate.getTime())) {
                            return modalSubmission.editReply('Invalid end date format. Please use YYYY-MM-DD.');
                        }

                        // Set end time to 23:59:59
                        endDate.setHours(23, 59, 59);

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Check if an active tiebreaker already exists
                            const now = new Date();
                            const activeTiebreaker = await ArcadeBoard.findOne({
                                boardType: 'tiebreaker',
                                startDate: { $lte: now },
                                endDate: { $gte: now }
                            });

                            if (activeTiebreaker) {
                                return modalSubmission.editReply('An active tiebreaker already exists. Please end it before creating a new one.');
                            }

                            // Generate a unique board ID based on month and year
                            const monthYear = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}`;
                            const boardId = `tiebreaker-${monthYear}`;

                            // Create new tiebreaker board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'tiebreaker',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate: now,
                                endDate,
                                // Add monthKey for consistency with racing challenges
                                monthKey: monthYear
                            });

                            await newBoard.save();

                            // Get the month name
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[now.getMonth()];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF0000') // Red for tiebreaker
                                .setTitle(`âš”ï¸ Tiebreaker Created: ${monthName} ${now.getFullYear()}`)
                                .setDescription(
                                    `**Game:** ${gameInfo.title}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Tiebreaker Period:** ${now.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `This tiebreaker will be used to resolve ties in the ${monthName} monthly challenge leaderboard. ` +
                                    `Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_tiebreaker')
                                        .setLabel('Announce Tiebreaker')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_tiebreaker') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding tiebreaker:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the tiebreaker. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a tiebreaker.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAwardPoints(interaction) {
        // Create select board form
        const embed = new EmbedBuilder()
            .setTitle('Award Points')
            .setColor('#32CD32') // Lime green
            .setDescription('Select a board to award points for.')
            .addFields(
                {
                    name: 'Award Points',
                    value: 'You can award points for completed racing challenges or arcade boards. For racing challenges, points are awarded to the top 3 players. For arcade boards, points are awarded annually.'
                }
            );

        // Find all racing boards and tiebreakers
        const racingBoards = await ArcadeBoard.find({ 
            boardType: 'racing',
            pointsAwarded: { $ne: true } // Only show boards that haven't been awarded points yet
        }).sort({ startDate: -1 });

        // Create options for racing boards
        const boardOptions = racingBoards.map(board => {
            const monthYear = board.monthKey || 'Unknown Date';
            return {
                label: `Racing: ${board.gameTitle}${board.trackName ? ` - ${board.trackName}` : ''}`,
                description: `${monthYear}`,
                value: `racing-${board.boardId}`
            };
        });

        // Add option for annual arcade awards if any arcade boards exist
        const arcadeBoards = await ArcadeBoard.find({ boardType: 'arcade' });
        if (arcadeBoards.length > 0) {
            boardOptions.push({
                label: 'Annual Arcade Awards',
                description: 'Award points for all arcade boards for the current year',
                value: 'arcade-annual'
            });
        }

        // Create dropdown if we have options
        if (boardOptions.length === 0) {
            return interaction.editReply('No eligible boards found for awarding points. All racing challenges have already been awarded points, or no racing challenges exist.');
        }

        // Create the dropdown
        const row = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('select_board_for_award')
                    .setPlaceholder('Select a board to award points')
                    .addOptions(boardOptions)
            );

        // Send the selection menu
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the dropdown selection
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.StringSelect,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                await i.deferUpdate();
                
                const selectedValue = i.values[0];
                
                if (selectedValue.startsWith('racing-')) {
                    // Extract board ID
                    const boardId = selectedValue.substring(7);
                    await this.awardRacingPoints(i, boardId);
                } else if (selectedValue === 'arcade-annual') {
                    await this.awardArcadePoints(i);
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        StringSelectMenuBuilder.from(row.components[0])
                            .setDisabled(true)
                            .setPlaceholder('Selection timed out')
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This selection has expired. Please run the command again if you still need to award points.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling dropdown:', error);
                }
            }
        });
    },

    async awardRacingPoints(interaction, boardId) {
        try {
            // Find the racing board
            const racingBoard = await ArcadeBoard.findOne({ 
                boardId,
                boardType: 'racing'
            });

            if (!racingBoard) {
                return interaction.editReply(`Racing board with ID "${boardId}" not found.`);
            }

            // Check if points have already been awarded
            if (racingBoard.pointsAwarded) {
                return interaction.editReply(`Points have already been awarded for this racing challenge.`);
            }

            // Check if the racing challenge has ended
            const now = new Date();
            if (racingBoard.endDate > now) {
                return interaction.editReply(`This racing challenge hasn't ended yet. It ends on ${racingBoard.endDate.toLocaleDateString()}.`);
            }

, 'i') }
                        });
                        
                        if (!user) {
                            console.warn(`User ${usernames[i]} not found, skipping awards`);
                            continue;
                        }
                        
                        // Points and placement
                        const points = pointsDistribution[i];
                        const placement = placements[i];
                        
                        // Create award title in concise format
                        const awardTitle = `${monthAbbrev} ${year} Racing - ${placement}`;
                        
                        // Add award to the user
                        user.communityAwards.push({
                            title: awardTitle,
                            points: points,
                            awardedAt: new Date(),
                            awardedBy: interaction.user.tag
                        });
                        
                        await user.save();
                        awardedUsers.push(user.raUsername);
                        
                        // Add to results array for the racing board
                        results.push({
                            username: user.raUsername,
                            rank: i + 1,
                            time: times[i],
                            points: points
                        });
                    } catch (userError) {
                        console.error(`Error processing user ${usernames[i]}:`, userError);
                    }
                }
                
                // Update the racing board
                racingBoard.pointsAwarded = true;
                racingBoard.results = results;
                await racingBoard.save();
                
                // Get the month and year for display
                const monthName = startDate.toLocaleString('default', { month: 'long' });
                
                // Create response embed
                const resultEmbed = new EmbedBuilder()
                    .setColor('#00FF00') // Green for success
                    .setTitle('Racing Points Awarded')
                    .setDescription(`Successfully marked ${monthName} ${year} racing board as completed and awarded points!`)
                    .addFields(
                        {
                            name: 'Board',
                            value: `**${racingBoard.gameTitle}${racingBoard.trackName ? ` - ${racingBoard.trackName}` : ''}**`
                        }
                    )
                    .setTimestamp();
                
                // Add results to embed
                const resultsField = results.map(result => {
                    const medalEmoji = result.rank === 1 ? 'ðŸ¥‡' : (result.rank === 2 ? 'ðŸ¥ˆ' : 'ðŸ¥‰');
                    return `${medalEmoji} **${result.username}**: ${result.time} (${result.points} point${result.points !== 1 ? 's' : ''})`;
                }).join('\n');
                
                resultEmbed.addFields({ 
                    name: 'Results',
                    value: resultsField || 'No results found.' 
                });
                
                if (awardedUsers.length > 0) {
                    resultEmbed.addFields({
                        name: 'Status',
                        value: `âœ… Points awarded to: ${awardedUsers.join(', ')}`
                    });
                } else {
                    resultEmbed.addFields({
                        name: 'Status',
                        value: `âš ï¸ No points were awarded. Check for errors in the usernames.`
                    });
                }
                
                // Add navigation button
                const actionRow = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('view_boards')
                            .setLabel('View All Boards')
                            .setStyle(ButtonStyle.Secondary)
                            .setEmoji('ðŸ”')
                    );
                
                await modalSubmission.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
                
                // Set up collector for the navigation button
                const message = await modalSubmission.fetchReply();
                const collector = message.createMessageComponentCollector({
                    componentType: ComponentType.Button,
                    time: 300000 // 5 minutes timeout
                });
                
                collector.on('collect', async i => {
                    if (i.user.id === interaction.user.id) {
                        await i.deferUpdate();
                        
                        if (i.customId === 'view_boards') {
                            await this.handleViewBoards(i);
                        }
                    }
                });
                
            } catch (modalError) {
                console.error('Error handling modal submission:', modalError);
                // Modal timed out or was cancelled
            }
        } catch (error) {
            console.error('Error with manual racing awards:', error);
            await interaction.editReply('An error occurred while setting up manual racing awards. Please try again.');
        }
    },

    async awardArcadePoints(interaction) {
        try {
            // Show confirmation dialog
            const embed = new EmbedBuilder()
                .setTitle('Award Annual Arcade Points')
                .setColor('#9B59B6') // Purple for arcade
                .setDescription('This will award points for all arcade boards for the current year. This process can take several minutes to complete.')
                .addFields(
                    {
                        name: 'Process',
                        value: 'The system will check all arcade boards and award points to the top 3 players on each board. 1st place gets 3 points, 2nd place gets 2 points, and 3rd place gets 1 point.'
                    },
                    {
                        name: 'Confirmation',
                        value: 'Are you sure you want to proceed with awarding annual arcade points?'
                    }
                );

            // Create confirmation buttons
            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('confirm_arcade_awards')
                        .setLabel('Confirm')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('âœ…'),
                    new ButtonBuilder()
                        .setCustomId('cancel_arcade_awards')
                        .setLabel('Cancel')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('âŒ')
                );

            await interaction.editReply({
                embeds: [embed],
                components: [row]
            });

            // Set up collector for the confirmation buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'confirm_arcade_awards') {
                        // Show processing message
                        await i.editReply({
                            content: 'Triggering arcade awards process... This may take a few minutes.',
                            embeds: [],
                            components: []
                        });
                        
                        try {
                            // Import arcadeService
                            const arcadeService = (await import('../../services/arcadeService.js')).default;
                            
                            // Set client if needed
                            if (!arcadeService.client) {
                                arcadeService.setClient(interaction.client);
                            }
                            
                            // Run the arcade points award process
                            await arcadeService.awardArcadePoints();
                            
                            // Show success message
                            const successEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Annual Arcade Awards Completed')
                                .setDescription('The arcade awards process has been completed successfully!')
                                .setTimestamp();
                                
                            await i.editReply({
                                content: null,
                                embeds: [successEmbed],
                                components: []
                            });
                        } catch (error) {
                            console.error('Error triggering arcade awards:', error);
                            await i.editReply('An error occurred while processing arcade awards. Check the logs for details.');
                        }
                    } else if (i.customId === 'cancel_arcade_awards') {
                        await i.editReply({
                            content: 'Annual arcade awards process cancelled.',
                            embeds: [],
                            components: []
                        });
                    }
                }
            });
        } catch (error) {
            console.error('Error with arcade awards:', error);
            await interaction.editReply('An error occurred while setting up arcade awards. Please try again.');
        }
    },

    async handleAnnounceBoard(interaction) {
        // Create board selection form
        const embed = new EmbedBuilder()
            .setTitle('Announce Board')
            .setColor('#3498DB') // Blue
            .setDescription('Select a board to announce to the community.')
            .addFields(
                {
                    name: 'Announcement',
                    value: 'The selected board will be announced in the main announcement channel.'
                }
            );

        // Find all boards that haven't been announced
        const boards = await ArcadeBoard.find().sort({ createdAt: -1 });

        // Create options for boards
        const boardOptions = boards.map(board => {
            let typeEmoji, typeLabel;
            
            switch (board.boardType) {
                case 'arcade':
                    typeEmoji = 'ðŸŽ¯';
                    typeLabel = 'Arcade';
                    break;
                case 'racing':
                    typeEmoji = 'ðŸŽï¸';
                    typeLabel = 'Racing';
                    break;
                case 'tiebreaker':
                    typeEmoji = 'âš”ï¸';
                    typeLabel = 'Tiebreaker';
                    break;
                default:
                    typeEmoji = 'ðŸŽ®';
                    typeLabel = 'Board';
            }
            
            return {
                label: `${typeLabel}: ${board.gameTitle}${board.trackName ? ` - ${board.trackName}` : ''}`,
                description: `ID: ${board.boardId}`,
                value: board.boardId,
                emoji: typeEmoji
            };
        });

        // Create the dropdown if we have options
        if (boardOptions.length === 0) {
            return interaction.editReply('No boards found to announce.');
        }

        // Create the dropdown
        const row = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('select_board_for_announcement')
                    .setPlaceholder('Select a board to announce')
                    .addOptions(boardOptions)
            );

        // Send the selection menu
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the dropdown selection
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.StringSelect,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                await i.deferUpdate();
                
                const boardId = i.values[0];
                await this.announceBoard(i, boardId);
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        StringSelectMenuBuilder.from(row.components[0])
                            .setDisabled(true)
                            .setPlaceholder('Selection timed out')
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This selection has expired. Please run the command again if you still need to announce a board.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling dropdown:', error);
                }
            }
        });
    },

    async announceBoard(interaction, boardId) {
        try {
            // Find the board
            const board = await ArcadeBoard.findOne({ boardId });
            if (!board) {
                return interaction.editReply(`Board with ID "${boardId}" not found.`);
            }

            // Import arcadeService
            const arcadeService = (await import('../../services/arcadeService.js')).default;
            
            // Set client if needed
            if (!arcadeService.client) {
                arcadeService.setClient(interaction.client);
            }
            
            // Show processing message
            await interaction.editReply({
                content: `Announcing board "${board.gameTitle}"... Please wait.`,
                embeds: [],
                components: []
            });
            
            // Different announcement based on board type
            if (board.boardType === 'racing') {
                await arcadeService.announceNewRacingChallenge(board);
                
                // Show success message
                const successEmbed = new EmbedBuilder()
                    .setColor('#00FF00') // Green for success
                    .setTitle('Racing Challenge Announced')
                    .setDescription(`Racing challenge "${board.gameTitle}${board.trackName ? ` - ${board.trackName}` : ''}" has been announced!`)
                    .setTimestamp();
                    
                await interaction.editReply({
                    content: null,
                    embeds: [successEmbed],
                    components: []
                });
                
            } else if (board.boardType === 'arcade') {
                // Get the announcement channel
                const channel = await this.getAnnouncementChannel(interaction.client);
                if (!channel) {
                    return interaction.editReply('Announcement channel not found.');
                }
                
                // Get game info
                const gameInfo = await retroAPI.getGameInfo(board.gameId);
                
                // Create an announcement embed
                const announceEmbed = new EmbedBuilder()
                    .setColor('#0099ff')
                    .setTitle(`ðŸŽ® New Arcade Board: ${board.gameTitle}`)
                    .setDescription(
                        `A new arcade leaderboard has been added!\n\n` +
                        `**Game:** ${board.gameTitle}\n` +
                        `**Description:** ${board.description}\n\n` +
                        `Check it out with \`/arcade board id:${board.boardId}\``
                    )
                    .setTimestamp();
                
                if (gameInfo?.imageIcon) {
                    announceEmbed.setThumbnail(`https://retroachievements.org${gameInfo.imageIcon}`);
                }
                
                await channel.send({ embeds: [announceEmbed] });
                
                // Show success message
                const successEmbed = new EmbedBuilder()
                    .setColor('#00FF00') // Green for success
                    .setTitle('Arcade Board Announced')
                    .setDescription(`Arcade board "${board.gameTitle}" has been announced!`)
                    .setTimestamp();
                    
                await interaction.editReply({
                    content: null,
                    embeds: [successEmbed],
                    components: []
                });
                
            } else if (board.boardType === 'tiebreaker') {
                // Get the announcement channel
                const channel = await this.getAnnouncementChannel(interaction.client);
                if (!channel) {
                    return interaction.editReply('Announcement channel not found.');
                }
                
                // Get game info
                const gameInfo = await retroAPI.getGameInfo(board.gameId);
                
                // Get month name for display
                const now = new Date();
                const monthNames = ["January", "February", "March", "April", "May", "June",
                                "July", "August", "September", "October", "November", "December"];
                const monthName = monthNames[now.getMonth()];
                
                // Create an announcement embed
                const announceEmbed = new EmbedBuilder()
                    .setColor('#FF0000') // Red for tiebreakers
                    .setTitle(`âš”ï¸ New Tiebreaker: ${board.gameTitle}`)
                    .setDescription(
                        `A tiebreaker for the ${monthName} monthly challenge has been added!\n\n` +
                        `**Game:** ${board.gameTitle}\n` +
                        `**Description:** ${board.description}\n` +
                        `**End Date:** ${board.endDate.toLocaleDateString()}\n\n` +
                        `This tiebreaker will be used to resolve ties in the ${monthName} monthly challenge leaderboard. ` +
                        `Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.\n\n` +
                        `Check it out with \`/arcade tiebreaker\``
                    )
                    .setTimestamp();
                
                if (gameInfo?.imageIcon) {
                    announceEmbed.setThumbnail(`https://retroachievements.org${gameInfo.imageIcon}`);
                }
                
                await channel.send({ embeds: [announceEmbed] });
                
                // Show success message
                const successEmbed = new EmbedBuilder()
                    .setColor('#00FF00') // Green for success
                    .setTitle('Tiebreaker Announced')
                    .setDescription(`Tiebreaker "${board.gameTitle}" has been announced!`)
                    .setTimestamp();
                    
                await interaction.editReply({
                    content: null,
                    embeds: [successEmbed],
                    components: []
                });
            } else {
                return interaction.editReply(`Cannot announce board of type "${board.boardType}".`);
            }
        } catch (error) {
            console.error('Error announcing board:', error);
            await interaction.editReply('An error occurred while announcing the board. Please try again.');
        }
    },

    async getAnnouncementChannel(client) {
        try {
            // Get the guild
            const guild = await client.guilds.fetch(config.discord.guildId);
            if (!guild) {
                console.error('Guild not found');
                return null;
            }

            // Get the announcement channel
            return await guild.channels.fetch(config.discord.announcementChannelId);
        } catch (error) {
            console.error('Error getting announcement channel:', error);
            return null;
        }
    },

    async handleViewBoards(interaction) {
        // Create board type selection
        const embed = new EmbedBuilder()
            .setTitle('View Boards')
            .setColor('#3498DB') // Blue
            .setDescription('Select a board type to view.')
            .addFields(
                {
                    name: 'Board Types',
                    value: 'You can view arcade boards, racing challenges, or tiebreakers.'
                }
            );

        // Create the selection buttons
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('view_arcade_boards')
                    .setLabel('Arcade Boards')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ¯'),
                new ButtonBuilder()
                    .setCustomId('view_racing_boards')
                    .setLabel('Racing Challenges')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽï¸'),
                new ButtonBuilder()
                    .setCustomId('view_tiebreaker_boards')
                    .setLabel('Tiebreakers')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('âš”ï¸')
            );

        await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button selection
        const message = await interaction.fetchReply();
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                await i.deferUpdate();
                
                if (i.customId === 'view_arcade_boards') {
                    await this.viewBoardsByType(i, 'arcade');
                } else if (i.customId === 'view_racing_boards') {
                    await this.viewBoardsByType(i, 'racing');
                } else if (i.customId === 'view_tiebreaker_boards') {
                    await this.viewBoardsByType(i, 'tiebreaker');
                }
            }
        });
    },

    async viewBoardsByType(interaction, boardType) {
        try {
            // Find boards of the specified type
            const boards = await ArcadeBoard.find({ boardType }).sort({ createdAt: -1 });
            
            if (boards.length === 0) {
                return interaction.editReply(`No ${boardType} boards found.`);
            }
            
            // Create the embed
            const embed = new EmbedBuilder()
                .setTitle(`${boardType.charAt(0).toUpperCase() + boardType.slice(1)} Boards`)
                .setColor(boardType === 'arcade' ? '#9B59B6' : boardType === 'racing' ? '#FF9900' : '#FF0000')
                .setDescription(`Found ${boards.length} ${boardType} board${boards.length !== 1 ? 's' : ''}. Select a board to manage it.`)
                .setTimestamp();
                
            // Create options for the dropdown
            const boardOptions = boards.map(board => {
                let description;
                
                if (boardType === 'racing') {
                    const monthKey = board.monthKey || 'Unknown Date';
                    description = `${monthKey}${board.trackName ? ` - ${board.trackName}` : ''}`;
                } else {
                    description = `ID: ${board.boardId}`;
                }
                
                return {
                    label: `${board.gameTitle}`.substring(0, 100), // Discord limits label length
                    description: description.substring(0, 100), // Discord limits description length
                    value: board.boardId
                };
            });
            
            // Create the dropdown
            const row = new ActionRowBuilder()
                .addComponents(
                    new StringSelectMenuBuilder()
                        .setCustomId('select_board_to_manage')
                        .setPlaceholder(`Select a ${boardType} board to manage`)
                        .addOptions(boardOptions)
                );
                
            // Add back button
            const backRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('back_to_board_types')
                        .setLabel('Back to Board Types')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('â†©ï¸')
                );
                
            await interaction.editReply({
                embeds: [embed],
                components: [row, backRow]
            });
            
            // Set up collector for the interactions
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                time: 300000 // 5 minutes timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'select_board_to_manage') {
                        const selectedBoardId = i.values[0];
                        await this.manageBoardDetails(i, selectedBoardId);
                    } else if (i.customId === 'back_to_board_types') {
                        await this.handleViewBoards(i);
                    }
                }
            });
        } catch (error) {
            console.error(`Error viewing ${boardType} boards:`, error);
            await interaction.editReply(`An error occurred while retrieving ${boardType} boards. Please try again.`);
        }
    },

    async manageBoardDetails(interaction, boardId) {
        try {
            // Find the board
            const board = await ArcadeBoard.findOne({ boardId });
            
            if (!board) {
                return interaction.editReply(`Board with ID "${boardId}" not found.`);
            }
            
            // Create the embed
            const embed = new EmbedBuilder()
                .setTitle(`Board Details: ${board.gameTitle}`)
                .setColor(board.boardType === 'arcade' ? '#9B59B6' : board.boardType === 'racing' ? '#FF9900' : '#FF0000')
                .setDescription('View and manage board details.')
                .addFields(
                    {
                        name: 'Board Info',
                        value: `**Type:** ${board.boardType.charAt(0).toUpperCase() + board.boardType.slice(1)}\n` +
                               `**Game:** ${board.gameTitle}\n` +
                               `**Board ID:** ${board.boardId}\n` +
                               `**Leaderboard ID:** ${board.leaderboardId}\n` +
                               `**Game ID:** ${board.gameId}\n` +
                               `**Description:** ${board.description}`
                    }
                )
                .setTimestamp();
                
            // Add additional fields based on board type
            if (board.boardType === 'racing' || board.boardType === 'tiebreaker') {
                embed.addFields(
                    {
                        name: 'Date Info',
                        value: `**Start Date:** ${board.startDate ? board.startDate.toLocaleDateString() : 'N/A'}\n` +
                               `**End Date:** ${board.endDate ? board.endDate.toLocaleDateString() : 'N/A'}\n` +
                               `**Month Key:** ${board.monthKey || 'N/A'}`
                    }
                );
                
                if (board.boardType === 'racing') {
                    embed.addFields(
                        {
                            name: 'Racing Info',
                            value: `**Track Name:** ${board.trackName || 'N/A'}\n` +
                                   `**Points Awarded:** ${board.pointsAwarded ? 'Yes' : 'No'}`
                        }
                    );
                    
                    // Add results if available
                    if (board.results && board.results.length > 0) {
                        const resultsText = board.results.map(result => {
                            const medalEmoji = result.rank === 1 ? 'ðŸ¥‡' : (result.rank === 2 ? 'ðŸ¥ˆ' : 'ðŸ¥‰');
                            return `${medalEmoji} **${result.username}**: ${result.time} (${result.points} point${result.points !== 1 ? 's' : ''})`;
                        }).join('\n');
                        
                        embed.addFields(
                            {
                                name: 'Results',
                                value: resultsText
                            }
                        );
                    }
                }
            }
            
            // Create action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('announce_board')
                        .setLabel('Announce Board')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('ðŸ“¢')
                );
                
            // Add award button for racing boards that haven't been awarded yet
            if (board.boardType === 'racing' && !board.pointsAwarded) {
                actionRow.addComponents(
                    new ButtonBuilder()
                        .setCustomId('award_board')
                        .setLabel('Award Points')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji('ðŸ†')
                );
            }
            
            // Add remove button
            actionRow.addComponents(
                new ButtonBuilder()
                    .setCustomId('remove_board')
                    .setLabel('Remove Board')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji('ðŸ—‘ï¸')
            );
            
            // Add back button
            const backRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('back_to_board_list')
                        .setLabel('Back to Board List')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('â†©ï¸')
                );
                
            await interaction.editReply({
                embeds: [embed],
                components: [actionRow, backRow]
            });
            
            // Set up collector for the button interactions
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'announce_board') {
                        await this.announceBoard(i, boardId);
                    } else if (i.customId === 'award_board') {
                        await this.awardRacingPoints(i, boardId);
                    } else if (i.customId === 'remove_board') {
                        await this.removeBoard(i, boardId);
                    } else if (i.customId === 'back_to_board_list') {
                        await this.viewBoardsByType(i, board.boardType);
                    }
                }
            });
        } catch (error) {
            console.error('Error managing board details:', error);
            await interaction.editReply('An error occurred while retrieving board details. Please try again.');
        }
    },

    async removeBoard(interaction, boardId) {
        try {
            // Find the board
            const board = await ArcadeBoard.findOne({ boardId });
            
            if (!board) {
                return interaction.editReply(`Board with ID "${boardId}" not found.`);
            }
            
            // Create confirmation dialog
            const embed = new EmbedBuilder()
                .setTitle(`Remove Board: ${board.gameTitle}`)
                .setColor('#FF0000') // Red for danger
                .setDescription('Are you sure you want to remove this board? This action cannot be undone.')
                .addFields(
                    {
                        name: 'Board Info',
                        value: `**Type:** ${board.boardType.charAt(0).toUpperCase() + board.boardType.slice(1)}\n` +
                               `**Game:** ${board.gameTitle}\n` +
                               `**Board ID:** ${board.boardId}`
                    }
                )
                .setTimestamp();
                
            // Create confirmation buttons
            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('confirm_remove')
                        .setLabel('Remove Board')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('âœ…'),
                    new ButtonBuilder()
                        .setCustomId('cancel_remove')
                        .setLabel('Cancel')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('âŒ')
                );
                
            await interaction.editReply({
                embeds: [embed],
                components: [row]
            });
            
            // Set up collector for the confirmation buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'confirm_remove') {
                        // Remove the board
                        await ArcadeBoard.deleteOne({ boardId });
                        
                        // Show success message
                        const successEmbed = new EmbedBuilder()
                            .setColor('#00FF00') // Green for success
                            .setTitle('Board Removed')
                            .setDescription(`The board "${board.gameTitle}" has been successfully removed.`)
                            .setTimestamp();
                            
                        await i.editReply({
                            embeds: [successEmbed],
                            components: []
                        });
                    } else if (i.customId === 'cancel_remove') {
                        // Go back to board details
                        await this.manageBoardDetails(i, boardId);
                    }
                }
            });
        } catch (error) {
            console.error('Error removing board:', error);
            await interaction.editReply('An error occurred while removing the board. Please try again.');
        }
    },

    // USER MANAGEMENT HANDLERS
    async handleUserCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'register':
                await this.handleRegisterUser(interaction);
                break;
            case 'unregister':
                await this.handleUnregisterUser(interaction);
                break;
            case 'purge':
                await this.handlePurgeRegistration(interaction);
                break;
            case 'award':
                await this.handleGiveAward(interaction);
                break;
            case 'awards':
                await this.handleViewAwards(interaction);
                break;
            case 'clear':
                await this.handleClearUserData(interaction);
                break;
            case 'reset':
                await this.handleResetAchievements(interaction);
                break;
            default:
                await interaction.editReply('Invalid user subcommand.');
        }
    },

    async handleRegisterUser(interaction) {
        try {
            const discordUser = interaction.options.getUser('discord_user');
            const raUsername = interaction.options.getString('ra_username');

            // Check if user already exists
            const existingUser = await User.findOne({
                $or: [
                    { discordId: discordUser.id },
                    { raUsername: { $regex: new RegExp(`^${raUsername}import { 
    SlashCommandBuilder, 
    EmbedBuilder, 
    ActionRowBuilder, 
    StringSelectMenuBuilder,
    ButtonBuilder,
    ButtonStyle,
    ComponentType,
    ModalBuilder,
    TextInputBuilder,
    TextInputStyle,
    PermissionFlagsBits
} from 'discord.js';
import { User } from '../../models/User.js';
import { Challenge } from '../../models/Challenge.js';
import { ArcadeBoard } from '../../models/ArcadeBoard.js';
import { Poll } from '../../models/Poll.js';
import retroAPI from '../../services/retroAPI.js';
import { config } from '../../config/config.js';

// Constants
const MEMBER_ROLE_ID = '1316292690870014002';

export default {
    data: new SlashCommandBuilder()
        .setName('admin')
        .setDescription('Admin dashboard for managing all aspects of the community')
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild) // Require admin permissions
        // Challenge Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('challenge')
                .setDescription('Manage monthly and shadow challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('create')
                        .setDescription('Create or replace a monthly challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('shadow')
                        .setDescription('Add or edit a shadow challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('toggle')
                        .setDescription('Toggle shadow challenge visibility')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View current challenge details')
                )
        )
        
        // Arcade Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('arcade')
                .setDescription('Manage arcade boards and racing challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('add')
                        .setDescription('Add an arcade board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('racing')
                        .setDescription('Set up a racing challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('tiebreaker')
                        .setDescription('Create a tiebreaker board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Award points for a completed board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('announce')
                        .setDescription('Announce a board to the community')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View and manage existing boards')
                )
        )
        
        // User Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('user')
                .setDescription('Manage users, registrations, and awards')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('register')
                        .setDescription('Register a user')
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to register')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('unregister')
                        .setDescription('Unregister a user')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to unregister')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('purge')
                        .setDescription('Completely remove a user registration')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to purge')
                            .setRequired(true))
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to purge (optional)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Give a community award to a user')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('title')
                            .setDescription('The title of the award')
                            .setRequired(true))
                        .addIntegerOption(option =>
                            option.setName('points')
                            .setDescription('Number of points for this award')
                            .setRequired(true)
                            .setMinValue(1))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('awards')
                        .setDescription('View user awards')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('clear')
                        .setDescription('Clear nominations or awards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('reset')
                        .setDescription('Reset user achievements')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('RetroAchievements username')
                            .setRequired(true))
                )
        )
        
        // Voting Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('voting')
                .setDescription('Manage voting processes')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('start')
                        .setDescription('Start a voting poll')
                        .addChannelOption(option =>
                            option.setName('channel')
                            .setDescription('The channel to create the poll announcement in')
                            .setRequired(true))
                        .addChannelOption(option =>
                            option.setName('results_channel')
                            .setDescription('The channel to announce results in (defaults to same channel)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('cancel')
                        .setDescription('Cancel an active voting poll')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('status')
                        .setDescription('Check status of current voting')
                )
        )
        
        // System Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('system')
                .setDescription('System-level operations')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('update')
                        .setDescription('Force an update of all stats and leaderboards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('suggestions')
                        .setDescription('Manage community suggestions')
                )
        )
        
        // Info display subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('info')
                .setDescription('Display shareable information')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('arcade')
                        .setDescription('Display arcade board information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('challenges')
                        .setDescription('Display challenge information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('overview')
                        .setDescription('Display community overview')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('commands')
                        .setDescription('Display available commands')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('rules')
                        .setDescription('Display community rules')
                )
        ),

    async execute(interaction) {
        // Check if user has admin role
        if (!interaction.member.roles.cache.has(config.bot.roles.admin)) {
            return interaction.reply({
                content: 'You do not have permission to use this command.',
                ephemeral: true
            });
        }

        await interaction.deferReply({ ephemeral: true });

        try {
            // Extract subcommand group and subcommand
            const subcommandGroup = interaction.options.getSubcommandGroup();
            const subcommand = interaction.options.getSubcommand();
            
            // Route to the appropriate handler based on subcommand group and subcommand
            switch (subcommandGroup) {
                case 'challenge':
                    await this.handleChallengeCommand(interaction, subcommand);
                    break;
                case 'arcade':
                    await this.handleArcadeCommand(interaction, subcommand);
                    break;
                case 'user':
                    await this.handleUserCommand(interaction, subcommand);
                    break;
                case 'voting':
                    await this.handleVotingCommand(interaction, subcommand);
                    break;
                case 'system':
                    await this.handleSystemCommand(interaction, subcommand);
                    break;
                case 'info':
                    await this.handleInfoCommand(interaction, subcommand);
                    break;
                default:
                    await interaction.editReply('Invalid subcommand group.');
            }
        } catch (error) {
            console.error('Error executing admin command:', error);
            await interaction.editReply('An error occurred while processing your request.');
        }
    },

    // CHALLENGE MANAGEMENT HANDLERS
    async handleChallengeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'create':
                await this.handleCreateChallenge(interaction);
                break;
            case 'shadow':
                await this.handleShadowChallenge(interaction);
                break;
            case 'toggle':
                await this.handleToggleShadow(interaction);
                break;
            case 'view':
                await this.handleViewChallenge(interaction);
                break;
            default:
                await interaction.editReply('Invalid challenge subcommand.');
        }
    },

    async handleCreateChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Create Monthly Challenge')
            .setColor('#32CD32')
            .setDescription('Use this form to create or replace a monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'How to Find Achievement IDs',
                    value: 'Go to the game page on RetroAchievements, hover over an achievement, and note the ID number in the URL.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('create_challenge_form')
                    .setLabel('Open Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ®')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'create_challenge_form') {
                    // Create modal for challenge creation
                    const modal = new ModalBuilder()
                        .setCustomId('create_challenge_modal')
                        .setTitle('Create Monthly Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add year input
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Create date for the first of the specified month
                            const challengeDate = new Date(year, month - 1, 1);

                            // Check if a challenge already exists for this month
                            const existingChallenge = await Challenge.findOneAndDelete({
                                date: {
                                    $gte: challengeDate,
                                    $lt: new Date(year, month, 1)
                                }
                            });

                            // Create new challenge
                            const challenge = new Challenge({
                                date: challengeDate,
                                monthly_challange_gameid: gameId,
                                monthly_challange_progression_achievements: progressionAchievements,
                                monthly_challange_win_achievements: winAchievements,
                                monthly_challange_game_total: totalAchievements,
                                shadow_challange_revealed: false // Keep shadow challenge hidden by default
                            });

                            await challenge.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Monthly Challenge Created')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (existingChallenge) {
                                resultEmbed.setDescription(`Monthly challenge replaced for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: existingChallenge.monthly_challange_gameid.toString() },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Monthly challenge created for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('add_shadow')
                                        .setLabel('Add Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ‘¥'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'add_shadow') {
                                        await this.handleShadowChallenge(resultI, { month, year });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error creating challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while creating the challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to create a challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleShadowChallenge(interaction, prefilledData = null) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Shadow Challenge')
            .setColor('#9932CC') // Dark purple
            .setDescription('Use this form to add or edit a shadow challenge for a specific month.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'Shadow Challenge Rules',
                    value: 'Shadow challenges are hidden mysteries that players can discover by guessing or playing the challenge games. They automatically reveal for past months.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('shadow_challenge_form')
                    .setLabel('Open Shadow Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸ‘¥')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'shadow_challenge_form') {
                    // Create modal for shadow challenge
                    const modal = new ModalBuilder()
                        .setCustomId('shadow_challenge_modal')
                        .setTitle('Add Shadow Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input with prefilled data if available
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.month) {
                        monthInput.setValue(prefilledData.month.toString());
                    } else {
                        // Default to current month
                        const now = new Date();
                        monthInput.setValue((now.getMonth() + 1).toString());
                    }

                    // Add year input with prefilled data if available
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.year) {
                        yearInput.setValue(prefilledData.year.toString());
                    } else {
                        // Default to current year
                        const now = new Date();
                        yearInput.setValue(now.getFullYear().toString());
                    }

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get date range for the specified month
                            const monthStart = new Date(year, month - 1, 1);
                            const nextMonthStart = new Date(year, month, 1);

                            // Find the target challenge
                            const targetChallenge = await Challenge.findOne({
                                date: {
                                    $gte: monthStart,
                                    $lt: nextMonthStart
                                }
                            });

                            if (!targetChallenge) {
                                return modalSubmission.editReply(`No challenge exists for ${month}/${year}. Create a monthly challenge first using /admin challenge create.`);
                            }

                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Check if there's an existing shadow game to be replaced
                            let replacedShadowGame = null;
                            if (targetChallenge.shadow_challange_gameid) {
                                try {
                                    const oldGameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
                                    replacedShadowGame = oldGameInfo.title;
                                } catch (error) {
                                    console.error('Error fetching old shadow game info:', error);
                                    replacedShadowGame = targetChallenge.shadow_challange_gameid;
                                }
                            }

                            // Update the challenge with shadow game information
                            targetChallenge.shadow_challange_gameid = gameId;
                            targetChallenge.shadow_challange_progression_achievements = progressionAchievements;
                            targetChallenge.shadow_challange_win_achievements = winAchievements;
                            targetChallenge.shadow_challange_game_total = totalAchievements;
                            
                            // Automatically reveal shadow games for past months
                            const now = new Date();
                            if (month < now.getMonth() + 1 || year < now.getFullYear()) {
                                targetChallenge.shadow_challange_revealed = true;
                            } else if (!targetChallenge.shadow_challange_revealed) {
                                // For current or future months, keep shadow games hidden by default
                                targetChallenge.shadow_challange_revealed = false;
                            }

                            await targetChallenge.save();

                            // Get month name for display
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Determine if it was auto-revealed
                            const autoRevealed = (month < now.getMonth() + 1 || year < now.getFullYear());
                            
                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#9932CC') // Dark purple for shadow challenges
                                .setTitle('Shadow Challenge Added')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (replacedShadowGame) {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} replaced`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: replacedShadowGame },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} created`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() },
                                { name: 'Visibility', value: targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden' + (autoRevealed ? ' (Auto-revealed as past challenge)' : '') }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('toggle_shadow')
                                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'toggle_shadow') {
                                        await this.handleToggleShadow(resultI, { month, year, force: true });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding shadow challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the shadow challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a shadow challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleToggleShadow(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            let force = options?.force || false;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                const now = new Date();
                month = now.getMonth() + 1; // 1-indexed month
                year = now.getFullYear();
            }
            
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the target challenge
            const targetChallenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!targetChallenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            if (!targetChallenge.shadow_challange_gameid) {
                return interaction.editReply(`No shadow challenge has been set for ${month}/${year}.`);
            }

            // Toggle the visibility
            targetChallenge.shadow_challange_revealed = !targetChallenge.shadow_challange_revealed;
            await targetChallenge.save();

            // Get game info for the response
            const gameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
            
            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Create response embed
            const resultEmbed = new EmbedBuilder()
                .setColor(targetChallenge.shadow_challange_revealed ? '#00FF00' : '#FF0000') // Green for revealed, red for hidden
                .setTitle(`Shadow Challenge ${targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden'}`)
                .setDescription(`The shadow challenge for ${monthName} ${year} is now ${targetChallenge.shadow_challange_revealed ? 'REVEALED' : 'HIDDEN'}.`)
                .setTimestamp();

            if (targetChallenge.shadow_challange_revealed) {
                resultEmbed.addFields(
                    { name: 'Game', value: gameInfo.title },
                    { name: 'Required Progression Achievements', value: targetChallenge.shadow_challange_progression_achievements.length.toString() },
                    { name: 'Required Win Achievements', value: targetChallenge.shadow_challange_win_achievements.length > 0 ? targetChallenge.shadow_challange_win_achievements.length.toString() : 'None' }
                );
                
                if (gameInfo.imageIcon) {
                    resultEmbed.setThumbnail(`https://retroachievements.org${gameInfo.imageIcon}`);
                }
            }

            // Add action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow_again')
                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                    new ButtonBuilder()
                        .setCustomId('view_challenge')
                        .setLabel('View Challenge Details')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ”')
                );

            // If we're force-updating from another command, use editReply
            // Otherwise, use standard reply
            if (force) {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            } else {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            }

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'toggle_shadow_again') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    } else if (i.customId === 'view_challenge') {
                        await this.handleViewChallenge(i, { month, year });
                    }
                }
            });

        } catch (error) {
            console.error('Error toggling shadow challenge visibility:', error);
            await interaction.editReply('An error occurred while toggling the shadow challenge visibility. Please try again.');
        }
    },

    async handleViewChallenge(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                // Open a form to select month/year
                const embed = new EmbedBuilder()
                    .setTitle('View Challenge Details')
                    .setColor('#3498DB')
                    .setDescription('Please select which challenge you want to view.')
                    .addFields(
                        {
                            name: 'Options',
                            value: 'You can view the current month\'s challenge or select a specific month.'
                        }
                    );

                // Create buttons
                const row = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('view_current_challenge')
                            .setLabel('Current Month')
                            .setStyle(ButtonStyle.Primary)
                            .setEmoji('ðŸ“…'),
                        new ButtonBuilder()
                            .setCustomId('select_month_challenge')
                            .setLabel('Select Month')
                            .setStyle(ButtonStyle.Secondary)
                            .setEmoji('ðŸ”')
                    );

                await interaction.editReply({
                    embeds: [embed],
                    components: [row]
                });

                // Set up collector for the buttons
                const message = await interaction.fetchReply();
                const buttonCollector = message.createMessageComponentCollector({
                    componentType: ComponentType.Button,
                    time: 300000 // 5 minutes timeout
                });

                buttonCollector.on('collect', async i => {
                    if (i.user.id === interaction.user.id) {
                        await i.deferUpdate();

                        if (i.customId === 'view_current_challenge') {
                            // Use current month
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                            
                            // Continue with viewing the challenge
                            await this.displayChallengeDetails(i, month, year);
                            
                            // Stop the collector
                            buttonCollector.stop();
                        } else if (i.customId === 'select_month_challenge') {
                            // Show modal to select month/year
                            const modal = new ModalBuilder()
                                .setCustomId('select_challenge_month_modal')
                                .setTitle('Select Challenge Month');

                            // Add month input
                            const monthInput = new TextInputBuilder()
                                .setCustomId('month')
                                .setLabel('Month (1-12)')
                                .setPlaceholder('Example: 5 (for May)')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add year input
                            const yearInput = new TextInputBuilder()
                                .setCustomId('year')
                                .setLabel('Year')
                                .setPlaceholder('Example: 2025')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add inputs to modal
                            const monthRow = new ActionRowBuilder().addComponents(monthInput);
                            const yearRow = new ActionRowBuilder().addComponents(yearInput);

                            modal.addComponents(monthRow, yearRow);

                            // Show the modal
                            await i.showModal(modal);

                            try {
                                // Wait for modal submission
                                const modalSubmission = await i.awaitModalSubmit({
                                    time: 300000 // 5 minutes to fill out the form
                                });

                                await modalSubmission.deferUpdate();

                                // Extract values from the modal
                                month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                                year = parseInt(modalSubmission.fields.getTextInputValue('year'));

                                // Validate inputs
                                if (isNaN(month) || month < 1 || month > 12) {
                                    return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                                }

                                if (isNaN(year) || year < 2000 || year > 2100) {
                                    return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                                }

                                // Continue with viewing the challenge
                                await this.displayChallengeDetails(modalSubmission, month, year);
                                
                                // Stop the collector
                                buttonCollector.stop();

                            } catch (modalError) {
                                console.error('Error handling modal submission:', modalError);
                                // Modal timed out or was cancelled
                            }
                        }
                    }
                });

                // Let the function end here and let the collector handle the rest
                return;
            }

            // If we have month/year, display the challenge
            await this.displayChallengeDetails(interaction, month, year);

        } catch (error) {
            console.error('Error viewing challenge:', error);
            await interaction.editReply('An error occurred while viewing the challenge. Please try again.');
        }
    },

    async displayChallengeDetails(interaction, month, year) {
        try {
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the challenge
            const challenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!challenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Get game info for monthly challenge
            let monthlyGameInfo = null;
            if (challenge.monthly_challange_gameid) {
                monthlyGameInfo = await retroAPI.getGameInfo(challenge.monthly_challange_gameid);
            }

            // Get game info for shadow challenge if revealed
            let shadowGameInfo = null;
            if (challenge.shadow_challange_gameid && challenge.shadow_challange_revealed) {
                shadowGameInfo = await retroAPI.getGameInfo(challenge.shadow_challange_gameid);
            }

            // Create main embed
            const embed = new EmbedBuilder()
                .setTitle(`Challenge Details: ${monthName} ${year}`)
                .setColor('#3498DB')
                .setDescription(`Here are the details for the ${monthName} ${year} challenges:`)
                .setTimestamp();

            // Add monthly challenge info
            if (monthlyGameInfo) {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: `**Game:** ${monthlyGameInfo.title}\n` +
                          `**Required Progression Achievements:** ${challenge.monthly_challange_progression_achievements.length}\n` +
                          `**Required Win Achievements:** ${challenge.monthly_challange_win_achievements.length}\n` +
                          `**Total Achievements:** ${challenge.monthly_challange_game_total}\n` +
                          `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.monthly_challange_gameid})`
                });

                if (monthlyGameInfo.imageIcon) {
                    embed.setThumbnail(`https://retroachievements.org${monthlyGameInfo.imageIcon}`);
                }
            } else {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: 'No monthly challenge set.'
                });
            }

            // Add shadow challenge info
            if (challenge.shadow_challange_gameid) {
                if (challenge.shadow_challange_revealed && shadowGameInfo) {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (REVEALED)',
                        value: `**Game:** ${shadowGameInfo.title}\n` +
                              `**Required Progression Achievements:** ${challenge.shadow_challange_progression_achievements.length}\n` +
                              `**Required Win Achievements:** ${challenge.shadow_challange_win_achievements.length}\n` +
                              `**Total Achievements:** ${challenge.shadow_challange_game_total}\n` +
                              `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.shadow_challange_gameid})`
                    });
                } else {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (HIDDEN)',
                        value: 'Shadow challenge exists but is currently hidden.\n' +
                              `Use \`/admin challenge toggle\` to reveal it.`
                    });
                }
            } else {
                embed.addFields({
                    name: 'ðŸ‘¥ Shadow Challenge',
                    value: 'No shadow challenge set.\n' +
                          `Use \`/admin challenge shadow\` to add one.`
                });
            }

            // Create action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('edit_monthly')
                        .setLabel('Edit Monthly Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('ðŸ†'),
                    new ButtonBuilder()
                        .setCustomId('edit_shadow')
                        .setLabel(challenge.shadow_challange_gameid ? 'Edit Shadow Challenge' : 'Add Shadow Challenge')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ‘¥')
                );

            // Add toggle button if shadow challenge exists
            if (challenge.shadow_challange_gameid) {
                actionRow.addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow')
                        .setLabel(challenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji(challenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸')
                );
            }

            await interaction.editReply({
                embeds: [embed],
                components: [actionRow]
            });

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'edit_monthly') {
                        await this.handleCreateChallenge(i);
                    } else if (i.customId === 'edit_shadow') {
                        await this.handleShadowChallenge(i, { month, year });
                    } else if (i.customId === 'toggle_shadow') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    }
                }
            });

        } catch (error) {
            console.error('Error displaying challenge details:', error);
            await interaction.editReply('An error occurred while retrieving challenge details. Please try again.');
        }
    },

    // ARCADE MANAGEMENT HANDLERS
    async handleArcadeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'add':
                await this.handleAddArcadeBoard(interaction);
                break;
            case 'racing':
                await this.handleAddRacingChallenge(interaction);
                break;
            case 'tiebreaker':
                await this.handleAddTiebreaker(interaction);
                break;
            case 'award':
                await this.handleAwardPoints(interaction);
                break;
            case 'announce':
                await this.handleAnnounceBoard(interaction);
                break;
            case 'view':
                await this.handleViewBoards(interaction);
                break;
            default:
                await interaction.editReply('Invalid arcade subcommand.');
        }
    },

    async handleAddArcadeBoard(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Arcade Board')
            .setColor('#9B59B6') // Purple
            .setDescription('Use this form to add a new arcade board to the community.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Board ID (unique identifier)\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description'
                },
                {
                    name: 'How to Find IDs',
                    value: '**Game ID**: The number at the end of the game URL on RetroAchievements\n**Leaderboard ID**: The number at the end of the leaderboard URL'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_arcade_form')
                    .setLabel('Open Arcade Board Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ¯')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_arcade_form') {
                    // Create modal for arcade board
                    const modal = new ModalBuilder()
                        .setCustomId('add_arcade_modal')
                        .setTitle('Add Arcade Board');

                    // Add board ID input
                    const boardIdInput = new TextInputBuilder()
                        .setCustomId('board_id')
                        .setLabel('Board ID (unique identifier)')
                        .setPlaceholder('Example: sonic3-special-stages')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this arcade board challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add inputs to modal
                    const boardIdRow = new ActionRowBuilder().addComponents(boardIdInput);
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);

                    modal.addComponents(boardIdRow, gameIdRow, leaderboardIdRow, descriptionRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const boardId = modalSubmission.fields.getTextInputValue('board_id');
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        try {
                            // Check if board ID already exists
                            const existingBoard = await ArcadeBoard.findOne({ boardId });
                            if (existingBoard) {
                                return modalSubmission.editReply(`A board with ID "${boardId}" already exists.`);
                            }

                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Create new board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'arcade',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description
                            });

                            await newBoard.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Arcade Board Added')
                                .setDescription(`Successfully added "${gameInfo.title}" arcade board!`)
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .addFields(
                                    { name: 'Board ID', value: boardId },
                                    { name: 'Game', value: gameInfo.title },
                                    { name: 'Console', value: gameInfo.consoleName || 'Unknown' },
                                    { name: 'Description', value: description }
                                )
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_board')
                                        .setLabel('Announce Board')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_board') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding arcade board:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the arcade board. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add an arcade board.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddRacingChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Racing Challenge')
            .setColor('#FF9900') // Orange
            .setDescription('Use this form to set up a monthly racing challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Track Name\nâ€¢ Description\nâ€¢ Month and Year (optional, defaults to current month)'
                },
                {
                    name: 'Racing Challenge Rules',
                    value: 'Racing challenges are monthly competitions where players compete on time-based leaderboards. The top 3 players will receive community points.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_racing_form')
                    .setLabel('Open Racing Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_racing_form') {
                    // Create modal for racing challenge
                    const modal = new ModalBuilder()
                        .setCustomId('add_racing_modal')
                        .setTitle('Add Racing Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add track name input
                    const trackNameInput = new TextInputBuilder()
                        .setCustomId('track_name')
                        .setLabel('Track Name')
                        .setPlaceholder('Example: Rainbow Road')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this racing challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add month/year input
                    const monthYearInput = new TextInputBuilder()
                        .setCustomId('month_year')
                        .setLabel('Month and Year (optional, MM/YYYY format)')
                        .setPlaceholder('Example: 05/2025 (defaults to current month)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const trackNameRow = new ActionRowBuilder().addComponents(trackNameInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthYearInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, trackNameRow, descriptionRow, monthYearRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const trackName = modalSubmission.fields.getTextInputValue('track_name');
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const monthYearInput = modalSubmission.fields.getTextInputValue('month_year');

                        // Parse month and year
                        let month, year;
                        if (monthYearInput && monthYearInput.trim()) {
                            const parts = monthYearInput.split('/');
                            if (parts.length === 2) {
                                month = parseInt(parts[0]);
                                year = parseInt(parts[1]);
                            } else {
                                // Invalid format, use current month/year
                                const now = new Date();
                                month = now.getMonth() + 1;
                                year = now.getFullYear();
                            }
                        } else {
                            // No input, use current month/year
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                        }

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Calculate start and end dates
                            // Start at beginning of specified month
                            const startDate = new Date(year, month - 1, 1);
                            
                            // End at the end of the specified month (23:59:59 on the last day)
                            const endDate = new Date(year, month, 0, 23, 59, 59);
                            
                            // Check if a racing challenge already exists for this month
                            const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                            const existingChallenge = await ArcadeBoard.findOne({
                                boardType: 'racing',
                                monthKey
                            });

                            if (existingChallenge) {
                                return modalSubmission.editReply(`A racing challenge already exists for ${monthKey}.`);
                            }

                            // Generate a unique board ID specifically for racing
                            // This format ensures no overlap with regular arcade boards
                            const boardId = `racing-${monthKey}`;

                            // Get the full game title and console name
                            const gameFull = `${gameInfo.title} (${gameInfo.consoleName})`;

                            // Create new racing board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'racing',
                                leaderboardId,
                                gameId,
                                gameTitle: gameFull,
                                trackName,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate,
                                endDate,
                                monthKey
                            });

                            await newBoard.save();

                            // Get month name for response
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF9900') // Orange for racing
                                .setTitle(`Racing Challenge Created: ${monthName} ${year}`)
                                .setDescription(
                                    `**Game:** ${gameFull}\n` +
                                    `**Track:** ${trackName}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Challenge Period:** ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `The top 3 players at the end of the month will receive award points!`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_racing')
                                        .setLabel('Announce Racing Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_racing') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding racing challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the racing challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a racing challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddTiebreaker(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Tiebreaker')
            .setColor('#FF0000') // Red
            .setDescription('Use this form to create a tiebreaker leaderboard for the monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description\nâ€¢ End Date (YYYY-MM-DD format)'
                },
                {
                    name: 'Tiebreaker Rules',
                    value: 'Tiebreakers are used to resolve ties in the monthly challenge leaderboard. Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_tiebreaker_form')
                    .setLabel('Open Tiebreaker Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('âš”ï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_tiebreaker_form') {
                    // Create modal for tiebreaker
                    const modal = new ModalBuilder()
                        .setCustomId('add_tiebreaker_modal')
                        .setTitle('Add Tiebreaker');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this tiebreaker challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add end date input
                    const endDateInput = new TextInputBuilder()
                        .setCustomId('end_date')
                        .setLabel('End Date (YYYY-MM-DD format)')
                        .setPlaceholder('Example: 2025-05-31')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const endDateRow = new ActionRowBuilder().addComponents(endDateInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, descriptionRow, endDateRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const endDateStr = modalSubmission.fields.getTextInputValue('end_date');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        // Parse end date
                        const endDate = new Date(endDateStr);
                        if (isNaN(endDate.getTime())) {
                            return modalSubmission.editReply('Invalid end date format. Please use YYYY-MM-DD.');
                        }

                        // Set end time to 23:59:59
                        endDate.setHours(23, 59, 59);

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Check if an active tiebreaker already exists
                            const now = new Date();
                            const activeTiebreaker = await ArcadeBoard.findOne({
                                boardType: 'tiebreaker',
                                startDate: { $lte: now },
                                endDate: { $gte: now }
                            });

                            if (activeTiebreaker) {
                                return modalSubmission.editReply('An active tiebreaker already exists. Please end it before creating a new one.');
                            }

                            // Generate a unique board ID based on month and year
                            const monthYear = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}`;
                            const boardId = `tiebreaker-${monthYear}`;

                            // Create new tiebreaker board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'tiebreaker',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate: now,
                                endDate,
                                // Add monthKey for consistency with racing challenges
                                monthKey: monthYear
                            });

                            await newBoard.save();

                            // Get the month name
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[now.getMonth()];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF0000') // Red for tiebreaker
                                .setTitle(`âš”ï¸ Tiebreaker Created: ${monthName} ${now.getFullYear()}`)
                                .setDescription(
                                    `**Game:** ${gameInfo.title}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Tiebreaker Period:** ${now.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `This tiebreaker will be used to resolve ties in the ${monthName} monthly challenge leaderboard. ` +
                                    `Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_tiebreaker')
                                        .setLabel('Announce Tiebreaker')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_tiebreaker') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding tiebreaker:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the tiebreaker. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a tiebreaker.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAwardPoints(interaction) {
        // Create select board form
        const embed = new EmbedBuilder()
            .setTitle('Award Points')
            .setColor('#32CD32') // Lime green
            .setDescription('Select a board to award points for.')
            .addFields(
                {
                    name: 'Award Points',
                    value: 'You can award points for completed racing challenges or arcade boards. For racing challenges, points are awarded to the top 3 players. For arcade boards, points are awarded annually.'
                }
            );

        // Find all racing boards and tiebreakers
        const racingBoards = await ArcadeBoard.find({ 
            boardType: 'racing',
            pointsAwarded: { $ne: true } // Only show boards that haven't been awarded points yet
        }).sort({ startDate: -1 });

        // Create options for racing boards
        const boardOptions = racingBoards.map(board => {
            const monthYear = board.monthKey || 'Unknown Date';
            return {
                label: `Racing: ${board.gameTitle}${board.trackName ? ` - ${board.trackName}` : ''}`,
                description: `${monthYear}`,
                value: `racing-${board.boardId}`
            };
        });

        // Add option for annual arcade awards if any arcade boards exist
        const arcadeBoards = await ArcadeBoard.find({ boardType: 'arcade' });
        if (arcadeBoards.length > 0) {
            boardOptions.push({
                label: 'Annual Arcade Awards',
                description: 'Award points for all arcade boards for the current year',
                value: 'arcade-annual'
            });
        }

        // Create dropdown if we have options
        if (boardOptions.length === 0) {
            return interaction.editReply('No eligible boards found for awarding points. All racing challenges have already been awarded points, or no racing challenges exist.');
        }

        // Create the dropdown
        const row = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('select_board_for_award')
                    .setPlaceholder('Select a board to award points')
                    .addOptions(boardOptions)
            );

        // Send the selection menu
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the dropdown selection
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.StringSelect,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                await i.deferUpdate();
                
                const selectedValue = i.values[0];
                
                if (selectedValue.startsWith('racing-')) {
                    // Extract board ID
                    const boardId = selectedValue.substring(7);
                    await this.awardRacingPoints(i, boardId);
                } else if (selectedValue === 'arcade-annual') {
                    await this.awardArcadePoints(i);
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        StringSelectMenuBuilder.from(row.components[0])
                            .setDisabled(true)
                            .setPlaceholder('Selection timed out')
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This selection has expired. Please run the command again if you still need to award points.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling dropdown:', error);
                }
            }
        });
    },

    async awardRacingPoints(interaction, boardId) {
        try {
            // Find the racing board
            const racingBoard = await ArcadeBoard.findOne({ 
                boardId,
                boardType: 'racing'
            });

            if (!racingBoard) {
                return interaction.editReply(`Racing board with ID "${boardId}" not found.`);
            }

            // Check if points have already been awarded
            if (racingBoard.pointsAwarded) {
                return interaction.editReply(`Points have already been awarded for this racing challenge.`);
            }

            // Check if the racing challenge has ended
            const now = new Date();
            if (racingBoard.endDate > now) {
                return interaction.editReply(`This racing challenge hasn't ended yet. It ends on ${racingBoard.endDate.toLocaleDateString()}.`);
            }

, 'i') } }
                ]
            });

            if (existingUser) {
                return interaction.editReply(
                    'This user is already registered. ' +
                    `${existingUser.discordId === discordUser.id ? 'Discord ID' : 'RA username'} is already in use.`
                );
            }

            // Validate RA username exists
            const isValidUser = await retroAPI.validateUser(raUsername);
            if (!isValidUser) {
                return interaction.editReply('Invalid RetroAchievements username. Please check the username and try again.');
            }

            // Create guidelines confirmation embed
            const guidelinesEmbed = new EmbedBuilder()
                .setTitle('Community Guidelines Confirmation')
                .setDescription(`Please confirm that ${discordUser.tag} understands and agrees to the following community guidelines:`)
                .setColor('#3498DB')
                .addFields(
                    {
                        name: 'âš ï¸ Hardcore Mode Required',
                        value: 'All achievements must be earned in RetroAchievements **Hardcore Mode**. Save states and rewind features are **not allowed**.'
                    },
                    {
                        name: 'ðŸ“† Challenge Timeframe',
                        value: 'Achievements must be earned within the challenge month to be counted toward standings.'
                    },
                    {
                        name: 'ðŸ‘¥ Community Conduct',
                        value: 'Members must maintain respectful communication and follow all community rules.'
                    },
                    {
                        name: 'ðŸ“‹ Full Rules',
                        value: 'Please read the complete rules using the `/rules` command at your convenience.'
                    }
                )
                .setFooter({ text: 'You must acknowledge these guidelines to complete registration' });

            // Create confirmation buttons
            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('confirm_registration')
                        .setLabel('I Understand & Agree')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('cancel_registration')
                        .setLabel('Cancel Registration')
                        .setStyle(ButtonStyle.Danger)
                );

            // Send embed with buttons
            const message = await interaction.editReply({
                content: `Registration for ${discordUser.tag} (${raUsername}) requires confirmation:`,
                embeds: [guidelinesEmbed],
                components: [row]
            });

            // Create collector for button interactions
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 120000 // 2 minute timeout
            });

            // Handle button clicks
            collector.on('collect', async i => {
                // Only allow the original interaction user to confirm
                if (i.user.id !== interaction.user.id) {
                    await i.reply({ 
                        content: 'Only the admin who initiated this registration can confirm it.',
                        ephemeral: true 
                    });
                    return;
                }

                await i.deferUpdate();

                if (i.customId === 'confirm_registration') {
                    // Create new user in database
                    const user = new User({
                        raUsername,
                        discordId: discordUser.id
                    });
                    
                    await user.save();

                    // Assign role if user is in the server
                    try {
                        const guildMember = interaction.guild.members.cache.get(discordUser.id);
                        if (guildMember) {
                            await guildMember.roles.add(MEMBER_ROLE_ID);
                        }
                    } catch (roleError) {
                        console.error('Error assigning role:', roleError);
                        // Continue with registration even if role assignment fails
                    }

                    // Disable buttons
                    const disabledRow = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('confirm_disabled')
                                .setLabel('Registration Confirmed')
                                .setStyle(ButtonStyle.Success)
                                .setDisabled(true)
                        );

                    // Update message with registration confirmation
                    await i.editReply({
                        content: `âœ… Successfully registered user!\n` +
                               `Discord: ${discordUser.tag}\n` +
                               `RA Username: ${raUsername}\n` +
                               `RA Profile: https://retroachievements.org/user/${raUsername}`,
                        embeds: [],
                        components: [disabledRow]
                    });

                } else if (i.customId === 'cancel_registration') {
                    // Disable buttons
                    const disabledRow = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('cancel_disabled')
                                .setLabel('Registration Cancelled')
                                .setStyle(ButtonStyle.Danger)
                                .setDisabled(true)
                        );

                    // Update message with cancellation confirmation
                    await i.editReply({
                        content: `âŒ Registration cancelled for ${discordUser.tag} (${raUsername}).`,
                        embeds: [],
                        components: [disabledRow]
                    });
                }

                // Stop collector after handling button
                collector.stop();
            });

            // Handle collector end (timeout)
            collector.on('end', async (collected, reason) => {
                if (reason === 'time' && collected.size === 0) {
                    // If timeout with no interactions
                    const timeoutRow = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('timeout')
                                .setLabel('Registration Timed Out')
                                .setStyle(ButtonStyle.Secondary)
                                .setDisabled(true)
                        );

                    await interaction.editReply({
                        content: `â±ï¸ Registration timed out for ${discordUser.tag} (${raUsername}). Please try again.`,
                        embeds: [],
                        components: [timeoutRow]
                    });
                }
            });
        } catch (error) {
            console.error('Error during registration process:', error);
            return interaction.editReply('An error occurred while processing the registration. Please try again.');
        }
    },

    async handleUnregisterUser(interaction) {
        try {
            const raUsername = interaction.options.getString('ra_username');

            // Find the user
            const user = await User.findOne({
                raUsername: { $regex: new RegExp(`^${raUsername}import { 
    SlashCommandBuilder, 
    EmbedBuilder, 
    ActionRowBuilder, 
    StringSelectMenuBuilder,
    ButtonBuilder,
    ButtonStyle,
    ComponentType,
    ModalBuilder,
    TextInputBuilder,
    TextInputStyle,
    PermissionFlagsBits
} from 'discord.js';
import { User } from '../../models/User.js';
import { Challenge } from '../../models/Challenge.js';
import { ArcadeBoard } from '../../models/ArcadeBoard.js';
import { Poll } from '../../models/Poll.js';
import retroAPI from '../../services/retroAPI.js';
import { config } from '../../config/config.js';

// Constants
const MEMBER_ROLE_ID = '1316292690870014002';

export default {
    data: new SlashCommandBuilder()
        .setName('admin')
        .setDescription('Admin dashboard for managing all aspects of the community')
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild) // Require admin permissions
        // Challenge Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('challenge')
                .setDescription('Manage monthly and shadow challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('create')
                        .setDescription('Create or replace a monthly challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('shadow')
                        .setDescription('Add or edit a shadow challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('toggle')
                        .setDescription('Toggle shadow challenge visibility')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View current challenge details')
                )
        )
        
        // Arcade Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('arcade')
                .setDescription('Manage arcade boards and racing challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('add')
                        .setDescription('Add an arcade board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('racing')
                        .setDescription('Set up a racing challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('tiebreaker')
                        .setDescription('Create a tiebreaker board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Award points for a completed board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('announce')
                        .setDescription('Announce a board to the community')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View and manage existing boards')
                )
        )
        
        // User Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('user')
                .setDescription('Manage users, registrations, and awards')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('register')
                        .setDescription('Register a user')
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to register')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('unregister')
                        .setDescription('Unregister a user')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to unregister')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('purge')
                        .setDescription('Completely remove a user registration')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to purge')
                            .setRequired(true))
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to purge (optional)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Give a community award to a user')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('title')
                            .setDescription('The title of the award')
                            .setRequired(true))
                        .addIntegerOption(option =>
                            option.setName('points')
                            .setDescription('Number of points for this award')
                            .setRequired(true)
                            .setMinValue(1))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('awards')
                        .setDescription('View user awards')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('clear')
                        .setDescription('Clear nominations or awards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('reset')
                        .setDescription('Reset user achievements')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('RetroAchievements username')
                            .setRequired(true))
                )
        )
        
        // Voting Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('voting')
                .setDescription('Manage voting processes')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('start')
                        .setDescription('Start a voting poll')
                        .addChannelOption(option =>
                            option.setName('channel')
                            .setDescription('The channel to create the poll announcement in')
                            .setRequired(true))
                        .addChannelOption(option =>
                            option.setName('results_channel')
                            .setDescription('The channel to announce results in (defaults to same channel)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('cancel')
                        .setDescription('Cancel an active voting poll')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('status')
                        .setDescription('Check status of current voting')
                )
        )
        
        // System Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('system')
                .setDescription('System-level operations')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('update')
                        .setDescription('Force an update of all stats and leaderboards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('suggestions')
                        .setDescription('Manage community suggestions')
                )
        )
        
        // Info display subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('info')
                .setDescription('Display shareable information')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('arcade')
                        .setDescription('Display arcade board information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('challenges')
                        .setDescription('Display challenge information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('overview')
                        .setDescription('Display community overview')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('commands')
                        .setDescription('Display available commands')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('rules')
                        .setDescription('Display community rules')
                )
        ),

    async execute(interaction) {
        // Check if user has admin role
        if (!interaction.member.roles.cache.has(config.bot.roles.admin)) {
            return interaction.reply({
                content: 'You do not have permission to use this command.',
                ephemeral: true
            });
        }

        await interaction.deferReply({ ephemeral: true });

        try {
            // Extract subcommand group and subcommand
            const subcommandGroup = interaction.options.getSubcommandGroup();
            const subcommand = interaction.options.getSubcommand();
            
            // Route to the appropriate handler based on subcommand group and subcommand
            switch (subcommandGroup) {
                case 'challenge':
                    await this.handleChallengeCommand(interaction, subcommand);
                    break;
                case 'arcade':
                    await this.handleArcadeCommand(interaction, subcommand);
                    break;
                case 'user':
                    await this.handleUserCommand(interaction, subcommand);
                    break;
                case 'voting':
                    await this.handleVotingCommand(interaction, subcommand);
                    break;
                case 'system':
                    await this.handleSystemCommand(interaction, subcommand);
                    break;
                case 'info':
                    await this.handleInfoCommand(interaction, subcommand);
                    break;
                default:
                    await interaction.editReply('Invalid subcommand group.');
            }
        } catch (error) {
            console.error('Error executing admin command:', error);
            await interaction.editReply('An error occurred while processing your request.');
        }
    },

    // CHALLENGE MANAGEMENT HANDLERS
    async handleChallengeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'create':
                await this.handleCreateChallenge(interaction);
                break;
            case 'shadow':
                await this.handleShadowChallenge(interaction);
                break;
            case 'toggle':
                await this.handleToggleShadow(interaction);
                break;
            case 'view':
                await this.handleViewChallenge(interaction);
                break;
            default:
                await interaction.editReply('Invalid challenge subcommand.');
        }
    },

    async handleCreateChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Create Monthly Challenge')
            .setColor('#32CD32')
            .setDescription('Use this form to create or replace a monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'How to Find Achievement IDs',
                    value: 'Go to the game page on RetroAchievements, hover over an achievement, and note the ID number in the URL.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('create_challenge_form')
                    .setLabel('Open Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ®')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'create_challenge_form') {
                    // Create modal for challenge creation
                    const modal = new ModalBuilder()
                        .setCustomId('create_challenge_modal')
                        .setTitle('Create Monthly Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add year input
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Create date for the first of the specified month
                            const challengeDate = new Date(year, month - 1, 1);

                            // Check if a challenge already exists for this month
                            const existingChallenge = await Challenge.findOneAndDelete({
                                date: {
                                    $gte: challengeDate,
                                    $lt: new Date(year, month, 1)
                                }
                            });

                            // Create new challenge
                            const challenge = new Challenge({
                                date: challengeDate,
                                monthly_challange_gameid: gameId,
                                monthly_challange_progression_achievements: progressionAchievements,
                                monthly_challange_win_achievements: winAchievements,
                                monthly_challange_game_total: totalAchievements,
                                shadow_challange_revealed: false // Keep shadow challenge hidden by default
                            });

                            await challenge.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Monthly Challenge Created')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (existingChallenge) {
                                resultEmbed.setDescription(`Monthly challenge replaced for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: existingChallenge.monthly_challange_gameid.toString() },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Monthly challenge created for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('add_shadow')
                                        .setLabel('Add Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ‘¥'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'add_shadow') {
                                        await this.handleShadowChallenge(resultI, { month, year });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error creating challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while creating the challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to create a challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleShadowChallenge(interaction, prefilledData = null) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Shadow Challenge')
            .setColor('#9932CC') // Dark purple
            .setDescription('Use this form to add or edit a shadow challenge for a specific month.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'Shadow Challenge Rules',
                    value: 'Shadow challenges are hidden mysteries that players can discover by guessing or playing the challenge games. They automatically reveal for past months.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('shadow_challenge_form')
                    .setLabel('Open Shadow Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸ‘¥')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'shadow_challenge_form') {
                    // Create modal for shadow challenge
                    const modal = new ModalBuilder()
                        .setCustomId('shadow_challenge_modal')
                        .setTitle('Add Shadow Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input with prefilled data if available
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.month) {
                        monthInput.setValue(prefilledData.month.toString());
                    } else {
                        // Default to current month
                        const now = new Date();
                        monthInput.setValue((now.getMonth() + 1).toString());
                    }

                    // Add year input with prefilled data if available
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.year) {
                        yearInput.setValue(prefilledData.year.toString());
                    } else {
                        // Default to current year
                        const now = new Date();
                        yearInput.setValue(now.getFullYear().toString());
                    }

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get date range for the specified month
                            const monthStart = new Date(year, month - 1, 1);
                            const nextMonthStart = new Date(year, month, 1);

                            // Find the target challenge
                            const targetChallenge = await Challenge.findOne({
                                date: {
                                    $gte: monthStart,
                                    $lt: nextMonthStart
                                }
                            });

                            if (!targetChallenge) {
                                return modalSubmission.editReply(`No challenge exists for ${month}/${year}. Create a monthly challenge first using /admin challenge create.`);
                            }

                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Check if there's an existing shadow game to be replaced
                            let replacedShadowGame = null;
                            if (targetChallenge.shadow_challange_gameid) {
                                try {
                                    const oldGameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
                                    replacedShadowGame = oldGameInfo.title;
                                } catch (error) {
                                    console.error('Error fetching old shadow game info:', error);
                                    replacedShadowGame = targetChallenge.shadow_challange_gameid;
                                }
                            }

                            // Update the challenge with shadow game information
                            targetChallenge.shadow_challange_gameid = gameId;
                            targetChallenge.shadow_challange_progression_achievements = progressionAchievements;
                            targetChallenge.shadow_challange_win_achievements = winAchievements;
                            targetChallenge.shadow_challange_game_total = totalAchievements;
                            
                            // Automatically reveal shadow games for past months
                            const now = new Date();
                            if (month < now.getMonth() + 1 || year < now.getFullYear()) {
                                targetChallenge.shadow_challange_revealed = true;
                            } else if (!targetChallenge.shadow_challange_revealed) {
                                // For current or future months, keep shadow games hidden by default
                                targetChallenge.shadow_challange_revealed = false;
                            }

                            await targetChallenge.save();

                            // Get month name for display
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Determine if it was auto-revealed
                            const autoRevealed = (month < now.getMonth() + 1 || year < now.getFullYear());
                            
                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#9932CC') // Dark purple for shadow challenges
                                .setTitle('Shadow Challenge Added')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (replacedShadowGame) {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} replaced`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: replacedShadowGame },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} created`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() },
                                { name: 'Visibility', value: targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden' + (autoRevealed ? ' (Auto-revealed as past challenge)' : '') }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('toggle_shadow')
                                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'toggle_shadow') {
                                        await this.handleToggleShadow(resultI, { month, year, force: true });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding shadow challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the shadow challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a shadow challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleToggleShadow(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            let force = options?.force || false;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                const now = new Date();
                month = now.getMonth() + 1; // 1-indexed month
                year = now.getFullYear();
            }
            
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the target challenge
            const targetChallenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!targetChallenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            if (!targetChallenge.shadow_challange_gameid) {
                return interaction.editReply(`No shadow challenge has been set for ${month}/${year}.`);
            }

            // Toggle the visibility
            targetChallenge.shadow_challange_revealed = !targetChallenge.shadow_challange_revealed;
            await targetChallenge.save();

            // Get game info for the response
            const gameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
            
            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Create response embed
            const resultEmbed = new EmbedBuilder()
                .setColor(targetChallenge.shadow_challange_revealed ? '#00FF00' : '#FF0000') // Green for revealed, red for hidden
                .setTitle(`Shadow Challenge ${targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden'}`)
                .setDescription(`The shadow challenge for ${monthName} ${year} is now ${targetChallenge.shadow_challange_revealed ? 'REVEALED' : 'HIDDEN'}.`)
                .setTimestamp();

            if (targetChallenge.shadow_challange_revealed) {
                resultEmbed.addFields(
                    { name: 'Game', value: gameInfo.title },
                    { name: 'Required Progression Achievements', value: targetChallenge.shadow_challange_progression_achievements.length.toString() },
                    { name: 'Required Win Achievements', value: targetChallenge.shadow_challange_win_achievements.length > 0 ? targetChallenge.shadow_challange_win_achievements.length.toString() : 'None' }
                );
                
                if (gameInfo.imageIcon) {
                    resultEmbed.setThumbnail(`https://retroachievements.org${gameInfo.imageIcon}`);
                }
            }

            // Add action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow_again')
                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                    new ButtonBuilder()
                        .setCustomId('view_challenge')
                        .setLabel('View Challenge Details')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ”')
                );

            // If we're force-updating from another command, use editReply
            // Otherwise, use standard reply
            if (force) {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            } else {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            }

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'toggle_shadow_again') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    } else if (i.customId === 'view_challenge') {
                        await this.handleViewChallenge(i, { month, year });
                    }
                }
            });

        } catch (error) {
            console.error('Error toggling shadow challenge visibility:', error);
            await interaction.editReply('An error occurred while toggling the shadow challenge visibility. Please try again.');
        }
    },

    async handleViewChallenge(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                // Open a form to select month/year
                const embed = new EmbedBuilder()
                    .setTitle('View Challenge Details')
                    .setColor('#3498DB')
                    .setDescription('Please select which challenge you want to view.')
                    .addFields(
                        {
                            name: 'Options',
                            value: 'You can view the current month\'s challenge or select a specific month.'
                        }
                    );

                // Create buttons
                const row = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('view_current_challenge')
                            .setLabel('Current Month')
                            .setStyle(ButtonStyle.Primary)
                            .setEmoji('ðŸ“…'),
                        new ButtonBuilder()
                            .setCustomId('select_month_challenge')
                            .setLabel('Select Month')
                            .setStyle(ButtonStyle.Secondary)
                            .setEmoji('ðŸ”')
                    );

                await interaction.editReply({
                    embeds: [embed],
                    components: [row]
                });

                // Set up collector for the buttons
                const message = await interaction.fetchReply();
                const buttonCollector = message.createMessageComponentCollector({
                    componentType: ComponentType.Button,
                    time: 300000 // 5 minutes timeout
                });

                buttonCollector.on('collect', async i => {
                    if (i.user.id === interaction.user.id) {
                        await i.deferUpdate();

                        if (i.customId === 'view_current_challenge') {
                            // Use current month
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                            
                            // Continue with viewing the challenge
                            await this.displayChallengeDetails(i, month, year);
                            
                            // Stop the collector
                            buttonCollector.stop();
                        } else if (i.customId === 'select_month_challenge') {
                            // Show modal to select month/year
                            const modal = new ModalBuilder()
                                .setCustomId('select_challenge_month_modal')
                                .setTitle('Select Challenge Month');

                            // Add month input
                            const monthInput = new TextInputBuilder()
                                .setCustomId('month')
                                .setLabel('Month (1-12)')
                                .setPlaceholder('Example: 5 (for May)')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add year input
                            const yearInput = new TextInputBuilder()
                                .setCustomId('year')
                                .setLabel('Year')
                                .setPlaceholder('Example: 2025')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add inputs to modal
                            const monthRow = new ActionRowBuilder().addComponents(monthInput);
                            const yearRow = new ActionRowBuilder().addComponents(yearInput);

                            modal.addComponents(monthRow, yearRow);

                            // Show the modal
                            await i.showModal(modal);

                            try {
                                // Wait for modal submission
                                const modalSubmission = await i.awaitModalSubmit({
                                    time: 300000 // 5 minutes to fill out the form
                                });

                                await modalSubmission.deferUpdate();

                                // Extract values from the modal
                                month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                                year = parseInt(modalSubmission.fields.getTextInputValue('year'));

                                // Validate inputs
                                if (isNaN(month) || month < 1 || month > 12) {
                                    return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                                }

                                if (isNaN(year) || year < 2000 || year > 2100) {
                                    return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                                }

                                // Continue with viewing the challenge
                                await this.displayChallengeDetails(modalSubmission, month, year);
                                
                                // Stop the collector
                                buttonCollector.stop();

                            } catch (modalError) {
                                console.error('Error handling modal submission:', modalError);
                                // Modal timed out or was cancelled
                            }
                        }
                    }
                });

                // Let the function end here and let the collector handle the rest
                return;
            }

            // If we have month/year, display the challenge
            await this.displayChallengeDetails(interaction, month, year);

        } catch (error) {
            console.error('Error viewing challenge:', error);
            await interaction.editReply('An error occurred while viewing the challenge. Please try again.');
        }
    },

    async displayChallengeDetails(interaction, month, year) {
        try {
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the challenge
            const challenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!challenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Get game info for monthly challenge
            let monthlyGameInfo = null;
            if (challenge.monthly_challange_gameid) {
                monthlyGameInfo = await retroAPI.getGameInfo(challenge.monthly_challange_gameid);
            }

            // Get game info for shadow challenge if revealed
            let shadowGameInfo = null;
            if (challenge.shadow_challange_gameid && challenge.shadow_challange_revealed) {
                shadowGameInfo = await retroAPI.getGameInfo(challenge.shadow_challange_gameid);
            }

            // Create main embed
            const embed = new EmbedBuilder()
                .setTitle(`Challenge Details: ${monthName} ${year}`)
                .setColor('#3498DB')
                .setDescription(`Here are the details for the ${monthName} ${year} challenges:`)
                .setTimestamp();

            // Add monthly challenge info
            if (monthlyGameInfo) {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: `**Game:** ${monthlyGameInfo.title}\n` +
                          `**Required Progression Achievements:** ${challenge.monthly_challange_progression_achievements.length}\n` +
                          `**Required Win Achievements:** ${challenge.monthly_challange_win_achievements.length}\n` +
                          `**Total Achievements:** ${challenge.monthly_challange_game_total}\n` +
                          `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.monthly_challange_gameid})`
                });

                if (monthlyGameInfo.imageIcon) {
                    embed.setThumbnail(`https://retroachievements.org${monthlyGameInfo.imageIcon}`);
                }
            } else {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: 'No monthly challenge set.'
                });
            }

            // Add shadow challenge info
            if (challenge.shadow_challange_gameid) {
                if (challenge.shadow_challange_revealed && shadowGameInfo) {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (REVEALED)',
                        value: `**Game:** ${shadowGameInfo.title}\n` +
                              `**Required Progression Achievements:** ${challenge.shadow_challange_progression_achievements.length}\n` +
                              `**Required Win Achievements:** ${challenge.shadow_challange_win_achievements.length}\n` +
                              `**Total Achievements:** ${challenge.shadow_challange_game_total}\n` +
                              `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.shadow_challange_gameid})`
                    });
                } else {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (HIDDEN)',
                        value: 'Shadow challenge exists but is currently hidden.\n' +
                              `Use \`/admin challenge toggle\` to reveal it.`
                    });
                }
            } else {
                embed.addFields({
                    name: 'ðŸ‘¥ Shadow Challenge',
                    value: 'No shadow challenge set.\n' +
                          `Use \`/admin challenge shadow\` to add one.`
                });
            }

            // Create action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('edit_monthly')
                        .setLabel('Edit Monthly Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('ðŸ†'),
                    new ButtonBuilder()
                        .setCustomId('edit_shadow')
                        .setLabel(challenge.shadow_challange_gameid ? 'Edit Shadow Challenge' : 'Add Shadow Challenge')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ‘¥')
                );

            // Add toggle button if shadow challenge exists
            if (challenge.shadow_challange_gameid) {
                actionRow.addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow')
                        .setLabel(challenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji(challenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸')
                );
            }

            await interaction.editReply({
                embeds: [embed],
                components: [actionRow]
            });

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'edit_monthly') {
                        await this.handleCreateChallenge(i);
                    } else if (i.customId === 'edit_shadow') {
                        await this.handleShadowChallenge(i, { month, year });
                    } else if (i.customId === 'toggle_shadow') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    }
                }
            });

        } catch (error) {
            console.error('Error displaying challenge details:', error);
            await interaction.editReply('An error occurred while retrieving challenge details. Please try again.');
        }
    },

    // ARCADE MANAGEMENT HANDLERS
    async handleArcadeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'add':
                await this.handleAddArcadeBoard(interaction);
                break;
            case 'racing':
                await this.handleAddRacingChallenge(interaction);
                break;
            case 'tiebreaker':
                await this.handleAddTiebreaker(interaction);
                break;
            case 'award':
                await this.handleAwardPoints(interaction);
                break;
            case 'announce':
                await this.handleAnnounceBoard(interaction);
                break;
            case 'view':
                await this.handleViewBoards(interaction);
                break;
            default:
                await interaction.editReply('Invalid arcade subcommand.');
        }
    },

    async handleAddArcadeBoard(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Arcade Board')
            .setColor('#9B59B6') // Purple
            .setDescription('Use this form to add a new arcade board to the community.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Board ID (unique identifier)\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description'
                },
                {
                    name: 'How to Find IDs',
                    value: '**Game ID**: The number at the end of the game URL on RetroAchievements\n**Leaderboard ID**: The number at the end of the leaderboard URL'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_arcade_form')
                    .setLabel('Open Arcade Board Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ¯')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_arcade_form') {
                    // Create modal for arcade board
                    const modal = new ModalBuilder()
                        .setCustomId('add_arcade_modal')
                        .setTitle('Add Arcade Board');

                    // Add board ID input
                    const boardIdInput = new TextInputBuilder()
                        .setCustomId('board_id')
                        .setLabel('Board ID (unique identifier)')
                        .setPlaceholder('Example: sonic3-special-stages')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this arcade board challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add inputs to modal
                    const boardIdRow = new ActionRowBuilder().addComponents(boardIdInput);
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);

                    modal.addComponents(boardIdRow, gameIdRow, leaderboardIdRow, descriptionRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const boardId = modalSubmission.fields.getTextInputValue('board_id');
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        try {
                            // Check if board ID already exists
                            const existingBoard = await ArcadeBoard.findOne({ boardId });
                            if (existingBoard) {
                                return modalSubmission.editReply(`A board with ID "${boardId}" already exists.`);
                            }

                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Create new board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'arcade',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description
                            });

                            await newBoard.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Arcade Board Added')
                                .setDescription(`Successfully added "${gameInfo.title}" arcade board!`)
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .addFields(
                                    { name: 'Board ID', value: boardId },
                                    { name: 'Game', value: gameInfo.title },
                                    { name: 'Console', value: gameInfo.consoleName || 'Unknown' },
                                    { name: 'Description', value: description }
                                )
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_board')
                                        .setLabel('Announce Board')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_board') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding arcade board:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the arcade board. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add an arcade board.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddRacingChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Racing Challenge')
            .setColor('#FF9900') // Orange
            .setDescription('Use this form to set up a monthly racing challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Track Name\nâ€¢ Description\nâ€¢ Month and Year (optional, defaults to current month)'
                },
                {
                    name: 'Racing Challenge Rules',
                    value: 'Racing challenges are monthly competitions where players compete on time-based leaderboards. The top 3 players will receive community points.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_racing_form')
                    .setLabel('Open Racing Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_racing_form') {
                    // Create modal for racing challenge
                    const modal = new ModalBuilder()
                        .setCustomId('add_racing_modal')
                        .setTitle('Add Racing Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add track name input
                    const trackNameInput = new TextInputBuilder()
                        .setCustomId('track_name')
                        .setLabel('Track Name')
                        .setPlaceholder('Example: Rainbow Road')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this racing challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add month/year input
                    const monthYearInput = new TextInputBuilder()
                        .setCustomId('month_year')
                        .setLabel('Month and Year (optional, MM/YYYY format)')
                        .setPlaceholder('Example: 05/2025 (defaults to current month)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const trackNameRow = new ActionRowBuilder().addComponents(trackNameInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthYearInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, trackNameRow, descriptionRow, monthYearRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const trackName = modalSubmission.fields.getTextInputValue('track_name');
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const monthYearInput = modalSubmission.fields.getTextInputValue('month_year');

                        // Parse month and year
                        let month, year;
                        if (monthYearInput && monthYearInput.trim()) {
                            const parts = monthYearInput.split('/');
                            if (parts.length === 2) {
                                month = parseInt(parts[0]);
                                year = parseInt(parts[1]);
                            } else {
                                // Invalid format, use current month/year
                                const now = new Date();
                                month = now.getMonth() + 1;
                                year = now.getFullYear();
                            }
                        } else {
                            // No input, use current month/year
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                        }

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Calculate start and end dates
                            // Start at beginning of specified month
                            const startDate = new Date(year, month - 1, 1);
                            
                            // End at the end of the specified month (23:59:59 on the last day)
                            const endDate = new Date(year, month, 0, 23, 59, 59);
                            
                            // Check if a racing challenge already exists for this month
                            const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                            const existingChallenge = await ArcadeBoard.findOne({
                                boardType: 'racing',
                                monthKey
                            });

                            if (existingChallenge) {
                                return modalSubmission.editReply(`A racing challenge already exists for ${monthKey}.`);
                            }

                            // Generate a unique board ID specifically for racing
                            // This format ensures no overlap with regular arcade boards
                            const boardId = `racing-${monthKey}`;

                            // Get the full game title and console name
                            const gameFull = `${gameInfo.title} (${gameInfo.consoleName})`;

                            // Create new racing board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'racing',
                                leaderboardId,
                                gameId,
                                gameTitle: gameFull,
                                trackName,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate,
                                endDate,
                                monthKey
                            });

                            await newBoard.save();

                            // Get month name for response
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF9900') // Orange for racing
                                .setTitle(`Racing Challenge Created: ${monthName} ${year}`)
                                .setDescription(
                                    `**Game:** ${gameFull}\n` +
                                    `**Track:** ${trackName}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Challenge Period:** ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `The top 3 players at the end of the month will receive award points!`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_racing')
                                        .setLabel('Announce Racing Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_racing') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding racing challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the racing challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a racing challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddTiebreaker(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Tiebreaker')
            .setColor('#FF0000') // Red
            .setDescription('Use this form to create a tiebreaker leaderboard for the monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description\nâ€¢ End Date (YYYY-MM-DD format)'
                },
                {
                    name: 'Tiebreaker Rules',
                    value: 'Tiebreakers are used to resolve ties in the monthly challenge leaderboard. Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_tiebreaker_form')
                    .setLabel('Open Tiebreaker Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('âš”ï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_tiebreaker_form') {
                    // Create modal for tiebreaker
                    const modal = new ModalBuilder()
                        .setCustomId('add_tiebreaker_modal')
                        .setTitle('Add Tiebreaker');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this tiebreaker challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add end date input
                    const endDateInput = new TextInputBuilder()
                        .setCustomId('end_date')
                        .setLabel('End Date (YYYY-MM-DD format)')
                        .setPlaceholder('Example: 2025-05-31')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const endDateRow = new ActionRowBuilder().addComponents(endDateInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, descriptionRow, endDateRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const endDateStr = modalSubmission.fields.getTextInputValue('end_date');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        // Parse end date
                        const endDate = new Date(endDateStr);
                        if (isNaN(endDate.getTime())) {
                            return modalSubmission.editReply('Invalid end date format. Please use YYYY-MM-DD.');
                        }

                        // Set end time to 23:59:59
                        endDate.setHours(23, 59, 59);

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Check if an active tiebreaker already exists
                            const now = new Date();
                            const activeTiebreaker = await ArcadeBoard.findOne({
                                boardType: 'tiebreaker',
                                startDate: { $lte: now },
                                endDate: { $gte: now }
                            });

                            if (activeTiebreaker) {
                                return modalSubmission.editReply('An active tiebreaker already exists. Please end it before creating a new one.');
                            }

                            // Generate a unique board ID based on month and year
                            const monthYear = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}`;
                            const boardId = `tiebreaker-${monthYear}`;

                            // Create new tiebreaker board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'tiebreaker',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate: now,
                                endDate,
                                // Add monthKey for consistency with racing challenges
                                monthKey: monthYear
                            });

                            await newBoard.save();

                            // Get the month name
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[now.getMonth()];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF0000') // Red for tiebreaker
                                .setTitle(`âš”ï¸ Tiebreaker Created: ${monthName} ${now.getFullYear()}`)
                                .setDescription(
                                    `**Game:** ${gameInfo.title}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Tiebreaker Period:** ${now.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `This tiebreaker will be used to resolve ties in the ${monthName} monthly challenge leaderboard. ` +
                                    `Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_tiebreaker')
                                        .setLabel('Announce Tiebreaker')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_tiebreaker') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding tiebreaker:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the tiebreaker. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a tiebreaker.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAwardPoints(interaction) {
        // Create select board form
        const embed = new EmbedBuilder()
            .setTitle('Award Points')
            .setColor('#32CD32') // Lime green
            .setDescription('Select a board to award points for.')
            .addFields(
                {
                    name: 'Award Points',
                    value: 'You can award points for completed racing challenges or arcade boards. For racing challenges, points are awarded to the top 3 players. For arcade boards, points are awarded annually.'
                }
            );

        // Find all racing boards and tiebreakers
        const racingBoards = await ArcadeBoard.find({ 
            boardType: 'racing',
            pointsAwarded: { $ne: true } // Only show boards that haven't been awarded points yet
        }).sort({ startDate: -1 });

        // Create options for racing boards
        const boardOptions = racingBoards.map(board => {
            const monthYear = board.monthKey || 'Unknown Date';
            return {
                label: `Racing: ${board.gameTitle}${board.trackName ? ` - ${board.trackName}` : ''}`,
                description: `${monthYear}`,
                value: `racing-${board.boardId}`
            };
        });

        // Add option for annual arcade awards if any arcade boards exist
        const arcadeBoards = await ArcadeBoard.find({ boardType: 'arcade' });
        if (arcadeBoards.length > 0) {
            boardOptions.push({
                label: 'Annual Arcade Awards',
                description: 'Award points for all arcade boards for the current year',
                value: 'arcade-annual'
            });
        }

        // Create dropdown if we have options
        if (boardOptions.length === 0) {
            return interaction.editReply('No eligible boards found for awarding points. All racing challenges have already been awarded points, or no racing challenges exist.');
        }

        // Create the dropdown
        const row = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('select_board_for_award')
                    .setPlaceholder('Select a board to award points')
                    .addOptions(boardOptions)
            );

        // Send the selection menu
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the dropdown selection
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.StringSelect,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                await i.deferUpdate();
                
                const selectedValue = i.values[0];
                
                if (selectedValue.startsWith('racing-')) {
                    // Extract board ID
                    const boardId = selectedValue.substring(7);
                    await this.awardRacingPoints(i, boardId);
                } else if (selectedValue === 'arcade-annual') {
                    await this.awardArcadePoints(i);
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        StringSelectMenuBuilder.from(row.components[0])
                            .setDisabled(true)
                            .setPlaceholder('Selection timed out')
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This selection has expired. Please run the command again if you still need to award points.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling dropdown:', error);
                }
            }
        });
    },

    async awardRacingPoints(interaction, boardId) {
        try {
            // Find the racing board
            const racingBoard = await ArcadeBoard.findOne({ 
                boardId,
                boardType: 'racing'
            });

            if (!racingBoard) {
                return interaction.editReply(`Racing board with ID "${boardId}" not found.`);
            }

            // Check if points have already been awarded
            if (racingBoard.pointsAwarded) {
                return interaction.editReply(`Points have already been awarded for this racing challenge.`);
            }

            // Check if the racing challenge has ended
            const now = new Date();
            if (racingBoard.endDate > now) {
                return interaction.editReply(`This racing challenge hasn't ended yet. It ends on ${racingBoard.endDate.toLocaleDateString()}.`);
            }

, 'i') }
            });

            if (!user) {
                return interaction.editReply('User not found. Please check the username.');
            }

            // Get Discord user info for the response
            let discordUserInfo = 'Unknown Discord user';
            try {
                const discordUser = await interaction.client.users.fetch(user.discordId);
                if (discordUser) {
                    discordUserInfo = discordUser.tag;
                }
            } catch (error) {
                console.error('Error fetching Discord user:', error);
            }

            // Create confirmation embed
            const confirmEmbed = new EmbedBuilder()
                .setTitle('Confirm Unregistration')
                .setColor('#FF0000') // Red for danger
                .setDescription(`Are you sure you want to unregister this user? This action can be undone by re-registering later.`)
                .addFields(
                    {
                        name: 'User Information',
                        value: `**RA Username:** ${user.raUsername}\n` +
                               `**Discord:** ${discordUserInfo}\n` +
                               `**Registered Since:** ${new Date(user.registeredAt || user.createdAt).toLocaleDateString()}`
                    }
                )
                .setTimestamp();
                
            // Create confirmation buttons
            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('confirm_unregister')
                        .setLabel('Unregister User')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('âœ…'),
                    new ButtonBuilder()
                        .setCustomId('cancel_unregister')
                        .setLabel('Cancel')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('âŒ')
                );
                
            await interaction.editReply({
                embeds: [confirmEmbed],
                components: [row]
            });
            
            // Set up collector for the confirmation buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 60000 // 1 minute timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'confirm_unregister') {
                        // Delete the user
                        await User.deleteOne({ _id: user._id });
                        
                        // Show success message
                        const successEmbed = new EmbedBuilder()
                            .setColor('#00FF00') // Green for success
                            .setTitle('User Unregistered')
                            .setDescription(`The user "${user.raUsername}" has been successfully unregistered.`)
                            .addFields(
                                {
                                    name: 'User Information',
                                    value: `**RA Username:** ${user.raUsername}\n` +
                                        `**Discord:** ${discordUserInfo}`
                                }
                            )
                            .setTimestamp();
                            
                        await i.editReply({
                            embeds: [successEmbed],
                            components: []
                        });
                    } else if (i.customId === 'cancel_unregister') {
                        // Show cancellation message
                        await i.editReply({
                            content: 'Unregistration cancelled.',
                            embeds: [],
                            components: []
                        });
                    }
                }
            });
        } catch (error) {
            console.error('Error unregistering user:', error);
            return interaction.editReply('An error occurred while unregistering the user. Please try again.');
        }
    },

    async handlePurgeRegistration(interaction) {
        try {
            const raUsername = interaction.options.getString('ra_username');
            const discordUser = interaction.options.getUser('discord_user');
            
            // Build query based on provided information
            let query = {
                raUsername: { $regex: new RegExp(`^${raUsername}import { 
    SlashCommandBuilder, 
    EmbedBuilder, 
    ActionRowBuilder, 
    StringSelectMenuBuilder,
    ButtonBuilder,
    ButtonStyle,
    ComponentType,
    ModalBuilder,
    TextInputBuilder,
    TextInputStyle,
    PermissionFlagsBits
} from 'discord.js';
import { User } from '../../models/User.js';
import { Challenge } from '../../models/Challenge.js';
import { ArcadeBoard } from '../../models/ArcadeBoard.js';
import { Poll } from '../../models/Poll.js';
import retroAPI from '../../services/retroAPI.js';
import { config } from '../../config/config.js';

// Constants
const MEMBER_ROLE_ID = '1316292690870014002';

export default {
    data: new SlashCommandBuilder()
        .setName('admin')
        .setDescription('Admin dashboard for managing all aspects of the community')
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild) // Require admin permissions
        // Challenge Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('challenge')
                .setDescription('Manage monthly and shadow challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('create')
                        .setDescription('Create or replace a monthly challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('shadow')
                        .setDescription('Add or edit a shadow challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('toggle')
                        .setDescription('Toggle shadow challenge visibility')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View current challenge details')
                )
        )
        
        // Arcade Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('arcade')
                .setDescription('Manage arcade boards and racing challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('add')
                        .setDescription('Add an arcade board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('racing')
                        .setDescription('Set up a racing challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('tiebreaker')
                        .setDescription('Create a tiebreaker board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Award points for a completed board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('announce')
                        .setDescription('Announce a board to the community')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View and manage existing boards')
                )
        )
        
        // User Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('user')
                .setDescription('Manage users, registrations, and awards')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('register')
                        .setDescription('Register a user')
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to register')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('unregister')
                        .setDescription('Unregister a user')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to unregister')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('purge')
                        .setDescription('Completely remove a user registration')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to purge')
                            .setRequired(true))
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to purge (optional)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Give a community award to a user')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('title')
                            .setDescription('The title of the award')
                            .setRequired(true))
                        .addIntegerOption(option =>
                            option.setName('points')
                            .setDescription('Number of points for this award')
                            .setRequired(true)
                            .setMinValue(1))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('awards')
                        .setDescription('View user awards')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('clear')
                        .setDescription('Clear nominations or awards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('reset')
                        .setDescription('Reset user achievements')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('RetroAchievements username')
                            .setRequired(true))
                )
        )
        
        // Voting Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('voting')
                .setDescription('Manage voting processes')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('start')
                        .setDescription('Start a voting poll')
                        .addChannelOption(option =>
                            option.setName('channel')
                            .setDescription('The channel to create the poll announcement in')
                            .setRequired(true))
                        .addChannelOption(option =>
                            option.setName('results_channel')
                            .setDescription('The channel to announce results in (defaults to same channel)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('cancel')
                        .setDescription('Cancel an active voting poll')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('status')
                        .setDescription('Check status of current voting')
                )
        )
        
        // System Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('system')
                .setDescription('System-level operations')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('update')
                        .setDescription('Force an update of all stats and leaderboards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('suggestions')
                        .setDescription('Manage community suggestions')
                )
        )
        
        // Info display subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('info')
                .setDescription('Display shareable information')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('arcade')
                        .setDescription('Display arcade board information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('challenges')
                        .setDescription('Display challenge information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('overview')
                        .setDescription('Display community overview')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('commands')
                        .setDescription('Display available commands')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('rules')
                        .setDescription('Display community rules')
                )
        ),

    async execute(interaction) {
        // Check if user has admin role
        if (!interaction.member.roles.cache.has(config.bot.roles.admin)) {
            return interaction.reply({
                content: 'You do not have permission to use this command.',
                ephemeral: true
            });
        }

        await interaction.deferReply({ ephemeral: true });

        try {
            // Extract subcommand group and subcommand
            const subcommandGroup = interaction.options.getSubcommandGroup();
            const subcommand = interaction.options.getSubcommand();
            
            // Route to the appropriate handler based on subcommand group and subcommand
            switch (subcommandGroup) {
                case 'challenge':
                    await this.handleChallengeCommand(interaction, subcommand);
                    break;
                case 'arcade':
                    await this.handleArcadeCommand(interaction, subcommand);
                    break;
                case 'user':
                    await this.handleUserCommand(interaction, subcommand);
                    break;
                case 'voting':
                    await this.handleVotingCommand(interaction, subcommand);
                    break;
                case 'system':
                    await this.handleSystemCommand(interaction, subcommand);
                    break;
                case 'info':
                    await this.handleInfoCommand(interaction, subcommand);
                    break;
                default:
                    await interaction.editReply('Invalid subcommand group.');
            }
        } catch (error) {
            console.error('Error executing admin command:', error);
            await interaction.editReply('An error occurred while processing your request.');
        }
    },

    // CHALLENGE MANAGEMENT HANDLERS
    async handleChallengeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'create':
                await this.handleCreateChallenge(interaction);
                break;
            case 'shadow':
                await this.handleShadowChallenge(interaction);
                break;
            case 'toggle':
                await this.handleToggleShadow(interaction);
                break;
            case 'view':
                await this.handleViewChallenge(interaction);
                break;
            default:
                await interaction.editReply('Invalid challenge subcommand.');
        }
    },

    async handleCreateChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Create Monthly Challenge')
            .setColor('#32CD32')
            .setDescription('Use this form to create or replace a monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'How to Find Achievement IDs',
                    value: 'Go to the game page on RetroAchievements, hover over an achievement, and note the ID number in the URL.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('create_challenge_form')
                    .setLabel('Open Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ®')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'create_challenge_form') {
                    // Create modal for challenge creation
                    const modal = new ModalBuilder()
                        .setCustomId('create_challenge_modal')
                        .setTitle('Create Monthly Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add year input
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Create date for the first of the specified month
                            const challengeDate = new Date(year, month - 1, 1);

                            // Check if a challenge already exists for this month
                            const existingChallenge = await Challenge.findOneAndDelete({
                                date: {
                                    $gte: challengeDate,
                                    $lt: new Date(year, month, 1)
                                }
                            });

                            // Create new challenge
                            const challenge = new Challenge({
                                date: challengeDate,
                                monthly_challange_gameid: gameId,
                                monthly_challange_progression_achievements: progressionAchievements,
                                monthly_challange_win_achievements: winAchievements,
                                monthly_challange_game_total: totalAchievements,
                                shadow_challange_revealed: false // Keep shadow challenge hidden by default
                            });

                            await challenge.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Monthly Challenge Created')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (existingChallenge) {
                                resultEmbed.setDescription(`Monthly challenge replaced for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: existingChallenge.monthly_challange_gameid.toString() },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Monthly challenge created for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('add_shadow')
                                        .setLabel('Add Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ‘¥'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'add_shadow') {
                                        await this.handleShadowChallenge(resultI, { month, year });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error creating challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while creating the challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to create a challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleShadowChallenge(interaction, prefilledData = null) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Shadow Challenge')
            .setColor('#9932CC') // Dark purple
            .setDescription('Use this form to add or edit a shadow challenge for a specific month.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'Shadow Challenge Rules',
                    value: 'Shadow challenges are hidden mysteries that players can discover by guessing or playing the challenge games. They automatically reveal for past months.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('shadow_challenge_form')
                    .setLabel('Open Shadow Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸ‘¥')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'shadow_challenge_form') {
                    // Create modal for shadow challenge
                    const modal = new ModalBuilder()
                        .setCustomId('shadow_challenge_modal')
                        .setTitle('Add Shadow Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input with prefilled data if available
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.month) {
                        monthInput.setValue(prefilledData.month.toString());
                    } else {
                        // Default to current month
                        const now = new Date();
                        monthInput.setValue((now.getMonth() + 1).toString());
                    }

                    // Add year input with prefilled data if available
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.year) {
                        yearInput.setValue(prefilledData.year.toString());
                    } else {
                        // Default to current year
                        const now = new Date();
                        yearInput.setValue(now.getFullYear().toString());
                    }

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get date range for the specified month
                            const monthStart = new Date(year, month - 1, 1);
                            const nextMonthStart = new Date(year, month, 1);

                            // Find the target challenge
                            const targetChallenge = await Challenge.findOne({
                                date: {
                                    $gte: monthStart,
                                    $lt: nextMonthStart
                                }
                            });

                            if (!targetChallenge) {
                                return modalSubmission.editReply(`No challenge exists for ${month}/${year}. Create a monthly challenge first using /admin challenge create.`);
                            }

                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Check if there's an existing shadow game to be replaced
                            let replacedShadowGame = null;
                            if (targetChallenge.shadow_challange_gameid) {
                                try {
                                    const oldGameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
                                    replacedShadowGame = oldGameInfo.title;
                                } catch (error) {
                                    console.error('Error fetching old shadow game info:', error);
                                    replacedShadowGame = targetChallenge.shadow_challange_gameid;
                                }
                            }

                            // Update the challenge with shadow game information
                            targetChallenge.shadow_challange_gameid = gameId;
                            targetChallenge.shadow_challange_progression_achievements = progressionAchievements;
                            targetChallenge.shadow_challange_win_achievements = winAchievements;
                            targetChallenge.shadow_challange_game_total = totalAchievements;
                            
                            // Automatically reveal shadow games for past months
                            const now = new Date();
                            if (month < now.getMonth() + 1 || year < now.getFullYear()) {
                                targetChallenge.shadow_challange_revealed = true;
                            } else if (!targetChallenge.shadow_challange_revealed) {
                                // For current or future months, keep shadow games hidden by default
                                targetChallenge.shadow_challange_revealed = false;
                            }

                            await targetChallenge.save();

                            // Get month name for display
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Determine if it was auto-revealed
                            const autoRevealed = (month < now.getMonth() + 1 || year < now.getFullYear());
                            
                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#9932CC') // Dark purple for shadow challenges
                                .setTitle('Shadow Challenge Added')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (replacedShadowGame) {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} replaced`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: replacedShadowGame },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} created`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() },
                                { name: 'Visibility', value: targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden' + (autoRevealed ? ' (Auto-revealed as past challenge)' : '') }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('toggle_shadow')
                                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'toggle_shadow') {
                                        await this.handleToggleShadow(resultI, { month, year, force: true });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding shadow challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the shadow challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a shadow challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleToggleShadow(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            let force = options?.force || false;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                const now = new Date();
                month = now.getMonth() + 1; // 1-indexed month
                year = now.getFullYear();
            }
            
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the target challenge
            const targetChallenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!targetChallenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            if (!targetChallenge.shadow_challange_gameid) {
                return interaction.editReply(`No shadow challenge has been set for ${month}/${year}.`);
            }

            // Toggle the visibility
            targetChallenge.shadow_challange_revealed = !targetChallenge.shadow_challange_revealed;
            await targetChallenge.save();

            // Get game info for the response
            const gameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
            
            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Create response embed
            const resultEmbed = new EmbedBuilder()
                .setColor(targetChallenge.shadow_challange_revealed ? '#00FF00' : '#FF0000') // Green for revealed, red for hidden
                .setTitle(`Shadow Challenge ${targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden'}`)
                .setDescription(`The shadow challenge for ${monthName} ${year} is now ${targetChallenge.shadow_challange_revealed ? 'REVEALED' : 'HIDDEN'}.`)
                .setTimestamp();

            if (targetChallenge.shadow_challange_revealed) {
                resultEmbed.addFields(
                    { name: 'Game', value: gameInfo.title },
                    { name: 'Required Progression Achievements', value: targetChallenge.shadow_challange_progression_achievements.length.toString() },
                    { name: 'Required Win Achievements', value: targetChallenge.shadow_challange_win_achievements.length > 0 ? targetChallenge.shadow_challange_win_achievements.length.toString() : 'None' }
                );
                
                if (gameInfo.imageIcon) {
                    resultEmbed.setThumbnail(`https://retroachievements.org${gameInfo.imageIcon}`);
                }
            }

            // Add action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow_again')
                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                    new ButtonBuilder()
                        .setCustomId('view_challenge')
                        .setLabel('View Challenge Details')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ”')
                );

            // If we're force-updating from another command, use editReply
            // Otherwise, use standard reply
            if (force) {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            } else {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            }

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'toggle_shadow_again') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    } else if (i.customId === 'view_challenge') {
                        await this.handleViewChallenge(i, { month, year });
                    }
                }
            });

        } catch (error) {
            console.error('Error toggling shadow challenge visibility:', error);
            await interaction.editReply('An error occurred while toggling the shadow challenge visibility. Please try again.');
        }
    },

    async handleViewChallenge(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                // Open a form to select month/year
                const embed = new EmbedBuilder()
                    .setTitle('View Challenge Details')
                    .setColor('#3498DB')
                    .setDescription('Please select which challenge you want to view.')
                    .addFields(
                        {
                            name: 'Options',
                            value: 'You can view the current month\'s challenge or select a specific month.'
                        }
                    );

                // Create buttons
                const row = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('view_current_challenge')
                            .setLabel('Current Month')
                            .setStyle(ButtonStyle.Primary)
                            .setEmoji('ðŸ“…'),
                        new ButtonBuilder()
                            .setCustomId('select_month_challenge')
                            .setLabel('Select Month')
                            .setStyle(ButtonStyle.Secondary)
                            .setEmoji('ðŸ”')
                    );

                await interaction.editReply({
                    embeds: [embed],
                    components: [row]
                });

                // Set up collector for the buttons
                const message = await interaction.fetchReply();
                const buttonCollector = message.createMessageComponentCollector({
                    componentType: ComponentType.Button,
                    time: 300000 // 5 minutes timeout
                });

                buttonCollector.on('collect', async i => {
                    if (i.user.id === interaction.user.id) {
                        await i.deferUpdate();

                        if (i.customId === 'view_current_challenge') {
                            // Use current month
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                            
                            // Continue with viewing the challenge
                            await this.displayChallengeDetails(i, month, year);
                            
                            // Stop the collector
                            buttonCollector.stop();
                        } else if (i.customId === 'select_month_challenge') {
                            // Show modal to select month/year
                            const modal = new ModalBuilder()
                                .setCustomId('select_challenge_month_modal')
                                .setTitle('Select Challenge Month');

                            // Add month input
                            const monthInput = new TextInputBuilder()
                                .setCustomId('month')
                                .setLabel('Month (1-12)')
                                .setPlaceholder('Example: 5 (for May)')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add year input
                            const yearInput = new TextInputBuilder()
                                .setCustomId('year')
                                .setLabel('Year')
                                .setPlaceholder('Example: 2025')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add inputs to modal
                            const monthRow = new ActionRowBuilder().addComponents(monthInput);
                            const yearRow = new ActionRowBuilder().addComponents(yearInput);

                            modal.addComponents(monthRow, yearRow);

                            // Show the modal
                            await i.showModal(modal);

                            try {
                                // Wait for modal submission
                                const modalSubmission = await i.awaitModalSubmit({
                                    time: 300000 // 5 minutes to fill out the form
                                });

                                await modalSubmission.deferUpdate();

                                // Extract values from the modal
                                month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                                year = parseInt(modalSubmission.fields.getTextInputValue('year'));

                                // Validate inputs
                                if (isNaN(month) || month < 1 || month > 12) {
                                    return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                                }

                                if (isNaN(year) || year < 2000 || year > 2100) {
                                    return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                                }

                                // Continue with viewing the challenge
                                await this.displayChallengeDetails(modalSubmission, month, year);
                                
                                // Stop the collector
                                buttonCollector.stop();

                            } catch (modalError) {
                                console.error('Error handling modal submission:', modalError);
                                // Modal timed out or was cancelled
                            }
                        }
                    }
                });

                // Let the function end here and let the collector handle the rest
                return;
            }

            // If we have month/year, display the challenge
            await this.displayChallengeDetails(interaction, month, year);

        } catch (error) {
            console.error('Error viewing challenge:', error);
            await interaction.editReply('An error occurred while viewing the challenge. Please try again.');
        }
    },

    async displayChallengeDetails(interaction, month, year) {
        try {
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the challenge
            const challenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!challenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Get game info for monthly challenge
            let monthlyGameInfo = null;
            if (challenge.monthly_challange_gameid) {
                monthlyGameInfo = await retroAPI.getGameInfo(challenge.monthly_challange_gameid);
            }

            // Get game info for shadow challenge if revealed
            let shadowGameInfo = null;
            if (challenge.shadow_challange_gameid && challenge.shadow_challange_revealed) {
                shadowGameInfo = await retroAPI.getGameInfo(challenge.shadow_challange_gameid);
            }

            // Create main embed
            const embed = new EmbedBuilder()
                .setTitle(`Challenge Details: ${monthName} ${year}`)
                .setColor('#3498DB')
                .setDescription(`Here are the details for the ${monthName} ${year} challenges:`)
                .setTimestamp();

            // Add monthly challenge info
            if (monthlyGameInfo) {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: `**Game:** ${monthlyGameInfo.title}\n` +
                          `**Required Progression Achievements:** ${challenge.monthly_challange_progression_achievements.length}\n` +
                          `**Required Win Achievements:** ${challenge.monthly_challange_win_achievements.length}\n` +
                          `**Total Achievements:** ${challenge.monthly_challange_game_total}\n` +
                          `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.monthly_challange_gameid})`
                });

                if (monthlyGameInfo.imageIcon) {
                    embed.setThumbnail(`https://retroachievements.org${monthlyGameInfo.imageIcon}`);
                }
            } else {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: 'No monthly challenge set.'
                });
            }

            // Add shadow challenge info
            if (challenge.shadow_challange_gameid) {
                if (challenge.shadow_challange_revealed && shadowGameInfo) {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (REVEALED)',
                        value: `**Game:** ${shadowGameInfo.title}\n` +
                              `**Required Progression Achievements:** ${challenge.shadow_challange_progression_achievements.length}\n` +
                              `**Required Win Achievements:** ${challenge.shadow_challange_win_achievements.length}\n` +
                              `**Total Achievements:** ${challenge.shadow_challange_game_total}\n` +
                              `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.shadow_challange_gameid})`
                    });
                } else {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (HIDDEN)',
                        value: 'Shadow challenge exists but is currently hidden.\n' +
                              `Use \`/admin challenge toggle\` to reveal it.`
                    });
                }
            } else {
                embed.addFields({
                    name: 'ðŸ‘¥ Shadow Challenge',
                    value: 'No shadow challenge set.\n' +
                          `Use \`/admin challenge shadow\` to add one.`
                });
            }

            // Create action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('edit_monthly')
                        .setLabel('Edit Monthly Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('ðŸ†'),
                    new ButtonBuilder()
                        .setCustomId('edit_shadow')
                        .setLabel(challenge.shadow_challange_gameid ? 'Edit Shadow Challenge' : 'Add Shadow Challenge')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ‘¥')
                );

            // Add toggle button if shadow challenge exists
            if (challenge.shadow_challange_gameid) {
                actionRow.addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow')
                        .setLabel(challenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji(challenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸')
                );
            }

            await interaction.editReply({
                embeds: [embed],
                components: [actionRow]
            });

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'edit_monthly') {
                        await this.handleCreateChallenge(i);
                    } else if (i.customId === 'edit_shadow') {
                        await this.handleShadowChallenge(i, { month, year });
                    } else if (i.customId === 'toggle_shadow') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    }
                }
            });

        } catch (error) {
            console.error('Error displaying challenge details:', error);
            await interaction.editReply('An error occurred while retrieving challenge details. Please try again.');
        }
    },

    // ARCADE MANAGEMENT HANDLERS
    async handleArcadeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'add':
                await this.handleAddArcadeBoard(interaction);
                break;
            case 'racing':
                await this.handleAddRacingChallenge(interaction);
                break;
            case 'tiebreaker':
                await this.handleAddTiebreaker(interaction);
                break;
            case 'award':
                await this.handleAwardPoints(interaction);
                break;
            case 'announce':
                await this.handleAnnounceBoard(interaction);
                break;
            case 'view':
                await this.handleViewBoards(interaction);
                break;
            default:
                await interaction.editReply('Invalid arcade subcommand.');
        }
    },

    async handleAddArcadeBoard(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Arcade Board')
            .setColor('#9B59B6') // Purple
            .setDescription('Use this form to add a new arcade board to the community.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Board ID (unique identifier)\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description'
                },
                {
                    name: 'How to Find IDs',
                    value: '**Game ID**: The number at the end of the game URL on RetroAchievements\n**Leaderboard ID**: The number at the end of the leaderboard URL'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_arcade_form')
                    .setLabel('Open Arcade Board Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ¯')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_arcade_form') {
                    // Create modal for arcade board
                    const modal = new ModalBuilder()
                        .setCustomId('add_arcade_modal')
                        .setTitle('Add Arcade Board');

                    // Add board ID input
                    const boardIdInput = new TextInputBuilder()
                        .setCustomId('board_id')
                        .setLabel('Board ID (unique identifier)')
                        .setPlaceholder('Example: sonic3-special-stages')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this arcade board challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add inputs to modal
                    const boardIdRow = new ActionRowBuilder().addComponents(boardIdInput);
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);

                    modal.addComponents(boardIdRow, gameIdRow, leaderboardIdRow, descriptionRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const boardId = modalSubmission.fields.getTextInputValue('board_id');
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        try {
                            // Check if board ID already exists
                            const existingBoard = await ArcadeBoard.findOne({ boardId });
                            if (existingBoard) {
                                return modalSubmission.editReply(`A board with ID "${boardId}" already exists.`);
                            }

                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Create new board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'arcade',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description
                            });

                            await newBoard.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Arcade Board Added')
                                .setDescription(`Successfully added "${gameInfo.title}" arcade board!`)
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .addFields(
                                    { name: 'Board ID', value: boardId },
                                    { name: 'Game', value: gameInfo.title },
                                    { name: 'Console', value: gameInfo.consoleName || 'Unknown' },
                                    { name: 'Description', value: description }
                                )
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_board')
                                        .setLabel('Announce Board')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_board') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding arcade board:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the arcade board. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add an arcade board.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddRacingChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Racing Challenge')
            .setColor('#FF9900') // Orange
            .setDescription('Use this form to set up a monthly racing challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Track Name\nâ€¢ Description\nâ€¢ Month and Year (optional, defaults to current month)'
                },
                {
                    name: 'Racing Challenge Rules',
                    value: 'Racing challenges are monthly competitions where players compete on time-based leaderboards. The top 3 players will receive community points.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_racing_form')
                    .setLabel('Open Racing Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_racing_form') {
                    // Create modal for racing challenge
                    const modal = new ModalBuilder()
                        .setCustomId('add_racing_modal')
                        .setTitle('Add Racing Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add track name input
                    const trackNameInput = new TextInputBuilder()
                        .setCustomId('track_name')
                        .setLabel('Track Name')
                        .setPlaceholder('Example: Rainbow Road')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this racing challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add month/year input
                    const monthYearInput = new TextInputBuilder()
                        .setCustomId('month_year')
                        .setLabel('Month and Year (optional, MM/YYYY format)')
                        .setPlaceholder('Example: 05/2025 (defaults to current month)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const trackNameRow = new ActionRowBuilder().addComponents(trackNameInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthYearInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, trackNameRow, descriptionRow, monthYearRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const trackName = modalSubmission.fields.getTextInputValue('track_name');
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const monthYearInput = modalSubmission.fields.getTextInputValue('month_year');

                        // Parse month and year
                        let month, year;
                        if (monthYearInput && monthYearInput.trim()) {
                            const parts = monthYearInput.split('/');
                            if (parts.length === 2) {
                                month = parseInt(parts[0]);
                                year = parseInt(parts[1]);
                            } else {
                                // Invalid format, use current month/year
                                const now = new Date();
                                month = now.getMonth() + 1;
                                year = now.getFullYear();
                            }
                        } else {
                            // No input, use current month/year
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                        }

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Calculate start and end dates
                            // Start at beginning of specified month
                            const startDate = new Date(year, month - 1, 1);
                            
                            // End at the end of the specified month (23:59:59 on the last day)
                            const endDate = new Date(year, month, 0, 23, 59, 59);
                            
                            // Check if a racing challenge already exists for this month
                            const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                            const existingChallenge = await ArcadeBoard.findOne({
                                boardType: 'racing',
                                monthKey
                            });

                            if (existingChallenge) {
                                return modalSubmission.editReply(`A racing challenge already exists for ${monthKey}.`);
                            }

                            // Generate a unique board ID specifically for racing
                            // This format ensures no overlap with regular arcade boards
                            const boardId = `racing-${monthKey}`;

                            // Get the full game title and console name
                            const gameFull = `${gameInfo.title} (${gameInfo.consoleName})`;

                            // Create new racing board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'racing',
                                leaderboardId,
                                gameId,
                                gameTitle: gameFull,
                                trackName,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate,
                                endDate,
                                monthKey
                            });

                            await newBoard.save();

                            // Get month name for response
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF9900') // Orange for racing
                                .setTitle(`Racing Challenge Created: ${monthName} ${year}`)
                                .setDescription(
                                    `**Game:** ${gameFull}\n` +
                                    `**Track:** ${trackName}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Challenge Period:** ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `The top 3 players at the end of the month will receive award points!`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_racing')
                                        .setLabel('Announce Racing Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_racing') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding racing challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the racing challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a racing challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddTiebreaker(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Tiebreaker')
            .setColor('#FF0000') // Red
            .setDescription('Use this form to create a tiebreaker leaderboard for the monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description\nâ€¢ End Date (YYYY-MM-DD format)'
                },
                {
                    name: 'Tiebreaker Rules',
                    value: 'Tiebreakers are used to resolve ties in the monthly challenge leaderboard. Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_tiebreaker_form')
                    .setLabel('Open Tiebreaker Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('âš”ï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_tiebreaker_form') {
                    // Create modal for tiebreaker
                    const modal = new ModalBuilder()
                        .setCustomId('add_tiebreaker_modal')
                        .setTitle('Add Tiebreaker');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this tiebreaker challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add end date input
                    const endDateInput = new TextInputBuilder()
                        .setCustomId('end_date')
                        .setLabel('End Date (YYYY-MM-DD format)')
                        .setPlaceholder('Example: 2025-05-31')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const endDateRow = new ActionRowBuilder().addComponents(endDateInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, descriptionRow, endDateRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const endDateStr = modalSubmission.fields.getTextInputValue('end_date');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        // Parse end date
                        const endDate = new Date(endDateStr);
                        if (isNaN(endDate.getTime())) {
                            return modalSubmission.editReply('Invalid end date format. Please use YYYY-MM-DD.');
                        }

                        // Set end time to 23:59:59
                        endDate.setHours(23, 59, 59);

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Check if an active tiebreaker already exists
                            const now = new Date();
                            const activeTiebreaker = await ArcadeBoard.findOne({
                                boardType: 'tiebreaker',
                                startDate: { $lte: now },
                                endDate: { $gte: now }
                            });

                            if (activeTiebreaker) {
                                return modalSubmission.editReply('An active tiebreaker already exists. Please end it before creating a new one.');
                            }

                            // Generate a unique board ID based on month and year
                            const monthYear = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}`;
                            const boardId = `tiebreaker-${monthYear}`;

                            // Create new tiebreaker board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'tiebreaker',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate: now,
                                endDate,
                                // Add monthKey for consistency with racing challenges
                                monthKey: monthYear
                            });

                            await newBoard.save();

                            // Get the month name
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[now.getMonth()];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF0000') // Red for tiebreaker
                                .setTitle(`âš”ï¸ Tiebreaker Created: ${monthName} ${now.getFullYear()}`)
                                .setDescription(
                                    `**Game:** ${gameInfo.title}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Tiebreaker Period:** ${now.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `This tiebreaker will be used to resolve ties in the ${monthName} monthly challenge leaderboard. ` +
                                    `Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_tiebreaker')
                                        .setLabel('Announce Tiebreaker')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_tiebreaker') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding tiebreaker:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the tiebreaker. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a tiebreaker.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAwardPoints(interaction) {
        // Create select board form
        const embed = new EmbedBuilder()
            .setTitle('Award Points')
            .setColor('#32CD32') // Lime green
            .setDescription('Select a board to award points for.')
            .addFields(
                {
                    name: 'Award Points',
                    value: 'You can award points for completed racing challenges or arcade boards. For racing challenges, points are awarded to the top 3 players. For arcade boards, points are awarded annually.'
                }
            );

        // Find all racing boards and tiebreakers
        const racingBoards = await ArcadeBoard.find({ 
            boardType: 'racing',
            pointsAwarded: { $ne: true } // Only show boards that haven't been awarded points yet
        }).sort({ startDate: -1 });

        // Create options for racing boards
        const boardOptions = racingBoards.map(board => {
            const monthYear = board.monthKey || 'Unknown Date';
            return {
                label: `Racing: ${board.gameTitle}${board.trackName ? ` - ${board.trackName}` : ''}`,
                description: `${monthYear}`,
                value: `racing-${board.boardId}`
            };
        });

        // Add option for annual arcade awards if any arcade boards exist
        const arcadeBoards = await ArcadeBoard.find({ boardType: 'arcade' });
        if (arcadeBoards.length > 0) {
            boardOptions.push({
                label: 'Annual Arcade Awards',
                description: 'Award points for all arcade boards for the current year',
                value: 'arcade-annual'
            });
        }

        // Create dropdown if we have options
        if (boardOptions.length === 0) {
            return interaction.editReply('No eligible boards found for awarding points. All racing challenges have already been awarded points, or no racing challenges exist.');
        }

        // Create the dropdown
        const row = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('select_board_for_award')
                    .setPlaceholder('Select a board to award points')
                    .addOptions(boardOptions)
            );

        // Send the selection menu
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the dropdown selection
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.StringSelect,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                await i.deferUpdate();
                
                const selectedValue = i.values[0];
                
                if (selectedValue.startsWith('racing-')) {
                    // Extract board ID
                    const boardId = selectedValue.substring(7);
                    await this.awardRacingPoints(i, boardId);
                } else if (selectedValue === 'arcade-annual') {
                    await this.awardArcadePoints(i);
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        StringSelectMenuBuilder.from(row.components[0])
                            .setDisabled(true)
                            .setPlaceholder('Selection timed out')
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This selection has expired. Please run the command again if you still need to award points.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling dropdown:', error);
                }
            }
        });
    },

    async awardRacingPoints(interaction, boardId) {
        try {
            // Find the racing board
            const racingBoard = await ArcadeBoard.findOne({ 
                boardId,
                boardType: 'racing'
            });

            if (!racingBoard) {
                return interaction.editReply(`Racing board with ID "${boardId}" not found.`);
            }

            // Check if points have already been awarded
            if (racingBoard.pointsAwarded) {
                return interaction.editReply(`Points have already been awarded for this racing challenge.`);
            }

            // Check if the racing challenge has ended
            const now = new Date();
            if (racingBoard.endDate > now) {
                return interaction.editReply(`This racing challenge hasn't ended yet. It ends on ${racingBoard.endDate.toLocaleDateString()}.`);
            }

, 'i') }
            };
            
            // If Discord user is provided, add to query
            if (discordUser) {
                query = {
                    $or: [
                        { raUsername: { $regex: new RegExp(`^${raUsername}import { 
    SlashCommandBuilder, 
    EmbedBuilder, 
    ActionRowBuilder, 
    StringSelectMenuBuilder,
    ButtonBuilder,
    ButtonStyle,
    ComponentType,
    ModalBuilder,
    TextInputBuilder,
    TextInputStyle,
    PermissionFlagsBits
} from 'discord.js';
import { User } from '../../models/User.js';
import { Challenge } from '../../models/Challenge.js';
import { ArcadeBoard } from '../../models/ArcadeBoard.js';
import { Poll } from '../../models/Poll.js';
import retroAPI from '../../services/retroAPI.js';
import { config } from '../../config/config.js';

// Constants
const MEMBER_ROLE_ID = '1316292690870014002';

export default {
    data: new SlashCommandBuilder()
        .setName('admin')
        .setDescription('Admin dashboard for managing all aspects of the community')
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild) // Require admin permissions
        // Challenge Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('challenge')
                .setDescription('Manage monthly and shadow challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('create')
                        .setDescription('Create or replace a monthly challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('shadow')
                        .setDescription('Add or edit a shadow challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('toggle')
                        .setDescription('Toggle shadow challenge visibility')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View current challenge details')
                )
        )
        
        // Arcade Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('arcade')
                .setDescription('Manage arcade boards and racing challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('add')
                        .setDescription('Add an arcade board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('racing')
                        .setDescription('Set up a racing challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('tiebreaker')
                        .setDescription('Create a tiebreaker board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Award points for a completed board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('announce')
                        .setDescription('Announce a board to the community')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View and manage existing boards')
                )
        )
        
        // User Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('user')
                .setDescription('Manage users, registrations, and awards')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('register')
                        .setDescription('Register a user')
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to register')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('unregister')
                        .setDescription('Unregister a user')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to unregister')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('purge')
                        .setDescription('Completely remove a user registration')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to purge')
                            .setRequired(true))
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to purge (optional)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Give a community award to a user')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('title')
                            .setDescription('The title of the award')
                            .setRequired(true))
                        .addIntegerOption(option =>
                            option.setName('points')
                            .setDescription('Number of points for this award')
                            .setRequired(true)
                            .setMinValue(1))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('awards')
                        .setDescription('View user awards')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('clear')
                        .setDescription('Clear nominations or awards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('reset')
                        .setDescription('Reset user achievements')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('RetroAchievements username')
                            .setRequired(true))
                )
        )
        
        // Voting Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('voting')
                .setDescription('Manage voting processes')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('start')
                        .setDescription('Start a voting poll')
                        .addChannelOption(option =>
                            option.setName('channel')
                            .setDescription('The channel to create the poll announcement in')
                            .setRequired(true))
                        .addChannelOption(option =>
                            option.setName('results_channel')
                            .setDescription('The channel to announce results in (defaults to same channel)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('cancel')
                        .setDescription('Cancel an active voting poll')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('status')
                        .setDescription('Check status of current voting')
                )
        )
        
        // System Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('system')
                .setDescription('System-level operations')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('update')
                        .setDescription('Force an update of all stats and leaderboards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('suggestions')
                        .setDescription('Manage community suggestions')
                )
        )
        
        // Info display subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('info')
                .setDescription('Display shareable information')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('arcade')
                        .setDescription('Display arcade board information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('challenges')
                        .setDescription('Display challenge information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('overview')
                        .setDescription('Display community overview')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('commands')
                        .setDescription('Display available commands')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('rules')
                        .setDescription('Display community rules')
                )
        ),

    async execute(interaction) {
        // Check if user has admin role
        if (!interaction.member.roles.cache.has(config.bot.roles.admin)) {
            return interaction.reply({
                content: 'You do not have permission to use this command.',
                ephemeral: true
            });
        }

        await interaction.deferReply({ ephemeral: true });

        try {
            // Extract subcommand group and subcommand
            const subcommandGroup = interaction.options.getSubcommandGroup();
            const subcommand = interaction.options.getSubcommand();
            
            // Route to the appropriate handler based on subcommand group and subcommand
            switch (subcommandGroup) {
                case 'challenge':
                    await this.handleChallengeCommand(interaction, subcommand);
                    break;
                case 'arcade':
                    await this.handleArcadeCommand(interaction, subcommand);
                    break;
                case 'user':
                    await this.handleUserCommand(interaction, subcommand);
                    break;
                case 'voting':
                    await this.handleVotingCommand(interaction, subcommand);
                    break;
                case 'system':
                    await this.handleSystemCommand(interaction, subcommand);
                    break;
                case 'info':
                    await this.handleInfoCommand(interaction, subcommand);
                    break;
                default:
                    await interaction.editReply('Invalid subcommand group.');
            }
        } catch (error) {
            console.error('Error executing admin command:', error);
            await interaction.editReply('An error occurred while processing your request.');
        }
    },

    // CHALLENGE MANAGEMENT HANDLERS
    async handleChallengeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'create':
                await this.handleCreateChallenge(interaction);
                break;
            case 'shadow':
                await this.handleShadowChallenge(interaction);
                break;
            case 'toggle':
                await this.handleToggleShadow(interaction);
                break;
            case 'view':
                await this.handleViewChallenge(interaction);
                break;
            default:
                await interaction.editReply('Invalid challenge subcommand.');
        }
    },

    async handleCreateChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Create Monthly Challenge')
            .setColor('#32CD32')
            .setDescription('Use this form to create or replace a monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'How to Find Achievement IDs',
                    value: 'Go to the game page on RetroAchievements, hover over an achievement, and note the ID number in the URL.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('create_challenge_form')
                    .setLabel('Open Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ®')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'create_challenge_form') {
                    // Create modal for challenge creation
                    const modal = new ModalBuilder()
                        .setCustomId('create_challenge_modal')
                        .setTitle('Create Monthly Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add year input
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Create date for the first of the specified month
                            const challengeDate = new Date(year, month - 1, 1);

                            // Check if a challenge already exists for this month
                            const existingChallenge = await Challenge.findOneAndDelete({
                                date: {
                                    $gte: challengeDate,
                                    $lt: new Date(year, month, 1)
                                }
                            });

                            // Create new challenge
                            const challenge = new Challenge({
                                date: challengeDate,
                                monthly_challange_gameid: gameId,
                                monthly_challange_progression_achievements: progressionAchievements,
                                monthly_challange_win_achievements: winAchievements,
                                monthly_challange_game_total: totalAchievements,
                                shadow_challange_revealed: false // Keep shadow challenge hidden by default
                            });

                            await challenge.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Monthly Challenge Created')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (existingChallenge) {
                                resultEmbed.setDescription(`Monthly challenge replaced for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: existingChallenge.monthly_challange_gameid.toString() },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Monthly challenge created for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('add_shadow')
                                        .setLabel('Add Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ‘¥'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'add_shadow') {
                                        await this.handleShadowChallenge(resultI, { month, year });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error creating challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while creating the challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to create a challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleShadowChallenge(interaction, prefilledData = null) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Shadow Challenge')
            .setColor('#9932CC') // Dark purple
            .setDescription('Use this form to add or edit a shadow challenge for a specific month.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'Shadow Challenge Rules',
                    value: 'Shadow challenges are hidden mysteries that players can discover by guessing or playing the challenge games. They automatically reveal for past months.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('shadow_challenge_form')
                    .setLabel('Open Shadow Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸ‘¥')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'shadow_challenge_form') {
                    // Create modal for shadow challenge
                    const modal = new ModalBuilder()
                        .setCustomId('shadow_challenge_modal')
                        .setTitle('Add Shadow Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input with prefilled data if available
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.month) {
                        monthInput.setValue(prefilledData.month.toString());
                    } else {
                        // Default to current month
                        const now = new Date();
                        monthInput.setValue((now.getMonth() + 1).toString());
                    }

                    // Add year input with prefilled data if available
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.year) {
                        yearInput.setValue(prefilledData.year.toString());
                    } else {
                        // Default to current year
                        const now = new Date();
                        yearInput.setValue(now.getFullYear().toString());
                    }

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get date range for the specified month
                            const monthStart = new Date(year, month - 1, 1);
                            const nextMonthStart = new Date(year, month, 1);

                            // Find the target challenge
                            const targetChallenge = await Challenge.findOne({
                                date: {
                                    $gte: monthStart,
                                    $lt: nextMonthStart
                                }
                            });

                            if (!targetChallenge) {
                                return modalSubmission.editReply(`No challenge exists for ${month}/${year}. Create a monthly challenge first using /admin challenge create.`);
                            }

                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Check if there's an existing shadow game to be replaced
                            let replacedShadowGame = null;
                            if (targetChallenge.shadow_challange_gameid) {
                                try {
                                    const oldGameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
                                    replacedShadowGame = oldGameInfo.title;
                                } catch (error) {
                                    console.error('Error fetching old shadow game info:', error);
                                    replacedShadowGame = targetChallenge.shadow_challange_gameid;
                                }
                            }

                            // Update the challenge with shadow game information
                            targetChallenge.shadow_challange_gameid = gameId;
                            targetChallenge.shadow_challange_progression_achievements = progressionAchievements;
                            targetChallenge.shadow_challange_win_achievements = winAchievements;
                            targetChallenge.shadow_challange_game_total = totalAchievements;
                            
                            // Automatically reveal shadow games for past months
                            const now = new Date();
                            if (month < now.getMonth() + 1 || year < now.getFullYear()) {
                                targetChallenge.shadow_challange_revealed = true;
                            } else if (!targetChallenge.shadow_challange_revealed) {
                                // For current or future months, keep shadow games hidden by default
                                targetChallenge.shadow_challange_revealed = false;
                            }

                            await targetChallenge.save();

                            // Get month name for display
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Determine if it was auto-revealed
                            const autoRevealed = (month < now.getMonth() + 1 || year < now.getFullYear());
                            
                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#9932CC') // Dark purple for shadow challenges
                                .setTitle('Shadow Challenge Added')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (replacedShadowGame) {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} replaced`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: replacedShadowGame },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} created`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() },
                                { name: 'Visibility', value: targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden' + (autoRevealed ? ' (Auto-revealed as past challenge)' : '') }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('toggle_shadow')
                                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'toggle_shadow') {
                                        await this.handleToggleShadow(resultI, { month, year, force: true });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding shadow challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the shadow challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a shadow challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleToggleShadow(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            let force = options?.force || false;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                const now = new Date();
                month = now.getMonth() + 1; // 1-indexed month
                year = now.getFullYear();
            }
            
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the target challenge
            const targetChallenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!targetChallenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            if (!targetChallenge.shadow_challange_gameid) {
                return interaction.editReply(`No shadow challenge has been set for ${month}/${year}.`);
            }

            // Toggle the visibility
            targetChallenge.shadow_challange_revealed = !targetChallenge.shadow_challange_revealed;
            await targetChallenge.save();

            // Get game info for the response
            const gameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
            
            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Create response embed
            const resultEmbed = new EmbedBuilder()
                .setColor(targetChallenge.shadow_challange_revealed ? '#00FF00' : '#FF0000') // Green for revealed, red for hidden
                .setTitle(`Shadow Challenge ${targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden'}`)
                .setDescription(`The shadow challenge for ${monthName} ${year} is now ${targetChallenge.shadow_challange_revealed ? 'REVEALED' : 'HIDDEN'}.`)
                .setTimestamp();

            if (targetChallenge.shadow_challange_revealed) {
                resultEmbed.addFields(
                    { name: 'Game', value: gameInfo.title },
                    { name: 'Required Progression Achievements', value: targetChallenge.shadow_challange_progression_achievements.length.toString() },
                    { name: 'Required Win Achievements', value: targetChallenge.shadow_challange_win_achievements.length > 0 ? targetChallenge.shadow_challange_win_achievements.length.toString() : 'None' }
                );
                
                if (gameInfo.imageIcon) {
                    resultEmbed.setThumbnail(`https://retroachievements.org${gameInfo.imageIcon}`);
                }
            }

            // Add action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow_again')
                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                    new ButtonBuilder()
                        .setCustomId('view_challenge')
                        .setLabel('View Challenge Details')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ”')
                );

            // If we're force-updating from another command, use editReply
            // Otherwise, use standard reply
            if (force) {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            } else {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            }

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'toggle_shadow_again') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    } else if (i.customId === 'view_challenge') {
                        await this.handleViewChallenge(i, { month, year });
                    }
                }
            });

        } catch (error) {
            console.error('Error toggling shadow challenge visibility:', error);
            await interaction.editReply('An error occurred while toggling the shadow challenge visibility. Please try again.');
        }
    },

    async handleViewChallenge(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                // Open a form to select month/year
                const embed = new EmbedBuilder()
                    .setTitle('View Challenge Details')
                    .setColor('#3498DB')
                    .setDescription('Please select which challenge you want to view.')
                    .addFields(
                        {
                            name: 'Options',
                            value: 'You can view the current month\'s challenge or select a specific month.'
                        }
                    );

                // Create buttons
                const row = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('view_current_challenge')
                            .setLabel('Current Month')
                            .setStyle(ButtonStyle.Primary)
                            .setEmoji('ðŸ“…'),
                        new ButtonBuilder()
                            .setCustomId('select_month_challenge')
                            .setLabel('Select Month')
                            .setStyle(ButtonStyle.Secondary)
                            .setEmoji('ðŸ”')
                    );

                await interaction.editReply({
                    embeds: [embed],
                    components: [row]
                });

                // Set up collector for the buttons
                const message = await interaction.fetchReply();
                const buttonCollector = message.createMessageComponentCollector({
                    componentType: ComponentType.Button,
                    time: 300000 // 5 minutes timeout
                });

                buttonCollector.on('collect', async i => {
                    if (i.user.id === interaction.user.id) {
                        await i.deferUpdate();

                        if (i.customId === 'view_current_challenge') {
                            // Use current month
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                            
                            // Continue with viewing the challenge
                            await this.displayChallengeDetails(i, month, year);
                            
                            // Stop the collector
                            buttonCollector.stop();
                        } else if (i.customId === 'select_month_challenge') {
                            // Show modal to select month/year
                            const modal = new ModalBuilder()
                                .setCustomId('select_challenge_month_modal')
                                .setTitle('Select Challenge Month');

                            // Add month input
                            const monthInput = new TextInputBuilder()
                                .setCustomId('month')
                                .setLabel('Month (1-12)')
                                .setPlaceholder('Example: 5 (for May)')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add year input
                            const yearInput = new TextInputBuilder()
                                .setCustomId('year')
                                .setLabel('Year')
                                .setPlaceholder('Example: 2025')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add inputs to modal
                            const monthRow = new ActionRowBuilder().addComponents(monthInput);
                            const yearRow = new ActionRowBuilder().addComponents(yearInput);

                            modal.addComponents(monthRow, yearRow);

                            // Show the modal
                            await i.showModal(modal);

                            try {
                                // Wait for modal submission
                                const modalSubmission = await i.awaitModalSubmit({
                                    time: 300000 // 5 minutes to fill out the form
                                });

                                await modalSubmission.deferUpdate();

                                // Extract values from the modal
                                month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                                year = parseInt(modalSubmission.fields.getTextInputValue('year'));

                                // Validate inputs
                                if (isNaN(month) || month < 1 || month > 12) {
                                    return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                                }

                                if (isNaN(year) || year < 2000 || year > 2100) {
                                    return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                                }

                                // Continue with viewing the challenge
                                await this.displayChallengeDetails(modalSubmission, month, year);
                                
                                // Stop the collector
                                buttonCollector.stop();

                            } catch (modalError) {
                                console.error('Error handling modal submission:', modalError);
                                // Modal timed out or was cancelled
                            }
                        }
                    }
                });

                // Let the function end here and let the collector handle the rest
                return;
            }

            // If we have month/year, display the challenge
            await this.displayChallengeDetails(interaction, month, year);

        } catch (error) {
            console.error('Error viewing challenge:', error);
            await interaction.editReply('An error occurred while viewing the challenge. Please try again.');
        }
    },

    async displayChallengeDetails(interaction, month, year) {
        try {
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the challenge
            const challenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!challenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Get game info for monthly challenge
            let monthlyGameInfo = null;
            if (challenge.monthly_challange_gameid) {
                monthlyGameInfo = await retroAPI.getGameInfo(challenge.monthly_challange_gameid);
            }

            // Get game info for shadow challenge if revealed
            let shadowGameInfo = null;
            if (challenge.shadow_challange_gameid && challenge.shadow_challange_revealed) {
                shadowGameInfo = await retroAPI.getGameInfo(challenge.shadow_challange_gameid);
            }

            // Create main embed
            const embed = new EmbedBuilder()
                .setTitle(`Challenge Details: ${monthName} ${year}`)
                .setColor('#3498DB')
                .setDescription(`Here are the details for the ${monthName} ${year} challenges:`)
                .setTimestamp();

            // Add monthly challenge info
            if (monthlyGameInfo) {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: `**Game:** ${monthlyGameInfo.title}\n` +
                          `**Required Progression Achievements:** ${challenge.monthly_challange_progression_achievements.length}\n` +
                          `**Required Win Achievements:** ${challenge.monthly_challange_win_achievements.length}\n` +
                          `**Total Achievements:** ${challenge.monthly_challange_game_total}\n` +
                          `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.monthly_challange_gameid})`
                });

                if (monthlyGameInfo.imageIcon) {
                    embed.setThumbnail(`https://retroachievements.org${monthlyGameInfo.imageIcon}`);
                }
            } else {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: 'No monthly challenge set.'
                });
            }

            // Add shadow challenge info
            if (challenge.shadow_challange_gameid) {
                if (challenge.shadow_challange_revealed && shadowGameInfo) {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (REVEALED)',
                        value: `**Game:** ${shadowGameInfo.title}\n` +
                              `**Required Progression Achievements:** ${challenge.shadow_challange_progression_achievements.length}\n` +
                              `**Required Win Achievements:** ${challenge.shadow_challange_win_achievements.length}\n` +
                              `**Total Achievements:** ${challenge.shadow_challange_game_total}\n` +
                              `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.shadow_challange_gameid})`
                    });
                } else {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (HIDDEN)',
                        value: 'Shadow challenge exists but is currently hidden.\n' +
                              `Use \`/admin challenge toggle\` to reveal it.`
                    });
                }
            } else {
                embed.addFields({
                    name: 'ðŸ‘¥ Shadow Challenge',
                    value: 'No shadow challenge set.\n' +
                          `Use \`/admin challenge shadow\` to add one.`
                });
            }

            // Create action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('edit_monthly')
                        .setLabel('Edit Monthly Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('ðŸ†'),
                    new ButtonBuilder()
                        .setCustomId('edit_shadow')
                        .setLabel(challenge.shadow_challange_gameid ? 'Edit Shadow Challenge' : 'Add Shadow Challenge')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ‘¥')
                );

            // Add toggle button if shadow challenge exists
            if (challenge.shadow_challange_gameid) {
                actionRow.addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow')
                        .setLabel(challenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji(challenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸')
                );
            }

            await interaction.editReply({
                embeds: [embed],
                components: [actionRow]
            });

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'edit_monthly') {
                        await this.handleCreateChallenge(i);
                    } else if (i.customId === 'edit_shadow') {
                        await this.handleShadowChallenge(i, { month, year });
                    } else if (i.customId === 'toggle_shadow') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    }
                }
            });

        } catch (error) {
            console.error('Error displaying challenge details:', error);
            await interaction.editReply('An error occurred while retrieving challenge details. Please try again.');
        }
    },

    // ARCADE MANAGEMENT HANDLERS
    async handleArcadeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'add':
                await this.handleAddArcadeBoard(interaction);
                break;
            case 'racing':
                await this.handleAddRacingChallenge(interaction);
                break;
            case 'tiebreaker':
                await this.handleAddTiebreaker(interaction);
                break;
            case 'award':
                await this.handleAwardPoints(interaction);
                break;
            case 'announce':
                await this.handleAnnounceBoard(interaction);
                break;
            case 'view':
                await this.handleViewBoards(interaction);
                break;
            default:
                await interaction.editReply('Invalid arcade subcommand.');
        }
    },

    async handleAddArcadeBoard(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Arcade Board')
            .setColor('#9B59B6') // Purple
            .setDescription('Use this form to add a new arcade board to the community.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Board ID (unique identifier)\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description'
                },
                {
                    name: 'How to Find IDs',
                    value: '**Game ID**: The number at the end of the game URL on RetroAchievements\n**Leaderboard ID**: The number at the end of the leaderboard URL'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_arcade_form')
                    .setLabel('Open Arcade Board Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ¯')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_arcade_form') {
                    // Create modal for arcade board
                    const modal = new ModalBuilder()
                        .setCustomId('add_arcade_modal')
                        .setTitle('Add Arcade Board');

                    // Add board ID input
                    const boardIdInput = new TextInputBuilder()
                        .setCustomId('board_id')
                        .setLabel('Board ID (unique identifier)')
                        .setPlaceholder('Example: sonic3-special-stages')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this arcade board challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add inputs to modal
                    const boardIdRow = new ActionRowBuilder().addComponents(boardIdInput);
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);

                    modal.addComponents(boardIdRow, gameIdRow, leaderboardIdRow, descriptionRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const boardId = modalSubmission.fields.getTextInputValue('board_id');
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        try {
                            // Check if board ID already exists
                            const existingBoard = await ArcadeBoard.findOne({ boardId });
                            if (existingBoard) {
                                return modalSubmission.editReply(`A board with ID "${boardId}" already exists.`);
                            }

                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Create new board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'arcade',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description
                            });

                            await newBoard.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Arcade Board Added')
                                .setDescription(`Successfully added "${gameInfo.title}" arcade board!`)
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .addFields(
                                    { name: 'Board ID', value: boardId },
                                    { name: 'Game', value: gameInfo.title },
                                    { name: 'Console', value: gameInfo.consoleName || 'Unknown' },
                                    { name: 'Description', value: description }
                                )
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_board')
                                        .setLabel('Announce Board')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_board') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding arcade board:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the arcade board. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add an arcade board.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddRacingChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Racing Challenge')
            .setColor('#FF9900') // Orange
            .setDescription('Use this form to set up a monthly racing challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Track Name\nâ€¢ Description\nâ€¢ Month and Year (optional, defaults to current month)'
                },
                {
                    name: 'Racing Challenge Rules',
                    value: 'Racing challenges are monthly competitions where players compete on time-based leaderboards. The top 3 players will receive community points.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_racing_form')
                    .setLabel('Open Racing Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_racing_form') {
                    // Create modal for racing challenge
                    const modal = new ModalBuilder()
                        .setCustomId('add_racing_modal')
                        .setTitle('Add Racing Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add track name input
                    const trackNameInput = new TextInputBuilder()
                        .setCustomId('track_name')
                        .setLabel('Track Name')
                        .setPlaceholder('Example: Rainbow Road')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this racing challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add month/year input
                    const monthYearInput = new TextInputBuilder()
                        .setCustomId('month_year')
                        .setLabel('Month and Year (optional, MM/YYYY format)')
                        .setPlaceholder('Example: 05/2025 (defaults to current month)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const trackNameRow = new ActionRowBuilder().addComponents(trackNameInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthYearInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, trackNameRow, descriptionRow, monthYearRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const trackName = modalSubmission.fields.getTextInputValue('track_name');
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const monthYearInput = modalSubmission.fields.getTextInputValue('month_year');

                        // Parse month and year
                        let month, year;
                        if (monthYearInput && monthYearInput.trim()) {
                            const parts = monthYearInput.split('/');
                            if (parts.length === 2) {
                                month = parseInt(parts[0]);
                                year = parseInt(parts[1]);
                            } else {
                                // Invalid format, use current month/year
                                const now = new Date();
                                month = now.getMonth() + 1;
                                year = now.getFullYear();
                            }
                        } else {
                            // No input, use current month/year
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                        }

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Calculate start and end dates
                            // Start at beginning of specified month
                            const startDate = new Date(year, month - 1, 1);
                            
                            // End at the end of the specified month (23:59:59 on the last day)
                            const endDate = new Date(year, month, 0, 23, 59, 59);
                            
                            // Check if a racing challenge already exists for this month
                            const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                            const existingChallenge = await ArcadeBoard.findOne({
                                boardType: 'racing',
                                monthKey
                            });

                            if (existingChallenge) {
                                return modalSubmission.editReply(`A racing challenge already exists for ${monthKey}.`);
                            }

                            // Generate a unique board ID specifically for racing
                            // This format ensures no overlap with regular arcade boards
                            const boardId = `racing-${monthKey}`;

                            // Get the full game title and console name
                            const gameFull = `${gameInfo.title} (${gameInfo.consoleName})`;

                            // Create new racing board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'racing',
                                leaderboardId,
                                gameId,
                                gameTitle: gameFull,
                                trackName,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate,
                                endDate,
                                monthKey
                            });

                            await newBoard.save();

                            // Get month name for response
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF9900') // Orange for racing
                                .setTitle(`Racing Challenge Created: ${monthName} ${year}`)
                                .setDescription(
                                    `**Game:** ${gameFull}\n` +
                                    `**Track:** ${trackName}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Challenge Period:** ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `The top 3 players at the end of the month will receive award points!`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_racing')
                                        .setLabel('Announce Racing Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_racing') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding racing challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the racing challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a racing challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddTiebreaker(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Tiebreaker')
            .setColor('#FF0000') // Red
            .setDescription('Use this form to create a tiebreaker leaderboard for the monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description\nâ€¢ End Date (YYYY-MM-DD format)'
                },
                {
                    name: 'Tiebreaker Rules',
                    value: 'Tiebreakers are used to resolve ties in the monthly challenge leaderboard. Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_tiebreaker_form')
                    .setLabel('Open Tiebreaker Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('âš”ï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_tiebreaker_form') {
                    // Create modal for tiebreaker
                    const modal = new ModalBuilder()
                        .setCustomId('add_tiebreaker_modal')
                        .setTitle('Add Tiebreaker');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this tiebreaker challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add end date input
                    const endDateInput = new TextInputBuilder()
                        .setCustomId('end_date')
                        .setLabel('End Date (YYYY-MM-DD format)')
                        .setPlaceholder('Example: 2025-05-31')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const endDateRow = new ActionRowBuilder().addComponents(endDateInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, descriptionRow, endDateRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const endDateStr = modalSubmission.fields.getTextInputValue('end_date');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        // Parse end date
                        const endDate = new Date(endDateStr);
                        if (isNaN(endDate.getTime())) {
                            return modalSubmission.editReply('Invalid end date format. Please use YYYY-MM-DD.');
                        }

                        // Set end time to 23:59:59
                        endDate.setHours(23, 59, 59);

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Check if an active tiebreaker already exists
                            const now = new Date();
                            const activeTiebreaker = await ArcadeBoard.findOne({
                                boardType: 'tiebreaker',
                                startDate: { $lte: now },
                                endDate: { $gte: now }
                            });

                            if (activeTiebreaker) {
                                return modalSubmission.editReply('An active tiebreaker already exists. Please end it before creating a new one.');
                            }

                            // Generate a unique board ID based on month and year
                            const monthYear = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}`;
                            const boardId = `tiebreaker-${monthYear}`;

                            // Create new tiebreaker board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'tiebreaker',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate: now,
                                endDate,
                                // Add monthKey for consistency with racing challenges
                                monthKey: monthYear
                            });

                            await newBoard.save();

                            // Get the month name
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[now.getMonth()];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF0000') // Red for tiebreaker
                                .setTitle(`âš”ï¸ Tiebreaker Created: ${monthName} ${now.getFullYear()}`)
                                .setDescription(
                                    `**Game:** ${gameInfo.title}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Tiebreaker Period:** ${now.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `This tiebreaker will be used to resolve ties in the ${monthName} monthly challenge leaderboard. ` +
                                    `Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_tiebreaker')
                                        .setLabel('Announce Tiebreaker')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_tiebreaker') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding tiebreaker:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the tiebreaker. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a tiebreaker.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAwardPoints(interaction) {
        // Create select board form
        const embed = new EmbedBuilder()
            .setTitle('Award Points')
            .setColor('#32CD32') // Lime green
            .setDescription('Select a board to award points for.')
            .addFields(
                {
                    name: 'Award Points',
                    value: 'You can award points for completed racing challenges or arcade boards. For racing challenges, points are awarded to the top 3 players. For arcade boards, points are awarded annually.'
                }
            );

        // Find all racing boards and tiebreakers
        const racingBoards = await ArcadeBoard.find({ 
            boardType: 'racing',
            pointsAwarded: { $ne: true } // Only show boards that haven't been awarded points yet
        }).sort({ startDate: -1 });

        // Create options for racing boards
        const boardOptions = racingBoards.map(board => {
            const monthYear = board.monthKey || 'Unknown Date';
            return {
                label: `Racing: ${board.gameTitle}${board.trackName ? ` - ${board.trackName}` : ''}`,
                description: `${monthYear}`,
                value: `racing-${board.boardId}`
            };
        });

        // Add option for annual arcade awards if any arcade boards exist
        const arcadeBoards = await ArcadeBoard.find({ boardType: 'arcade' });
        if (arcadeBoards.length > 0) {
            boardOptions.push({
                label: 'Annual Arcade Awards',
                description: 'Award points for all arcade boards for the current year',
                value: 'arcade-annual'
            });
        }

        // Create dropdown if we have options
        if (boardOptions.length === 0) {
            return interaction.editReply('No eligible boards found for awarding points. All racing challenges have already been awarded points, or no racing challenges exist.');
        }

        // Create the dropdown
        const row = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('select_board_for_award')
                    .setPlaceholder('Select a board to award points')
                    .addOptions(boardOptions)
            );

        // Send the selection menu
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the dropdown selection
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.StringSelect,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                await i.deferUpdate();
                
                const selectedValue = i.values[0];
                
                if (selectedValue.startsWith('racing-')) {
                    // Extract board ID
                    const boardId = selectedValue.substring(7);
                    await this.awardRacingPoints(i, boardId);
                } else if (selectedValue === 'arcade-annual') {
                    await this.awardArcadePoints(i);
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        StringSelectMenuBuilder.from(row.components[0])
                            .setDisabled(true)
                            .setPlaceholder('Selection timed out')
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This selection has expired. Please run the command again if you still need to award points.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling dropdown:', error);
                }
            }
        });
    },

    async awardRacingPoints(interaction, boardId) {
        try {
            // Find the racing board
            const racingBoard = await ArcadeBoard.findOne({ 
                boardId,
                boardType: 'racing'
            });

            if (!racingBoard) {
                return interaction.editReply(`Racing board with ID "${boardId}" not found.`);
            }

            // Check if points have already been awarded
            if (racingBoard.pointsAwarded) {
                return interaction.editReply(`Points have already been awarded for this racing challenge.`);
            }

            // Check if the racing challenge has ended
            const now = new Date();
            if (racingBoard.endDate > now) {
                return interaction.editReply(`This racing challenge hasn't ended yet. It ends on ${racingBoard.endDate.toLocaleDateString()}.`);
            }

, 'i') } },
                        { discordId: discordUser.id }
                    ]
                };
            }

            // Find all matching users
            const users = await User.find(query);
            
            if (users.length === 0) {
                return interaction.editReply('No users found matching the provided criteria.');
            }
            
            // Create confirmation embed
            const confirmEmbed = new EmbedBuilder()
                .setTitle('Confirm Purge Registration')
                .setColor('#FF0000') // Red for danger
                .setDescription(`Are you sure you want to purge ${users.length} user registration${users.length !== 1 ? 's' : ''}? This action cannot be undone.`)
                .setTimestamp();
                
            // Add users to purge
            let usersToDelete = '';
            for (const user of users) {
                let discordInfo = 'Unknown Discord user';
                try {
                    if (user.discordId) {
                        const discordMember = await interaction.client.users.fetch(user.discordId);
                        if (discordMember) {
                            discordInfo = discordMember.tag;
                        }
                    }
                } catch (fetchError) {
                    console.error('Error fetching Discord user:', fetchError);
                }
                
                usersToDelete += `- **${user.raUsername}** (Discord: ${discordInfo})\n`;
            }
            
            confirmEmbed.addFields({
                name: 'Users to Purge',
                value: usersToDelete
            });
                
            // Create confirmation buttons
            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('confirm_purge')
                        .setLabel('Purge Registration')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('âœ…'),
                    new ButtonBuilder()
                        .setCustomId('cancel_purge')
                        .setLabel('Cancel')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('âŒ')
                );
                
            await interaction.editReply({
                embeds: [confirmEmbed],
                components: [row]
            });
            
            // Set up collector for the confirmation buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 60000 // 1 minute timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'confirm_purge') {
                        // Keep track of purged users for reporting
                        const purgedUsers = [];
                        
                        // Process each matching user
                        for (const user of users) {
                            // Try to remove member role if discord user is in the server
                            try {
                                if (user.discordId) {
                                    const member = interaction.guild.members.cache.get(user.discordId);
                                    if (member) {
                                        await member.roles.remove(MEMBER_ROLE_ID);
                                    }
                                }
                            } catch (roleError) {
                                console.error('Error removing role:', roleError);
                                // Continue with deletion even if role removal fails
                            }
                            
                            // Track user info for response
                            let discordInfo = 'Unknown Discord user';
                            try {
                                if (user.discordId) {
                                    const discordMember = await interaction.client.users.fetch(user.discordId);
                                    if (discordMember) {
                                        discordInfo = discordMember.tag;
                                    }
                                }
                            } catch (fetchError) {
                                console.error('Error fetching Discord user:', fetchError);
                            }
                            
                            purgedUsers.push({
                                raUsername: user.raUsername,
                                discordInfo
                            });
                            
                            // Delete the user document
                            await User.deleteOne({ _id: user._id });
                        }
                        
                        // Show success message
                        const successEmbed = new EmbedBuilder()
                            .setColor('#00FF00') // Green for success
                            .setTitle('Registrations Purged')
                            .setDescription(`Successfully purged ${purgedUsers.length} user registration${purgedUsers.length !== 1 ? 's' : ''}.`)
                            .setTimestamp();
                            
                        // Generate details for the purged users
                        let purgedDetails = '';
                        purgedUsers.forEach((user, index) => {
                            purgedDetails += `${index + 1}. **${user.raUsername}** (Discord: ${user.discordInfo})\n`;
                        });
                        
                        successEmbed.addFields({
                            name: 'Purged Users',
                            value: purgedDetails
                        });
                        
                        successEmbed.addFields({
                            name: 'Next Steps',
                            value: 'These users can now be re-registered.'
                        });
                            
                        await i.editReply({
                            embeds: [successEmbed],
                            components: []
                        });
                    } else if (i.customId === 'cancel_purge') {
                        // Show cancellation message
                        await i.editReply({
                            content: 'Purge operation cancelled.',
                            embeds: [],
                            components: []
                        });
                    }
                }
            });
        } catch (error) {
            console.error('Error purging registration:', error);
            return interaction.editReply('An error occurred while purging the user registration. Please try again.');
        }
    },

    async handleGiveAward(interaction) {
        try {
            const raUsername = interaction.options.getString('username');
            const title = interaction.options.getString('title');
            const points = interaction.options.getInteger('points');

            // Find the user
            const user = await User.findOne({
                raUsername: { $regex: new RegExp(`^${raUsername}import { 
    SlashCommandBuilder, 
    EmbedBuilder, 
    ActionRowBuilder, 
    StringSelectMenuBuilder,
    ButtonBuilder,
    ButtonStyle,
    ComponentType,
    ModalBuilder,
    TextInputBuilder,
    TextInputStyle,
    PermissionFlagsBits
} from 'discord.js';
import { User } from '../../models/User.js';
import { Challenge } from '../../models/Challenge.js';
import { ArcadeBoard } from '../../models/ArcadeBoard.js';
import { Poll } from '../../models/Poll.js';
import retroAPI from '../../services/retroAPI.js';
import { config } from '../../config/config.js';

// Constants
const MEMBER_ROLE_ID = '1316292690870014002';

export default {
    data: new SlashCommandBuilder()
        .setName('admin')
        .setDescription('Admin dashboard for managing all aspects of the community')
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild) // Require admin permissions
        // Challenge Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('challenge')
                .setDescription('Manage monthly and shadow challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('create')
                        .setDescription('Create or replace a monthly challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('shadow')
                        .setDescription('Add or edit a shadow challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('toggle')
                        .setDescription('Toggle shadow challenge visibility')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View current challenge details')
                )
        )
        
        // Arcade Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('arcade')
                .setDescription('Manage arcade boards and racing challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('add')
                        .setDescription('Add an arcade board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('racing')
                        .setDescription('Set up a racing challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('tiebreaker')
                        .setDescription('Create a tiebreaker board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Award points for a completed board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('announce')
                        .setDescription('Announce a board to the community')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View and manage existing boards')
                )
        )
        
        // User Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('user')
                .setDescription('Manage users, registrations, and awards')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('register')
                        .setDescription('Register a user')
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to register')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('unregister')
                        .setDescription('Unregister a user')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to unregister')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('purge')
                        .setDescription('Completely remove a user registration')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to purge')
                            .setRequired(true))
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to purge (optional)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Give a community award to a user')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('title')
                            .setDescription('The title of the award')
                            .setRequired(true))
                        .addIntegerOption(option =>
                            option.setName('points')
                            .setDescription('Number of points for this award')
                            .setRequired(true)
                            .setMinValue(1))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('awards')
                        .setDescription('View user awards')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('clear')
                        .setDescription('Clear nominations or awards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('reset')
                        .setDescription('Reset user achievements')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('RetroAchievements username')
                            .setRequired(true))
                )
        )
        
        // Voting Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('voting')
                .setDescription('Manage voting processes')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('start')
                        .setDescription('Start a voting poll')
                        .addChannelOption(option =>
                            option.setName('channel')
                            .setDescription('The channel to create the poll announcement in')
                            .setRequired(true))
                        .addChannelOption(option =>
                            option.setName('results_channel')
                            .setDescription('The channel to announce results in (defaults to same channel)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('cancel')
                        .setDescription('Cancel an active voting poll')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('status')
                        .setDescription('Check status of current voting')
                )
        )
        
        // System Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('system')
                .setDescription('System-level operations')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('update')
                        .setDescription('Force an update of all stats and leaderboards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('suggestions')
                        .setDescription('Manage community suggestions')
                )
        )
        
        // Info display subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('info')
                .setDescription('Display shareable information')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('arcade')
                        .setDescription('Display arcade board information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('challenges')
                        .setDescription('Display challenge information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('overview')
                        .setDescription('Display community overview')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('commands')
                        .setDescription('Display available commands')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('rules')
                        .setDescription('Display community rules')
                )
        ),

    async execute(interaction) {
        // Check if user has admin role
        if (!interaction.member.roles.cache.has(config.bot.roles.admin)) {
            return interaction.reply({
                content: 'You do not have permission to use this command.',
                ephemeral: true
            });
        }

        await interaction.deferReply({ ephemeral: true });

        try {
            // Extract subcommand group and subcommand
            const subcommandGroup = interaction.options.getSubcommandGroup();
            const subcommand = interaction.options.getSubcommand();
            
            // Route to the appropriate handler based on subcommand group and subcommand
            switch (subcommandGroup) {
                case 'challenge':
                    await this.handleChallengeCommand(interaction, subcommand);
                    break;
                case 'arcade':
                    await this.handleArcadeCommand(interaction, subcommand);
                    break;
                case 'user':
                    await this.handleUserCommand(interaction, subcommand);
                    break;
                case 'voting':
                    await this.handleVotingCommand(interaction, subcommand);
                    break;
                case 'system':
                    await this.handleSystemCommand(interaction, subcommand);
                    break;
                case 'info':
                    await this.handleInfoCommand(interaction, subcommand);
                    break;
                default:
                    await interaction.editReply('Invalid subcommand group.');
            }
        } catch (error) {
            console.error('Error executing admin command:', error);
            await interaction.editReply('An error occurred while processing your request.');
        }
    },

    // CHALLENGE MANAGEMENT HANDLERS
    async handleChallengeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'create':
                await this.handleCreateChallenge(interaction);
                break;
            case 'shadow':
                await this.handleShadowChallenge(interaction);
                break;
            case 'toggle':
                await this.handleToggleShadow(interaction);
                break;
            case 'view':
                await this.handleViewChallenge(interaction);
                break;
            default:
                await interaction.editReply('Invalid challenge subcommand.');
        }
    },

    async handleCreateChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Create Monthly Challenge')
            .setColor('#32CD32')
            .setDescription('Use this form to create or replace a monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'How to Find Achievement IDs',
                    value: 'Go to the game page on RetroAchievements, hover over an achievement, and note the ID number in the URL.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('create_challenge_form')
                    .setLabel('Open Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ®')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'create_challenge_form') {
                    // Create modal for challenge creation
                    const modal = new ModalBuilder()
                        .setCustomId('create_challenge_modal')
                        .setTitle('Create Monthly Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add year input
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Create date for the first of the specified month
                            const challengeDate = new Date(year, month - 1, 1);

                            // Check if a challenge already exists for this month
                            const existingChallenge = await Challenge.findOneAndDelete({
                                date: {
                                    $gte: challengeDate,
                                    $lt: new Date(year, month, 1)
                                }
                            });

                            // Create new challenge
                            const challenge = new Challenge({
                                date: challengeDate,
                                monthly_challange_gameid: gameId,
                                monthly_challange_progression_achievements: progressionAchievements,
                                monthly_challange_win_achievements: winAchievements,
                                monthly_challange_game_total: totalAchievements,
                                shadow_challange_revealed: false // Keep shadow challenge hidden by default
                            });

                            await challenge.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Monthly Challenge Created')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (existingChallenge) {
                                resultEmbed.setDescription(`Monthly challenge replaced for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: existingChallenge.monthly_challange_gameid.toString() },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Monthly challenge created for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('add_shadow')
                                        .setLabel('Add Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ‘¥'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'add_shadow') {
                                        await this.handleShadowChallenge(resultI, { month, year });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error creating challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while creating the challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to create a challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleShadowChallenge(interaction, prefilledData = null) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Shadow Challenge')
            .setColor('#9932CC') // Dark purple
            .setDescription('Use this form to add or edit a shadow challenge for a specific month.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'Shadow Challenge Rules',
                    value: 'Shadow challenges are hidden mysteries that players can discover by guessing or playing the challenge games. They automatically reveal for past months.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('shadow_challenge_form')
                    .setLabel('Open Shadow Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸ‘¥')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'shadow_challenge_form') {
                    // Create modal for shadow challenge
                    const modal = new ModalBuilder()
                        .setCustomId('shadow_challenge_modal')
                        .setTitle('Add Shadow Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input with prefilled data if available
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.month) {
                        monthInput.setValue(prefilledData.month.toString());
                    } else {
                        // Default to current month
                        const now = new Date();
                        monthInput.setValue((now.getMonth() + 1).toString());
                    }

                    // Add year input with prefilled data if available
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.year) {
                        yearInput.setValue(prefilledData.year.toString());
                    } else {
                        // Default to current year
                        const now = new Date();
                        yearInput.setValue(now.getFullYear().toString());
                    }

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get date range for the specified month
                            const monthStart = new Date(year, month - 1, 1);
                            const nextMonthStart = new Date(year, month, 1);

                            // Find the target challenge
                            const targetChallenge = await Challenge.findOne({
                                date: {
                                    $gte: monthStart,
                                    $lt: nextMonthStart
                                }
                            });

                            if (!targetChallenge) {
                                return modalSubmission.editReply(`No challenge exists for ${month}/${year}. Create a monthly challenge first using /admin challenge create.`);
                            }

                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Check if there's an existing shadow game to be replaced
                            let replacedShadowGame = null;
                            if (targetChallenge.shadow_challange_gameid) {
                                try {
                                    const oldGameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
                                    replacedShadowGame = oldGameInfo.title;
                                } catch (error) {
                                    console.error('Error fetching old shadow game info:', error);
                                    replacedShadowGame = targetChallenge.shadow_challange_gameid;
                                }
                            }

                            // Update the challenge with shadow game information
                            targetChallenge.shadow_challange_gameid = gameId;
                            targetChallenge.shadow_challange_progression_achievements = progressionAchievements;
                            targetChallenge.shadow_challange_win_achievements = winAchievements;
                            targetChallenge.shadow_challange_game_total = totalAchievements;
                            
                            // Automatically reveal shadow games for past months
                            const now = new Date();
                            if (month < now.getMonth() + 1 || year < now.getFullYear()) {
                                targetChallenge.shadow_challange_revealed = true;
                            } else if (!targetChallenge.shadow_challange_revealed) {
                                // For current or future months, keep shadow games hidden by default
                                targetChallenge.shadow_challange_revealed = false;
                            }

                            await targetChallenge.save();

                            // Get month name for display
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Determine if it was auto-revealed
                            const autoRevealed = (month < now.getMonth() + 1 || year < now.getFullYear());
                            
                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#9932CC') // Dark purple for shadow challenges
                                .setTitle('Shadow Challenge Added')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (replacedShadowGame) {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} replaced`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: replacedShadowGame },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} created`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() },
                                { name: 'Visibility', value: targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden' + (autoRevealed ? ' (Auto-revealed as past challenge)' : '') }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('toggle_shadow')
                                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'toggle_shadow') {
                                        await this.handleToggleShadow(resultI, { month, year, force: true });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding shadow challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the shadow challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a shadow challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleToggleShadow(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            let force = options?.force || false;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                const now = new Date();
                month = now.getMonth() + 1; // 1-indexed month
                year = now.getFullYear();
            }
            
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the target challenge
            const targetChallenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!targetChallenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            if (!targetChallenge.shadow_challange_gameid) {
                return interaction.editReply(`No shadow challenge has been set for ${month}/${year}.`);
            }

            // Toggle the visibility
            targetChallenge.shadow_challange_revealed = !targetChallenge.shadow_challange_revealed;
            await targetChallenge.save();

            // Get game info for the response
            const gameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
            
            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Create response embed
            const resultEmbed = new EmbedBuilder()
                .setColor(targetChallenge.shadow_challange_revealed ? '#00FF00' : '#FF0000') // Green for revealed, red for hidden
                .setTitle(`Shadow Challenge ${targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden'}`)
                .setDescription(`The shadow challenge for ${monthName} ${year} is now ${targetChallenge.shadow_challange_revealed ? 'REVEALED' : 'HIDDEN'}.`)
                .setTimestamp();

            if (targetChallenge.shadow_challange_revealed) {
                resultEmbed.addFields(
                    { name: 'Game', value: gameInfo.title },
                    { name: 'Required Progression Achievements', value: targetChallenge.shadow_challange_progression_achievements.length.toString() },
                    { name: 'Required Win Achievements', value: targetChallenge.shadow_challange_win_achievements.length > 0 ? targetChallenge.shadow_challange_win_achievements.length.toString() : 'None' }
                );
                
                if (gameInfo.imageIcon) {
                    resultEmbed.setThumbnail(`https://retroachievements.org${gameInfo.imageIcon}`);
                }
            }

            // Add action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow_again')
                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                    new ButtonBuilder()
                        .setCustomId('view_challenge')
                        .setLabel('View Challenge Details')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ”')
                );

            // If we're force-updating from another command, use editReply
            // Otherwise, use standard reply
            if (force) {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            } else {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            }

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'toggle_shadow_again') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    } else if (i.customId === 'view_challenge') {
                        await this.handleViewChallenge(i, { month, year });
                    }
                }
            });

        } catch (error) {
            console.error('Error toggling shadow challenge visibility:', error);
            await interaction.editReply('An error occurred while toggling the shadow challenge visibility. Please try again.');
        }
    },

    async handleViewChallenge(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                // Open a form to select month/year
                const embed = new EmbedBuilder()
                    .setTitle('View Challenge Details')
                    .setColor('#3498DB')
                    .setDescription('Please select which challenge you want to view.')
                    .addFields(
                        {
                            name: 'Options',
                            value: 'You can view the current month\'s challenge or select a specific month.'
                        }
                    );

                // Create buttons
                const row = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('view_current_challenge')
                            .setLabel('Current Month')
                            .setStyle(ButtonStyle.Primary)
                            .setEmoji('ðŸ“…'),
                        new ButtonBuilder()
                            .setCustomId('select_month_challenge')
                            .setLabel('Select Month')
                            .setStyle(ButtonStyle.Secondary)
                            .setEmoji('ðŸ”')
                    );

                await interaction.editReply({
                    embeds: [embed],
                    components: [row]
                });

                // Set up collector for the buttons
                const message = await interaction.fetchReply();
                const buttonCollector = message.createMessageComponentCollector({
                    componentType: ComponentType.Button,
                    time: 300000 // 5 minutes timeout
                });

                buttonCollector.on('collect', async i => {
                    if (i.user.id === interaction.user.id) {
                        await i.deferUpdate();

                        if (i.customId === 'view_current_challenge') {
                            // Use current month
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                            
                            // Continue with viewing the challenge
                            await this.displayChallengeDetails(i, month, year);
                            
                            // Stop the collector
                            buttonCollector.stop();
                        } else if (i.customId === 'select_month_challenge') {
                            // Show modal to select month/year
                            const modal = new ModalBuilder()
                                .setCustomId('select_challenge_month_modal')
                                .setTitle('Select Challenge Month');

                            // Add month input
                            const monthInput = new TextInputBuilder()
                                .setCustomId('month')
                                .setLabel('Month (1-12)')
                                .setPlaceholder('Example: 5 (for May)')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add year input
                            const yearInput = new TextInputBuilder()
                                .setCustomId('year')
                                .setLabel('Year')
                                .setPlaceholder('Example: 2025')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add inputs to modal
                            const monthRow = new ActionRowBuilder().addComponents(monthInput);
                            const yearRow = new ActionRowBuilder().addComponents(yearInput);

                            modal.addComponents(monthRow, yearRow);

                            // Show the modal
                            await i.showModal(modal);

                            try {
                                // Wait for modal submission
                                const modalSubmission = await i.awaitModalSubmit({
                                    time: 300000 // 5 minutes to fill out the form
                                });

                                await modalSubmission.deferUpdate();

                                // Extract values from the modal
                                month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                                year = parseInt(modalSubmission.fields.getTextInputValue('year'));

                                // Validate inputs
                                if (isNaN(month) || month < 1 || month > 12) {
                                    return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                                }

                                if (isNaN(year) || year < 2000 || year > 2100) {
                                    return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                                }

                                // Continue with viewing the challenge
                                await this.displayChallengeDetails(modalSubmission, month, year);
                                
                                // Stop the collector
                                buttonCollector.stop();

                            } catch (modalError) {
                                console.error('Error handling modal submission:', modalError);
                                // Modal timed out or was cancelled
                            }
                        }
                    }
                });

                // Let the function end here and let the collector handle the rest
                return;
            }

            // If we have month/year, display the challenge
            await this.displayChallengeDetails(interaction, month, year);

        } catch (error) {
            console.error('Error viewing challenge:', error);
            await interaction.editReply('An error occurred while viewing the challenge. Please try again.');
        }
    },

    async displayChallengeDetails(interaction, month, year) {
        try {
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the challenge
            const challenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!challenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Get game info for monthly challenge
            let monthlyGameInfo = null;
            if (challenge.monthly_challange_gameid) {
                monthlyGameInfo = await retroAPI.getGameInfo(challenge.monthly_challange_gameid);
            }

            // Get game info for shadow challenge if revealed
            let shadowGameInfo = null;
            if (challenge.shadow_challange_gameid && challenge.shadow_challange_revealed) {
                shadowGameInfo = await retroAPI.getGameInfo(challenge.shadow_challange_gameid);
            }

            // Create main embed
            const embed = new EmbedBuilder()
                .setTitle(`Challenge Details: ${monthName} ${year}`)
                .setColor('#3498DB')
                .setDescription(`Here are the details for the ${monthName} ${year} challenges:`)
                .setTimestamp();

            // Add monthly challenge info
            if (monthlyGameInfo) {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: `**Game:** ${monthlyGameInfo.title}\n` +
                          `**Required Progression Achievements:** ${challenge.monthly_challange_progression_achievements.length}\n` +
                          `**Required Win Achievements:** ${challenge.monthly_challange_win_achievements.length}\n` +
                          `**Total Achievements:** ${challenge.monthly_challange_game_total}\n` +
                          `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.monthly_challange_gameid})`
                });

                if (monthlyGameInfo.imageIcon) {
                    embed.setThumbnail(`https://retroachievements.org${monthlyGameInfo.imageIcon}`);
                }
            } else {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: 'No monthly challenge set.'
                });
            }

            // Add shadow challenge info
            if (challenge.shadow_challange_gameid) {
                if (challenge.shadow_challange_revealed && shadowGameInfo) {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (REVEALED)',
                        value: `**Game:** ${shadowGameInfo.title}\n` +
                              `**Required Progression Achievements:** ${challenge.shadow_challange_progression_achievements.length}\n` +
                              `**Required Win Achievements:** ${challenge.shadow_challange_win_achievements.length}\n` +
                              `**Total Achievements:** ${challenge.shadow_challange_game_total}\n` +
                              `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.shadow_challange_gameid})`
                    });
                } else {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (HIDDEN)',
                        value: 'Shadow challenge exists but is currently hidden.\n' +
                              `Use \`/admin challenge toggle\` to reveal it.`
                    });
                }
            } else {
                embed.addFields({
                    name: 'ðŸ‘¥ Shadow Challenge',
                    value: 'No shadow challenge set.\n' +
                          `Use \`/admin challenge shadow\` to add one.`
                });
            }

            // Create action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('edit_monthly')
                        .setLabel('Edit Monthly Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('ðŸ†'),
                    new ButtonBuilder()
                        .setCustomId('edit_shadow')
                        .setLabel(challenge.shadow_challange_gameid ? 'Edit Shadow Challenge' : 'Add Shadow Challenge')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ‘¥')
                );

            // Add toggle button if shadow challenge exists
            if (challenge.shadow_challange_gameid) {
                actionRow.addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow')
                        .setLabel(challenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji(challenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸')
                );
            }

            await interaction.editReply({
                embeds: [embed],
                components: [actionRow]
            });

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'edit_monthly') {
                        await this.handleCreateChallenge(i);
                    } else if (i.customId === 'edit_shadow') {
                        await this.handleShadowChallenge(i, { month, year });
                    } else if (i.customId === 'toggle_shadow') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    }
                }
            });

        } catch (error) {
            console.error('Error displaying challenge details:', error);
            await interaction.editReply('An error occurred while retrieving challenge details. Please try again.');
        }
    },

    // ARCADE MANAGEMENT HANDLERS
    async handleArcadeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'add':
                await this.handleAddArcadeBoard(interaction);
                break;
            case 'racing':
                await this.handleAddRacingChallenge(interaction);
                break;
            case 'tiebreaker':
                await this.handleAddTiebreaker(interaction);
                break;
            case 'award':
                await this.handleAwardPoints(interaction);
                break;
            case 'announce':
                await this.handleAnnounceBoard(interaction);
                break;
            case 'view':
                await this.handleViewBoards(interaction);
                break;
            default:
                await interaction.editReply('Invalid arcade subcommand.');
        }
    },

    async handleAddArcadeBoard(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Arcade Board')
            .setColor('#9B59B6') // Purple
            .setDescription('Use this form to add a new arcade board to the community.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Board ID (unique identifier)\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description'
                },
                {
                    name: 'How to Find IDs',
                    value: '**Game ID**: The number at the end of the game URL on RetroAchievements\n**Leaderboard ID**: The number at the end of the leaderboard URL'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_arcade_form')
                    .setLabel('Open Arcade Board Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ¯')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_arcade_form') {
                    // Create modal for arcade board
                    const modal = new ModalBuilder()
                        .setCustomId('add_arcade_modal')
                        .setTitle('Add Arcade Board');

                    // Add board ID input
                    const boardIdInput = new TextInputBuilder()
                        .setCustomId('board_id')
                        .setLabel('Board ID (unique identifier)')
                        .setPlaceholder('Example: sonic3-special-stages')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this arcade board challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add inputs to modal
                    const boardIdRow = new ActionRowBuilder().addComponents(boardIdInput);
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);

                    modal.addComponents(boardIdRow, gameIdRow, leaderboardIdRow, descriptionRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const boardId = modalSubmission.fields.getTextInputValue('board_id');
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        try {
                            // Check if board ID already exists
                            const existingBoard = await ArcadeBoard.findOne({ boardId });
                            if (existingBoard) {
                                return modalSubmission.editReply(`A board with ID "${boardId}" already exists.`);
                            }

                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Create new board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'arcade',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description
                            });

                            await newBoard.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Arcade Board Added')
                                .setDescription(`Successfully added "${gameInfo.title}" arcade board!`)
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .addFields(
                                    { name: 'Board ID', value: boardId },
                                    { name: 'Game', value: gameInfo.title },
                                    { name: 'Console', value: gameInfo.consoleName || 'Unknown' },
                                    { name: 'Description', value: description }
                                )
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_board')
                                        .setLabel('Announce Board')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_board') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding arcade board:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the arcade board. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add an arcade board.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddRacingChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Racing Challenge')
            .setColor('#FF9900') // Orange
            .setDescription('Use this form to set up a monthly racing challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Track Name\nâ€¢ Description\nâ€¢ Month and Year (optional, defaults to current month)'
                },
                {
                    name: 'Racing Challenge Rules',
                    value: 'Racing challenges are monthly competitions where players compete on time-based leaderboards. The top 3 players will receive community points.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_racing_form')
                    .setLabel('Open Racing Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_racing_form') {
                    // Create modal for racing challenge
                    const modal = new ModalBuilder()
                        .setCustomId('add_racing_modal')
                        .setTitle('Add Racing Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add track name input
                    const trackNameInput = new TextInputBuilder()
                        .setCustomId('track_name')
                        .setLabel('Track Name')
                        .setPlaceholder('Example: Rainbow Road')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this racing challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add month/year input
                    const monthYearInput = new TextInputBuilder()
                        .setCustomId('month_year')
                        .setLabel('Month and Year (optional, MM/YYYY format)')
                        .setPlaceholder('Example: 05/2025 (defaults to current month)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const trackNameRow = new ActionRowBuilder().addComponents(trackNameInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthYearInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, trackNameRow, descriptionRow, monthYearRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const trackName = modalSubmission.fields.getTextInputValue('track_name');
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const monthYearInput = modalSubmission.fields.getTextInputValue('month_year');

                        // Parse month and year
                        let month, year;
                        if (monthYearInput && monthYearInput.trim()) {
                            const parts = monthYearInput.split('/');
                            if (parts.length === 2) {
                                month = parseInt(parts[0]);
                                year = parseInt(parts[1]);
                            } else {
                                // Invalid format, use current month/year
                                const now = new Date();
                                month = now.getMonth() + 1;
                                year = now.getFullYear();
                            }
                        } else {
                            // No input, use current month/year
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                        }

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Calculate start and end dates
                            // Start at beginning of specified month
                            const startDate = new Date(year, month - 1, 1);
                            
                            // End at the end of the specified month (23:59:59 on the last day)
                            const endDate = new Date(year, month, 0, 23, 59, 59);
                            
                            // Check if a racing challenge already exists for this month
                            const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                            const existingChallenge = await ArcadeBoard.findOne({
                                boardType: 'racing',
                                monthKey
                            });

                            if (existingChallenge) {
                                return modalSubmission.editReply(`A racing challenge already exists for ${monthKey}.`);
                            }

                            // Generate a unique board ID specifically for racing
                            // This format ensures no overlap with regular arcade boards
                            const boardId = `racing-${monthKey}`;

                            // Get the full game title and console name
                            const gameFull = `${gameInfo.title} (${gameInfo.consoleName})`;

                            // Create new racing board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'racing',
                                leaderboardId,
                                gameId,
                                gameTitle: gameFull,
                                trackName,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate,
                                endDate,
                                monthKey
                            });

                            await newBoard.save();

                            // Get month name for response
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF9900') // Orange for racing
                                .setTitle(`Racing Challenge Created: ${monthName} ${year}`)
                                .setDescription(
                                    `**Game:** ${gameFull}\n` +
                                    `**Track:** ${trackName}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Challenge Period:** ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `The top 3 players at the end of the month will receive award points!`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_racing')
                                        .setLabel('Announce Racing Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_racing') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding racing challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the racing challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a racing challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddTiebreaker(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Tiebreaker')
            .setColor('#FF0000') // Red
            .setDescription('Use this form to create a tiebreaker leaderboard for the monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description\nâ€¢ End Date (YYYY-MM-DD format)'
                },
                {
                    name: 'Tiebreaker Rules',
                    value: 'Tiebreakers are used to resolve ties in the monthly challenge leaderboard. Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_tiebreaker_form')
                    .setLabel('Open Tiebreaker Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('âš”ï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_tiebreaker_form') {
                    // Create modal for tiebreaker
                    const modal = new ModalBuilder()
                        .setCustomId('add_tiebreaker_modal')
                        .setTitle('Add Tiebreaker');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this tiebreaker challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add end date input
                    const endDateInput = new TextInputBuilder()
                        .setCustomId('end_date')
                        .setLabel('End Date (YYYY-MM-DD format)')
                        .setPlaceholder('Example: 2025-05-31')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const endDateRow = new ActionRowBuilder().addComponents(endDateInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, descriptionRow, endDateRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const endDateStr = modalSubmission.fields.getTextInputValue('end_date');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        // Parse end date
                        const endDate = new Date(endDateStr);
                        if (isNaN(endDate.getTime())) {
                            return modalSubmission.editReply('Invalid end date format. Please use YYYY-MM-DD.');
                        }

                        // Set end time to 23:59:59
                        endDate.setHours(23, 59, 59);

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Check if an active tiebreaker already exists
                            const now = new Date();
                            const activeTiebreaker = await ArcadeBoard.findOne({
                                boardType: 'tiebreaker',
                                startDate: { $lte: now },
                                endDate: { $gte: now }
                            });

                            if (activeTiebreaker) {
                                return modalSubmission.editReply('An active tiebreaker already exists. Please end it before creating a new one.');
                            }

                            // Generate a unique board ID based on month and year
                            const monthYear = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}`;
                            const boardId = `tiebreaker-${monthYear}`;

                            // Create new tiebreaker board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'tiebreaker',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate: now,
                                endDate,
                                // Add monthKey for consistency with racing challenges
                                monthKey: monthYear
                            });

                            await newBoard.save();

                            // Get the month name
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[now.getMonth()];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF0000') // Red for tiebreaker
                                .setTitle(`âš”ï¸ Tiebreaker Created: ${monthName} ${now.getFullYear()}`)
                                .setDescription(
                                    `**Game:** ${gameInfo.title}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Tiebreaker Period:** ${now.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `This tiebreaker will be used to resolve ties in the ${monthName} monthly challenge leaderboard. ` +
                                    `Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_tiebreaker')
                                        .setLabel('Announce Tiebreaker')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_tiebreaker') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding tiebreaker:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the tiebreaker. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a tiebreaker.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAwardPoints(interaction) {
        // Create select board form
        const embed = new EmbedBuilder()
            .setTitle('Award Points')
            .setColor('#32CD32') // Lime green
            .setDescription('Select a board to award points for.')
            .addFields(
                {
                    name: 'Award Points',
                    value: 'You can award points for completed racing challenges or arcade boards. For racing challenges, points are awarded to the top 3 players. For arcade boards, points are awarded annually.'
                }
            );

        // Find all racing boards and tiebreakers
        const racingBoards = await ArcadeBoard.find({ 
            boardType: 'racing',
            pointsAwarded: { $ne: true } // Only show boards that haven't been awarded points yet
        }).sort({ startDate: -1 });

        // Create options for racing boards
        const boardOptions = racingBoards.map(board => {
            const monthYear = board.monthKey || 'Unknown Date';
            return {
                label: `Racing: ${board.gameTitle}${board.trackName ? ` - ${board.trackName}` : ''}`,
                description: `${monthYear}`,
                value: `racing-${board.boardId}`
            };
        });

        // Add option for annual arcade awards if any arcade boards exist
        const arcadeBoards = await ArcadeBoard.find({ boardType: 'arcade' });
        if (arcadeBoards.length > 0) {
            boardOptions.push({
                label: 'Annual Arcade Awards',
                description: 'Award points for all arcade boards for the current year',
                value: 'arcade-annual'
            });
        }

        // Create dropdown if we have options
        if (boardOptions.length === 0) {
            return interaction.editReply('No eligible boards found for awarding points. All racing challenges have already been awarded points, or no racing challenges exist.');
        }

        // Create the dropdown
        const row = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('select_board_for_award')
                    .setPlaceholder('Select a board to award points')
                    .addOptions(boardOptions)
            );

        // Send the selection menu
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the dropdown selection
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.StringSelect,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                await i.deferUpdate();
                
                const selectedValue = i.values[0];
                
                if (selectedValue.startsWith('racing-')) {
                    // Extract board ID
                    const boardId = selectedValue.substring(7);
                    await this.awardRacingPoints(i, boardId);
                } else if (selectedValue === 'arcade-annual') {
                    await this.awardArcadePoints(i);
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        StringSelectMenuBuilder.from(row.components[0])
                            .setDisabled(true)
                            .setPlaceholder('Selection timed out')
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This selection has expired. Please run the command again if you still need to award points.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling dropdown:', error);
                }
            }
        });
    },

    async awardRacingPoints(interaction, boardId) {
        try {
            // Find the racing board
            const racingBoard = await ArcadeBoard.findOne({ 
                boardId,
                boardType: 'racing'
            });

            if (!racingBoard) {
                return interaction.editReply(`Racing board with ID "${boardId}" not found.`);
            }

            // Check if points have already been awarded
            if (racingBoard.pointsAwarded) {
                return interaction.editReply(`Points have already been awarded for this racing challenge.`);
            }

            // Check if the racing challenge has ended
            const now = new Date();
            if (racingBoard.endDate > now) {
                return interaction.editReply(`This racing challenge hasn't ended yet. It ends on ${racingBoard.endDate.toLocaleDateString()}.`);
            }

, 'i') }
            });

            if (!user) {
                return interaction.editReply('User not found. Please check the username or register the user first.');
            }

            // Create confirmation embed
            const confirmEmbed = new EmbedBuilder()
                .setTitle('Confirm Award')
                .setColor('#32CD32') // Lime green
                .setDescription(`Are you sure you want to give the following award to ${user.raUsername}?`)
                .addFields(
                    {
                        name: 'Award Details',
                        value: `**Title:** ${title}\n` +
                               `**Points:** ${points}\n` +
                               `**Awarded By:** ${interaction.user.tag}`
                    }
                )
                .setTimestamp();
                
            // Create confirmation buttons
            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('confirm_award')
                        .setLabel('Give Award')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji('ðŸ†'),
                    new ButtonBuilder()
                        .setCustomId('cancel_award')
                        .setLabel('Cancel')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('âŒ')
                );
                
            await interaction.editReply({
                embeds: [confirmEmbed],
                components: [row]
            });
            
            // Set up collector for the confirmation buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 60000 // 1 minute timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'confirm_award') {
                        // Add the community award
                        user.communityAwards.push({
                            title,
                            points,
                            awardedBy: interaction.user.tag
                        });

                        await user.save();
                        
                        // Show success message
                        const successEmbed = new EmbedBuilder()
                            .setColor('#00FF00') // Green for success
                            .setTitle('Award Given')
                            .setDescription(`Successfully awarded "${title}" (${points} point${points !== 1 ? 's' : ''}) to ${user.raUsername}!`)
                            .addFields(
                                {
                                    name: 'User Information',
                                    value: `**RA Username:** ${user.raUsername}\n` +
                                          `**Total Awards:** ${user.communityAwards.length}`
                                }
                            )
                            .setTimestamp();
                            
                        // Add view awards button
                        const viewButton = new ActionRowBuilder()
                            .addComponents(
                                new ButtonBuilder()
                                    .setCustomId('view_user_awards')
                                    .setLabel('View User Awards')
                                    .setStyle(ButtonStyle.Primary)
                                    .setEmoji('ðŸ”')
                            );
                            
                        await i.editReply({
                            embeds: [successEmbed],
                            components: [viewButton]
                        });
                        
                        // Set up collector for the view button
                        const viewMessage = await i.fetchReply();
                        const viewCollector = viewMessage.createMessageComponentCollector({
                            componentType: ComponentType.Button,
                            time: 60000 // 1 minute timeout
                        });
                        
                        viewCollector.on('collect', async viewI => {
                            if (viewI.user.id === interaction.user.id) {
                                await viewI.deferUpdate();
                                
                                if (viewI.customId === 'view_user_awards') {
                                    await this.displayUserAwards(viewI, user.raUsername);
                                }
                            }
                        });
                    } else if (i.customId === 'cancel_award') {
                        // Show cancellation message
                        await i.editReply({
                            content: 'Award cancelled.',
                            embeds: [],
                            components: []
                        });
                    }
                }
            });
        } catch (error) {
            console.error('Error giving community award:', error);
            return interaction.editReply('An error occurred while giving the award. Please try again.');
        }
    },

    async handleViewAwards(interaction) {
        try {
            const raUsername = interaction.options.getString('username');
            await this.displayUserAwards(interaction, raUsername);
        } catch (error) {
            console.error('Error viewing user awards:', error);
            return interaction.editReply('An error occurred while retrieving user awards. Please try again.');
        }
    },

    async displayUserAwards(interaction, raUsername) {
        try {
            // Find the user, case-insensitive search
            const user = await User.findOne({
                raUsername: { $regex: new RegExp(`^${raUsername}import { 
    SlashCommandBuilder, 
    EmbedBuilder, 
    ActionRowBuilder, 
    StringSelectMenuBuilder,
    ButtonBuilder,
    ButtonStyle,
    ComponentType,
    ModalBuilder,
    TextInputBuilder,
    TextInputStyle,
    PermissionFlagsBits
} from 'discord.js';
import { User } from '../../models/User.js';
import { Challenge } from '../../models/Challenge.js';
import { ArcadeBoard } from '../../models/ArcadeBoard.js';
import { Poll } from '../../models/Poll.js';
import retroAPI from '../../services/retroAPI.js';
import { config } from '../../config/config.js';

// Constants
const MEMBER_ROLE_ID = '1316292690870014002';

export default {
    data: new SlashCommandBuilder()
        .setName('admin')
        .setDescription('Admin dashboard for managing all aspects of the community')
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild) // Require admin permissions
        // Challenge Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('challenge')
                .setDescription('Manage monthly and shadow challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('create')
                        .setDescription('Create or replace a monthly challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('shadow')
                        .setDescription('Add or edit a shadow challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('toggle')
                        .setDescription('Toggle shadow challenge visibility')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View current challenge details')
                )
        )
        
        // Arcade Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('arcade')
                .setDescription('Manage arcade boards and racing challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('add')
                        .setDescription('Add an arcade board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('racing')
                        .setDescription('Set up a racing challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('tiebreaker')
                        .setDescription('Create a tiebreaker board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Award points for a completed board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('announce')
                        .setDescription('Announce a board to the community')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View and manage existing boards')
                )
        )
        
        // User Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('user')
                .setDescription('Manage users, registrations, and awards')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('register')
                        .setDescription('Register a user')
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to register')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('unregister')
                        .setDescription('Unregister a user')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to unregister')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('purge')
                        .setDescription('Completely remove a user registration')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to purge')
                            .setRequired(true))
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to purge (optional)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Give a community award to a user')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('title')
                            .setDescription('The title of the award')
                            .setRequired(true))
                        .addIntegerOption(option =>
                            option.setName('points')
                            .setDescription('Number of points for this award')
                            .setRequired(true)
                            .setMinValue(1))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('awards')
                        .setDescription('View user awards')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('clear')
                        .setDescription('Clear nominations or awards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('reset')
                        .setDescription('Reset user achievements')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('RetroAchievements username')
                            .setRequired(true))
                )
        )
        
        // Voting Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('voting')
                .setDescription('Manage voting processes')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('start')
                        .setDescription('Start a voting poll')
                        .addChannelOption(option =>
                            option.setName('channel')
                            .setDescription('The channel to create the poll announcement in')
                            .setRequired(true))
                        .addChannelOption(option =>
                            option.setName('results_channel')
                            .setDescription('The channel to announce results in (defaults to same channel)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('cancel')
                        .setDescription('Cancel an active voting poll')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('status')
                        .setDescription('Check status of current voting')
                )
        )
        
        // System Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('system')
                .setDescription('System-level operations')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('update')
                        .setDescription('Force an update of all stats and leaderboards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('suggestions')
                        .setDescription('Manage community suggestions')
                )
        )
        
        // Info display subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('info')
                .setDescription('Display shareable information')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('arcade')
                        .setDescription('Display arcade board information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('challenges')
                        .setDescription('Display challenge information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('overview')
                        .setDescription('Display community overview')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('commands')
                        .setDescription('Display available commands')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('rules')
                        .setDescription('Display community rules')
                )
        ),

    async execute(interaction) {
        // Check if user has admin role
        if (!interaction.member.roles.cache.has(config.bot.roles.admin)) {
            return interaction.reply({
                content: 'You do not have permission to use this command.',
                ephemeral: true
            });
        }

        await interaction.deferReply({ ephemeral: true });

        try {
            // Extract subcommand group and subcommand
            const subcommandGroup = interaction.options.getSubcommandGroup();
            const subcommand = interaction.options.getSubcommand();
            
            // Route to the appropriate handler based on subcommand group and subcommand
            switch (subcommandGroup) {
                case 'challenge':
                    await this.handleChallengeCommand(interaction, subcommand);
                    break;
                case 'arcade':
                    await this.handleArcadeCommand(interaction, subcommand);
                    break;
                case 'user':
                    await this.handleUserCommand(interaction, subcommand);
                    break;
                case 'voting':
                    await this.handleVotingCommand(interaction, subcommand);
                    break;
                case 'system':
                    await this.handleSystemCommand(interaction, subcommand);
                    break;
                case 'info':
                    await this.handleInfoCommand(interaction, subcommand);
                    break;
                default:
                    await interaction.editReply('Invalid subcommand group.');
            }
        } catch (error) {
            console.error('Error executing admin command:', error);
            await interaction.editReply('An error occurred while processing your request.');
        }
    },

    // CHALLENGE MANAGEMENT HANDLERS
    async handleChallengeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'create':
                await this.handleCreateChallenge(interaction);
                break;
            case 'shadow':
                await this.handleShadowChallenge(interaction);
                break;
            case 'toggle':
                await this.handleToggleShadow(interaction);
                break;
            case 'view':
                await this.handleViewChallenge(interaction);
                break;
            default:
                await interaction.editReply('Invalid challenge subcommand.');
        }
    },

    async handleCreateChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Create Monthly Challenge')
            .setColor('#32CD32')
            .setDescription('Use this form to create or replace a monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'How to Find Achievement IDs',
                    value: 'Go to the game page on RetroAchievements, hover over an achievement, and note the ID number in the URL.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('create_challenge_form')
                    .setLabel('Open Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ®')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'create_challenge_form') {
                    // Create modal for challenge creation
                    const modal = new ModalBuilder()
                        .setCustomId('create_challenge_modal')
                        .setTitle('Create Monthly Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add year input
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Create date for the first of the specified month
                            const challengeDate = new Date(year, month - 1, 1);

                            // Check if a challenge already exists for this month
                            const existingChallenge = await Challenge.findOneAndDelete({
                                date: {
                                    $gte: challengeDate,
                                    $lt: new Date(year, month, 1)
                                }
                            });

                            // Create new challenge
                            const challenge = new Challenge({
                                date: challengeDate,
                                monthly_challange_gameid: gameId,
                                monthly_challange_progression_achievements: progressionAchievements,
                                monthly_challange_win_achievements: winAchievements,
                                monthly_challange_game_total: totalAchievements,
                                shadow_challange_revealed: false // Keep shadow challenge hidden by default
                            });

                            await challenge.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Monthly Challenge Created')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (existingChallenge) {
                                resultEmbed.setDescription(`Monthly challenge replaced for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: existingChallenge.monthly_challange_gameid.toString() },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Monthly challenge created for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('add_shadow')
                                        .setLabel('Add Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ‘¥'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'add_shadow') {
                                        await this.handleShadowChallenge(resultI, { month, year });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error creating challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while creating the challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to create a challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleShadowChallenge(interaction, prefilledData = null) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Shadow Challenge')
            .setColor('#9932CC') // Dark purple
            .setDescription('Use this form to add or edit a shadow challenge for a specific month.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'Shadow Challenge Rules',
                    value: 'Shadow challenges are hidden mysteries that players can discover by guessing or playing the challenge games. They automatically reveal for past months.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('shadow_challenge_form')
                    .setLabel('Open Shadow Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸ‘¥')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'shadow_challenge_form') {
                    // Create modal for shadow challenge
                    const modal = new ModalBuilder()
                        .setCustomId('shadow_challenge_modal')
                        .setTitle('Add Shadow Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input with prefilled data if available
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.month) {
                        monthInput.setValue(prefilledData.month.toString());
                    } else {
                        // Default to current month
                        const now = new Date();
                        monthInput.setValue((now.getMonth() + 1).toString());
                    }

                    // Add year input with prefilled data if available
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.year) {
                        yearInput.setValue(prefilledData.year.toString());
                    } else {
                        // Default to current year
                        const now = new Date();
                        yearInput.setValue(now.getFullYear().toString());
                    }

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get date range for the specified month
                            const monthStart = new Date(year, month - 1, 1);
                            const nextMonthStart = new Date(year, month, 1);

                            // Find the target challenge
                            const targetChallenge = await Challenge.findOne({
                                date: {
                                    $gte: monthStart,
                                    $lt: nextMonthStart
                                }
                            });

                            if (!targetChallenge) {
                                return modalSubmission.editReply(`No challenge exists for ${month}/${year}. Create a monthly challenge first using /admin challenge create.`);
                            }

                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Check if there's an existing shadow game to be replaced
                            let replacedShadowGame = null;
                            if (targetChallenge.shadow_challange_gameid) {
                                try {
                                    const oldGameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
                                    replacedShadowGame = oldGameInfo.title;
                                } catch (error) {
                                    console.error('Error fetching old shadow game info:', error);
                                    replacedShadowGame = targetChallenge.shadow_challange_gameid;
                                }
                            }

                            // Update the challenge with shadow game information
                            targetChallenge.shadow_challange_gameid = gameId;
                            targetChallenge.shadow_challange_progression_achievements = progressionAchievements;
                            targetChallenge.shadow_challange_win_achievements = winAchievements;
                            targetChallenge.shadow_challange_game_total = totalAchievements;
                            
                            // Automatically reveal shadow games for past months
                            const now = new Date();
                            if (month < now.getMonth() + 1 || year < now.getFullYear()) {
                                targetChallenge.shadow_challange_revealed = true;
                            } else if (!targetChallenge.shadow_challange_revealed) {
                                // For current or future months, keep shadow games hidden by default
                                targetChallenge.shadow_challange_revealed = false;
                            }

                            await targetChallenge.save();

                            // Get month name for display
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Determine if it was auto-revealed
                            const autoRevealed = (month < now.getMonth() + 1 || year < now.getFullYear());
                            
                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#9932CC') // Dark purple for shadow challenges
                                .setTitle('Shadow Challenge Added')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (replacedShadowGame) {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} replaced`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: replacedShadowGame },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} created`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() },
                                { name: 'Visibility', value: targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden' + (autoRevealed ? ' (Auto-revealed as past challenge)' : '') }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('toggle_shadow')
                                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'toggle_shadow') {
                                        await this.handleToggleShadow(resultI, { month, year, force: true });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding shadow challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the shadow challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a shadow challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleToggleShadow(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            let force = options?.force || false;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                const now = new Date();
                month = now.getMonth() + 1; // 1-indexed month
                year = now.getFullYear();
            }
            
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the target challenge
            const targetChallenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!targetChallenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            if (!targetChallenge.shadow_challange_gameid) {
                return interaction.editReply(`No shadow challenge has been set for ${month}/${year}.`);
            }

            // Toggle the visibility
            targetChallenge.shadow_challange_revealed = !targetChallenge.shadow_challange_revealed;
            await targetChallenge.save();

            // Get game info for the response
            const gameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
            
            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Create response embed
            const resultEmbed = new EmbedBuilder()
                .setColor(targetChallenge.shadow_challange_revealed ? '#00FF00' : '#FF0000') // Green for revealed, red for hidden
                .setTitle(`Shadow Challenge ${targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden'}`)
                .setDescription(`The shadow challenge for ${monthName} ${year} is now ${targetChallenge.shadow_challange_revealed ? 'REVEALED' : 'HIDDEN'}.`)
                .setTimestamp();

            if (targetChallenge.shadow_challange_revealed) {
                resultEmbed.addFields(
                    { name: 'Game', value: gameInfo.title },
                    { name: 'Required Progression Achievements', value: targetChallenge.shadow_challange_progression_achievements.length.toString() },
                    { name: 'Required Win Achievements', value: targetChallenge.shadow_challange_win_achievements.length > 0 ? targetChallenge.shadow_challange_win_achievements.length.toString() : 'None' }
                );
                
                if (gameInfo.imageIcon) {
                    resultEmbed.setThumbnail(`https://retroachievements.org${gameInfo.imageIcon}`);
                }
            }

            // Add action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow_again')
                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                    new ButtonBuilder()
                        .setCustomId('view_challenge')
                        .setLabel('View Challenge Details')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ”')
                );

            // If we're force-updating from another command, use editReply
            // Otherwise, use standard reply
            if (force) {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            } else {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            }

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'toggle_shadow_again') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    } else if (i.customId === 'view_challenge') {
                        await this.handleViewChallenge(i, { month, year });
                    }
                }
            });

        } catch (error) {
            console.error('Error toggling shadow challenge visibility:', error);
            await interaction.editReply('An error occurred while toggling the shadow challenge visibility. Please try again.');
        }
    },

    async handleViewChallenge(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                // Open a form to select month/year
                const embed = new EmbedBuilder()
                    .setTitle('View Challenge Details')
                    .setColor('#3498DB')
                    .setDescription('Please select which challenge you want to view.')
                    .addFields(
                        {
                            name: 'Options',
                            value: 'You can view the current month\'s challenge or select a specific month.'
                        }
                    );

                // Create buttons
                const row = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('view_current_challenge')
                            .setLabel('Current Month')
                            .setStyle(ButtonStyle.Primary)
                            .setEmoji('ðŸ“…'),
                        new ButtonBuilder()
                            .setCustomId('select_month_challenge')
                            .setLabel('Select Month')
                            .setStyle(ButtonStyle.Secondary)
                            .setEmoji('ðŸ”')
                    );

                await interaction.editReply({
                    embeds: [embed],
                    components: [row]
                });

                // Set up collector for the buttons
                const message = await interaction.fetchReply();
                const buttonCollector = message.createMessageComponentCollector({
                    componentType: ComponentType.Button,
                    time: 300000 // 5 minutes timeout
                });

                buttonCollector.on('collect', async i => {
                    if (i.user.id === interaction.user.id) {
                        await i.deferUpdate();

                        if (i.customId === 'view_current_challenge') {
                            // Use current month
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                            
                            // Continue with viewing the challenge
                            await this.displayChallengeDetails(i, month, year);
                            
                            // Stop the collector
                            buttonCollector.stop();
                        } else if (i.customId === 'select_month_challenge') {
                            // Show modal to select month/year
                            const modal = new ModalBuilder()
                                .setCustomId('select_challenge_month_modal')
                                .setTitle('Select Challenge Month');

                            // Add month input
                            const monthInput = new TextInputBuilder()
                                .setCustomId('month')
                                .setLabel('Month (1-12)')
                                .setPlaceholder('Example: 5 (for May)')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add year input
                            const yearInput = new TextInputBuilder()
                                .setCustomId('year')
                                .setLabel('Year')
                                .setPlaceholder('Example: 2025')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add inputs to modal
                            const monthRow = new ActionRowBuilder().addComponents(monthInput);
                            const yearRow = new ActionRowBuilder().addComponents(yearInput);

                            modal.addComponents(monthRow, yearRow);

                            // Show the modal
                            await i.showModal(modal);

                            try {
                                // Wait for modal submission
                                const modalSubmission = await i.awaitModalSubmit({
                                    time: 300000 // 5 minutes to fill out the form
                                });

                                await modalSubmission.deferUpdate();

                                // Extract values from the modal
                                month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                                year = parseInt(modalSubmission.fields.getTextInputValue('year'));

                                // Validate inputs
                                if (isNaN(month) || month < 1 || month > 12) {
                                    return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                                }

                                if (isNaN(year) || year < 2000 || year > 2100) {
                                    return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                                }

                                // Continue with viewing the challenge
                                await this.displayChallengeDetails(modalSubmission, month, year);
                                
                                // Stop the collector
                                buttonCollector.stop();

                            } catch (modalError) {
                                console.error('Error handling modal submission:', modalError);
                                // Modal timed out or was cancelled
                            }
                        }
                    }
                });

                // Let the function end here and let the collector handle the rest
                return;
            }

            // If we have month/year, display the challenge
            await this.displayChallengeDetails(interaction, month, year);

        } catch (error) {
            console.error('Error viewing challenge:', error);
            await interaction.editReply('An error occurred while viewing the challenge. Please try again.');
        }
    },

    async displayChallengeDetails(interaction, month, year) {
        try {
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the challenge
            const challenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!challenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Get game info for monthly challenge
            let monthlyGameInfo = null;
            if (challenge.monthly_challange_gameid) {
                monthlyGameInfo = await retroAPI.getGameInfo(challenge.monthly_challange_gameid);
            }

            // Get game info for shadow challenge if revealed
            let shadowGameInfo = null;
            if (challenge.shadow_challange_gameid && challenge.shadow_challange_revealed) {
                shadowGameInfo = await retroAPI.getGameInfo(challenge.shadow_challange_gameid);
            }

            // Create main embed
            const embed = new EmbedBuilder()
                .setTitle(`Challenge Details: ${monthName} ${year}`)
                .setColor('#3498DB')
                .setDescription(`Here are the details for the ${monthName} ${year} challenges:`)
                .setTimestamp();

            // Add monthly challenge info
            if (monthlyGameInfo) {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: `**Game:** ${monthlyGameInfo.title}\n` +
                          `**Required Progression Achievements:** ${challenge.monthly_challange_progression_achievements.length}\n` +
                          `**Required Win Achievements:** ${challenge.monthly_challange_win_achievements.length}\n` +
                          `**Total Achievements:** ${challenge.monthly_challange_game_total}\n` +
                          `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.monthly_challange_gameid})`
                });

                if (monthlyGameInfo.imageIcon) {
                    embed.setThumbnail(`https://retroachievements.org${monthlyGameInfo.imageIcon}`);
                }
            } else {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: 'No monthly challenge set.'
                });
            }

            // Add shadow challenge info
            if (challenge.shadow_challange_gameid) {
                if (challenge.shadow_challange_revealed && shadowGameInfo) {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (REVEALED)',
                        value: `**Game:** ${shadowGameInfo.title}\n` +
                              `**Required Progression Achievements:** ${challenge.shadow_challange_progression_achievements.length}\n` +
                              `**Required Win Achievements:** ${challenge.shadow_challange_win_achievements.length}\n` +
                              `**Total Achievements:** ${challenge.shadow_challange_game_total}\n` +
                              `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.shadow_challange_gameid})`
                    });
                } else {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (HIDDEN)',
                        value: 'Shadow challenge exists but is currently hidden.\n' +
                              `Use \`/admin challenge toggle\` to reveal it.`
                    });
                }
            } else {
                embed.addFields({
                    name: 'ðŸ‘¥ Shadow Challenge',
                    value: 'No shadow challenge set.\n' +
                          `Use \`/admin challenge shadow\` to add one.`
                });
            }

            // Create action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('edit_monthly')
                        .setLabel('Edit Monthly Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('ðŸ†'),
                    new ButtonBuilder()
                        .setCustomId('edit_shadow')
                        .setLabel(challenge.shadow_challange_gameid ? 'Edit Shadow Challenge' : 'Add Shadow Challenge')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ‘¥')
                );

            // Add toggle button if shadow challenge exists
            if (challenge.shadow_challange_gameid) {
                actionRow.addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow')
                        .setLabel(challenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji(challenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸')
                );
            }

            await interaction.editReply({
                embeds: [embed],
                components: [actionRow]
            });

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'edit_monthly') {
                        await this.handleCreateChallenge(i);
                    } else if (i.customId === 'edit_shadow') {
                        await this.handleShadowChallenge(i, { month, year });
                    } else if (i.customId === 'toggle_shadow') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    }
                }
            });

        } catch (error) {
            console.error('Error displaying challenge details:', error);
            await interaction.editReply('An error occurred while retrieving challenge details. Please try again.');
        }
    },

    // ARCADE MANAGEMENT HANDLERS
    async handleArcadeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'add':
                await this.handleAddArcadeBoard(interaction);
                break;
            case 'racing':
                await this.handleAddRacingChallenge(interaction);
                break;
            case 'tiebreaker':
                await this.handleAddTiebreaker(interaction);
                break;
            case 'award':
                await this.handleAwardPoints(interaction);
                break;
            case 'announce':
                await this.handleAnnounceBoard(interaction);
                break;
            case 'view':
                await this.handleViewBoards(interaction);
                break;
            default:
                await interaction.editReply('Invalid arcade subcommand.');
        }
    },

    async handleAddArcadeBoard(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Arcade Board')
            .setColor('#9B59B6') // Purple
            .setDescription('Use this form to add a new arcade board to the community.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Board ID (unique identifier)\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description'
                },
                {
                    name: 'How to Find IDs',
                    value: '**Game ID**: The number at the end of the game URL on RetroAchievements\n**Leaderboard ID**: The number at the end of the leaderboard URL'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_arcade_form')
                    .setLabel('Open Arcade Board Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ¯')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_arcade_form') {
                    // Create modal for arcade board
                    const modal = new ModalBuilder()
                        .setCustomId('add_arcade_modal')
                        .setTitle('Add Arcade Board');

                    // Add board ID input
                    const boardIdInput = new TextInputBuilder()
                        .setCustomId('board_id')
                        .setLabel('Board ID (unique identifier)')
                        .setPlaceholder('Example: sonic3-special-stages')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this arcade board challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add inputs to modal
                    const boardIdRow = new ActionRowBuilder().addComponents(boardIdInput);
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);

                    modal.addComponents(boardIdRow, gameIdRow, leaderboardIdRow, descriptionRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const boardId = modalSubmission.fields.getTextInputValue('board_id');
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        try {
                            // Check if board ID already exists
                            const existingBoard = await ArcadeBoard.findOne({ boardId });
                            if (existingBoard) {
                                return modalSubmission.editReply(`A board with ID "${boardId}" already exists.`);
                            }

                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Create new board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'arcade',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description
                            });

                            await newBoard.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Arcade Board Added')
                                .setDescription(`Successfully added "${gameInfo.title}" arcade board!`)
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .addFields(
                                    { name: 'Board ID', value: boardId },
                                    { name: 'Game', value: gameInfo.title },
                                    { name: 'Console', value: gameInfo.consoleName || 'Unknown' },
                                    { name: 'Description', value: description }
                                )
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_board')
                                        .setLabel('Announce Board')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_board') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding arcade board:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the arcade board. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add an arcade board.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddRacingChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Racing Challenge')
            .setColor('#FF9900') // Orange
            .setDescription('Use this form to set up a monthly racing challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Track Name\nâ€¢ Description\nâ€¢ Month and Year (optional, defaults to current month)'
                },
                {
                    name: 'Racing Challenge Rules',
                    value: 'Racing challenges are monthly competitions where players compete on time-based leaderboards. The top 3 players will receive community points.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_racing_form')
                    .setLabel('Open Racing Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_racing_form') {
                    // Create modal for racing challenge
                    const modal = new ModalBuilder()
                        .setCustomId('add_racing_modal')
                        .setTitle('Add Racing Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add track name input
                    const trackNameInput = new TextInputBuilder()
                        .setCustomId('track_name')
                        .setLabel('Track Name')
                        .setPlaceholder('Example: Rainbow Road')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this racing challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add month/year input
                    const monthYearInput = new TextInputBuilder()
                        .setCustomId('month_year')
                        .setLabel('Month and Year (optional, MM/YYYY format)')
                        .setPlaceholder('Example: 05/2025 (defaults to current month)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const trackNameRow = new ActionRowBuilder().addComponents(trackNameInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthYearInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, trackNameRow, descriptionRow, monthYearRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const trackName = modalSubmission.fields.getTextInputValue('track_name');
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const monthYearInput = modalSubmission.fields.getTextInputValue('month_year');

                        // Parse month and year
                        let month, year;
                        if (monthYearInput && monthYearInput.trim()) {
                            const parts = monthYearInput.split('/');
                            if (parts.length === 2) {
                                month = parseInt(parts[0]);
                                year = parseInt(parts[1]);
                            } else {
                                // Invalid format, use current month/year
                                const now = new Date();
                                month = now.getMonth() + 1;
                                year = now.getFullYear();
                            }
                        } else {
                            // No input, use current month/year
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                        }

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Calculate start and end dates
                            // Start at beginning of specified month
                            const startDate = new Date(year, month - 1, 1);
                            
                            // End at the end of the specified month (23:59:59 on the last day)
                            const endDate = new Date(year, month, 0, 23, 59, 59);
                            
                            // Check if a racing challenge already exists for this month
                            const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                            const existingChallenge = await ArcadeBoard.findOne({
                                boardType: 'racing',
                                monthKey
                            });

                            if (existingChallenge) {
                                return modalSubmission.editReply(`A racing challenge already exists for ${monthKey}.`);
                            }

                            // Generate a unique board ID specifically for racing
                            // This format ensures no overlap with regular arcade boards
                            const boardId = `racing-${monthKey}`;

                            // Get the full game title and console name
                            const gameFull = `${gameInfo.title} (${gameInfo.consoleName})`;

                            // Create new racing board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'racing',
                                leaderboardId,
                                gameId,
                                gameTitle: gameFull,
                                trackName,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate,
                                endDate,
                                monthKey
                            });

                            await newBoard.save();

                            // Get month name for response
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF9900') // Orange for racing
                                .setTitle(`Racing Challenge Created: ${monthName} ${year}`)
                                .setDescription(
                                    `**Game:** ${gameFull}\n` +
                                    `**Track:** ${trackName}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Challenge Period:** ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `The top 3 players at the end of the month will receive award points!`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_racing')
                                        .setLabel('Announce Racing Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_racing') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding racing challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the racing challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a racing challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddTiebreaker(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Tiebreaker')
            .setColor('#FF0000') // Red
            .setDescription('Use this form to create a tiebreaker leaderboard for the monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description\nâ€¢ End Date (YYYY-MM-DD format)'
                },
                {
                    name: 'Tiebreaker Rules',
                    value: 'Tiebreakers are used to resolve ties in the monthly challenge leaderboard. Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_tiebreaker_form')
                    .setLabel('Open Tiebreaker Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('âš”ï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_tiebreaker_form') {
                    // Create modal for tiebreaker
                    const modal = new ModalBuilder()
                        .setCustomId('add_tiebreaker_modal')
                        .setTitle('Add Tiebreaker');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this tiebreaker challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add end date input
                    const endDateInput = new TextInputBuilder()
                        .setCustomId('end_date')
                        .setLabel('End Date (YYYY-MM-DD format)')
                        .setPlaceholder('Example: 2025-05-31')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const endDateRow = new ActionRowBuilder().addComponents(endDateInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, descriptionRow, endDateRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const endDateStr = modalSubmission.fields.getTextInputValue('end_date');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        // Parse end date
                        const endDate = new Date(endDateStr);
                        if (isNaN(endDate.getTime())) {
                            return modalSubmission.editReply('Invalid end date format. Please use YYYY-MM-DD.');
                        }

                        // Set end time to 23:59:59
                        endDate.setHours(23, 59, 59);

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Check if an active tiebreaker already exists
                            const now = new Date();
                            const activeTiebreaker = await ArcadeBoard.findOne({
                                boardType: 'tiebreaker',
                                startDate: { $lte: now },
                                endDate: { $gte: now }
                            });

                            if (activeTiebreaker) {
                                return modalSubmission.editReply('An active tiebreaker already exists. Please end it before creating a new one.');
                            }

                            // Generate a unique board ID based on month and year
                            const monthYear = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}`;
                            const boardId = `tiebreaker-${monthYear}`;

                            // Create new tiebreaker board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'tiebreaker',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate: now,
                                endDate,
                                // Add monthKey for consistency with racing challenges
                                monthKey: monthYear
                            });

                            await newBoard.save();

                            // Get the month name
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[now.getMonth()];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF0000') // Red for tiebreaker
                                .setTitle(`âš”ï¸ Tiebreaker Created: ${monthName} ${now.getFullYear()}`)
                                .setDescription(
                                    `**Game:** ${gameInfo.title}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Tiebreaker Period:** ${now.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `This tiebreaker will be used to resolve ties in the ${monthName} monthly challenge leaderboard. ` +
                                    `Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_tiebreaker')
                                        .setLabel('Announce Tiebreaker')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_tiebreaker') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding tiebreaker:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the tiebreaker. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a tiebreaker.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAwardPoints(interaction) {
        // Create select board form
        const embed = new EmbedBuilder()
            .setTitle('Award Points')
            .setColor('#32CD32') // Lime green
            .setDescription('Select a board to award points for.')
            .addFields(
                {
                    name: 'Award Points',
                    value: 'You can award points for completed racing challenges or arcade boards. For racing challenges, points are awarded to the top 3 players. For arcade boards, points are awarded annually.'
                }
            );

        // Find all racing boards and tiebreakers
        const racingBoards = await ArcadeBoard.find({ 
            boardType: 'racing',
            pointsAwarded: { $ne: true } // Only show boards that haven't been awarded points yet
        }).sort({ startDate: -1 });

        // Create options for racing boards
        const boardOptions = racingBoards.map(board => {
            const monthYear = board.monthKey || 'Unknown Date';
            return {
                label: `Racing: ${board.gameTitle}${board.trackName ? ` - ${board.trackName}` : ''}`,
                description: `${monthYear}`,
                value: `racing-${board.boardId}`
            };
        });

        // Add option for annual arcade awards if any arcade boards exist
        const arcadeBoards = await ArcadeBoard.find({ boardType: 'arcade' });
        if (arcadeBoards.length > 0) {
            boardOptions.push({
                label: 'Annual Arcade Awards',
                description: 'Award points for all arcade boards for the current year',
                value: 'arcade-annual'
            });
        }

        // Create dropdown if we have options
        if (boardOptions.length === 0) {
            return interaction.editReply('No eligible boards found for awarding points. All racing challenges have already been awarded points, or no racing challenges exist.');
        }

        // Create the dropdown
        const row = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('select_board_for_award')
                    .setPlaceholder('Select a board to award points')
                    .addOptions(boardOptions)
            );

        // Send the selection menu
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the dropdown selection
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.StringSelect,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                await i.deferUpdate();
                
                const selectedValue = i.values[0];
                
                if (selectedValue.startsWith('racing-')) {
                    // Extract board ID
                    const boardId = selectedValue.substring(7);
                    await this.awardRacingPoints(i, boardId);
                } else if (selectedValue === 'arcade-annual') {
                    await this.awardArcadePoints(i);
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        StringSelectMenuBuilder.from(row.components[0])
                            .setDisabled(true)
                            .setPlaceholder('Selection timed out')
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This selection has expired. Please run the command again if you still need to award points.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling dropdown:', error);
                }
            }
        });
    },

    async awardRacingPoints(interaction, boardId) {
        try {
            // Find the racing board
            const racingBoard = await ArcadeBoard.findOne({ 
                boardId,
                boardType: 'racing'
            });

            if (!racingBoard) {
                return interaction.editReply(`Racing board with ID "${boardId}" not found.`);
            }

            // Check if points have already been awarded
            if (racingBoard.pointsAwarded) {
                return interaction.editReply(`Points have already been awarded for this racing challenge.`);
            }

            // Check if the racing challenge has ended
            const now = new Date();
            if (racingBoard.endDate > now) {
                return interaction.editReply(`This racing challenge hasn't ended yet. It ends on ${racingBoard.endDate.toLocaleDateString()}.`);
            }

, 'i') }
            });

            if (!user) {
                return interaction.editReply(`User "${raUsername}" not found. Please check the username or register the user first.`);
            }

            // Check if the user has any awards
            if (!user.communityAwards || user.communityAwards.length === 0) {
                return interaction.editReply(`User "${user.raUsername}" has no community awards.`);
            }

            // Create the awards embed
            const embed = new EmbedBuilder()
                .setTitle(`Community Awards: ${user.raUsername}`)
                .setColor('#FFD700') // Gold
                .setDescription(`Showing ${user.communityAwards.length} community award${user.communityAwards.length !== 1 ? 's' : ''}.`)
                .setTimestamp();
                
            // Format awards for display
            const awards = user.communityAwards.map((award, index) => {
                const awardDate = award.awardedAt ? new Date(award.awardedAt).toLocaleDateString() : 'Unknown date';
                return `**${index + 1}.** "${award.title}" (${award.points} point${award.points !== 1 ? 's' : ''})\n` +
                      `   Awarded by: ${award.awardedBy || 'System'} on ${awardDate}`;
            }).join('\n\n');
            
            embed.addFields({
                name: 'Awards',
                value: awards
            });
            
            // Add total points
            const totalPoints = user.communityAwards.reduce((sum, award) => sum + award.points, 0);
            embed.addFields({
                name: 'Total Points',
                value: totalPoints.toString()
            });
            
            // Create action buttons
            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('clear_award')
                        .setLabel('Clear Award')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('ðŸ—‘ï¸'),
                    new ButtonBuilder()
                        .setCustomId('add_award')
                        .setLabel('Add Award')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji('ðŸ†')
                );
                
            await interaction.editReply({
                embeds: [embed],
                components: [row]
            });
            
            // Set up collector for the button interactions
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'clear_award') {
                        await this.handleClearAward(i, user.raUsername);
                    } else if (i.customId === 'add_award') {
                        // Create modal for adding award
                        const modal = new ModalBuilder()
                            .setCustomId('add_award_modal')
                            .setTitle(`Add Award to ${user.raUsername}`);

                        // Add title input
                        const titleInput = new TextInputBuilder()
                            .setCustomId('title')
                            .setLabel('Award Title')
                            .setPlaceholder('Enter award title...')
                            .setStyle(TextInputStyle.Short)
                            .setRequired(true);

                        // Add points input
                        const pointsInput = new TextInputBuilder()
                            .setCustomId('points')
                            .setLabel('Points')
                            .setPlaceholder('Enter number of points...')
                            .setStyle(TextInputStyle.Short)
                            .setRequired(true);

                        // Add inputs to modal
                        const titleRow = new ActionRowBuilder().addComponents(titleInput);
                        const pointsRow = new ActionRowBuilder().addComponents(pointsInput);

                        modal.addComponents(titleRow, pointsRow);

                        // Show the modal
                        await i.showModal(modal);
                        
                        try {
                            // Wait for modal submission
                            const modalSubmission = await i.awaitModalSubmit({
                                time: 300000 // 5 minutes to fill out the form
                            });

                            await modalSubmission.deferUpdate();

                            // Extract values from the modal
                            const title = modalSubmission.fields.getTextInputValue('title');
                            const points = parseInt(modalSubmission.fields.getTextInputValue('points'));

                            if (isNaN(points) || points < 1) {
                                return modalSubmission.editReply('Invalid points value. Please enter a positive number.');
                            }

                            // Add the community award
                            user.communityAwards.push({
                                title,
                                points,
                                awardedBy: interaction.user.tag,
                                awardedAt: new Date()
                            });

                            await user.save();
                            
                            // Show the updated awards
                            await this.displayUserAwards(modalSubmission, user.raUsername);
                        } catch (modalError) {
                            console.error('Error handling modal submission:', modalError);
                            // Modal timed out or was cancelled
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Error displaying user awards:', error);
            await interaction.editReply('An error occurred while retrieving user awards. Please try again.');
        }
    },

    async handleClearAward(interaction, raUsername) {
        try {
            // Find the user
            const user = await User.findOne({
                raUsername: { $regex: new RegExp(`^${raUsername}import { 
    SlashCommandBuilder, 
    EmbedBuilder, 
    ActionRowBuilder, 
    StringSelectMenuBuilder,
    ButtonBuilder,
    ButtonStyle,
    ComponentType,
    ModalBuilder,
    TextInputBuilder,
    TextInputStyle,
    PermissionFlagsBits
} from 'discord.js';
import { User } from '../../models/User.js';
import { Challenge } from '../../models/Challenge.js';
import { ArcadeBoard } from '../../models/ArcadeBoard.js';
import { Poll } from '../../models/Poll.js';
import retroAPI from '../../services/retroAPI.js';
import { config } from '../../config/config.js';

// Constants
const MEMBER_ROLE_ID = '1316292690870014002';

export default {
    data: new SlashCommandBuilder()
        .setName('admin')
        .setDescription('Admin dashboard for managing all aspects of the community')
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild) // Require admin permissions
        // Challenge Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('challenge')
                .setDescription('Manage monthly and shadow challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('create')
                        .setDescription('Create or replace a monthly challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('shadow')
                        .setDescription('Add or edit a shadow challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('toggle')
                        .setDescription('Toggle shadow challenge visibility')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View current challenge details')
                )
        )
        
        // Arcade Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('arcade')
                .setDescription('Manage arcade boards and racing challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('add')
                        .setDescription('Add an arcade board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('racing')
                        .setDescription('Set up a racing challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('tiebreaker')
                        .setDescription('Create a tiebreaker board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Award points for a completed board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('announce')
                        .setDescription('Announce a board to the community')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View and manage existing boards')
                )
        )
        
        // User Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('user')
                .setDescription('Manage users, registrations, and awards')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('register')
                        .setDescription('Register a user')
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to register')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('unregister')
                        .setDescription('Unregister a user')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to unregister')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('purge')
                        .setDescription('Completely remove a user registration')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to purge')
                            .setRequired(true))
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to purge (optional)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Give a community award to a user')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('title')
                            .setDescription('The title of the award')
                            .setRequired(true))
                        .addIntegerOption(option =>
                            option.setName('points')
                            .setDescription('Number of points for this award')
                            .setRequired(true)
                            .setMinValue(1))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('awards')
                        .setDescription('View user awards')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('clear')
                        .setDescription('Clear nominations or awards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('reset')
                        .setDescription('Reset user achievements')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('RetroAchievements username')
                            .setRequired(true))
                )
        )
        
        // Voting Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('voting')
                .setDescription('Manage voting processes')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('start')
                        .setDescription('Start a voting poll')
                        .addChannelOption(option =>
                            option.setName('channel')
                            .setDescription('The channel to create the poll announcement in')
                            .setRequired(true))
                        .addChannelOption(option =>
                            option.setName('results_channel')
                            .setDescription('The channel to announce results in (defaults to same channel)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('cancel')
                        .setDescription('Cancel an active voting poll')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('status')
                        .setDescription('Check status of current voting')
                )
        )
        
        // System Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('system')
                .setDescription('System-level operations')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('update')
                        .setDescription('Force an update of all stats and leaderboards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('suggestions')
                        .setDescription('Manage community suggestions')
                )
        )
        
        // Info display subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('info')
                .setDescription('Display shareable information')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('arcade')
                        .setDescription('Display arcade board information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('challenges')
                        .setDescription('Display challenge information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('overview')
                        .setDescription('Display community overview')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('commands')
                        .setDescription('Display available commands')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('rules')
                        .setDescription('Display community rules')
                )
        ),

    async execute(interaction) {
        // Check if user has admin role
        if (!interaction.member.roles.cache.has(config.bot.roles.admin)) {
            return interaction.reply({
                content: 'You do not have permission to use this command.',
                ephemeral: true
            });
        }

        await interaction.deferReply({ ephemeral: true });

        try {
            // Extract subcommand group and subcommand
            const subcommandGroup = interaction.options.getSubcommandGroup();
            const subcommand = interaction.options.getSubcommand();
            
            // Route to the appropriate handler based on subcommand group and subcommand
            switch (subcommandGroup) {
                case 'challenge':
                    await this.handleChallengeCommand(interaction, subcommand);
                    break;
                case 'arcade':
                    await this.handleArcadeCommand(interaction, subcommand);
                    break;
                case 'user':
                    await this.handleUserCommand(interaction, subcommand);
                    break;
                case 'voting':
                    await this.handleVotingCommand(interaction, subcommand);
                    break;
                case 'system':
                    await this.handleSystemCommand(interaction, subcommand);
                    break;
                case 'info':
                    await this.handleInfoCommand(interaction, subcommand);
                    break;
                default:
                    await interaction.editReply('Invalid subcommand group.');
            }
        } catch (error) {
            console.error('Error executing admin command:', error);
            await interaction.editReply('An error occurred while processing your request.');
        }
    },

    // CHALLENGE MANAGEMENT HANDLERS
    async handleChallengeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'create':
                await this.handleCreateChallenge(interaction);
                break;
            case 'shadow':
                await this.handleShadowChallenge(interaction);
                break;
            case 'toggle':
                await this.handleToggleShadow(interaction);
                break;
            case 'view':
                await this.handleViewChallenge(interaction);
                break;
            default:
                await interaction.editReply('Invalid challenge subcommand.');
        }
    },

    async handleCreateChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Create Monthly Challenge')
            .setColor('#32CD32')
            .setDescription('Use this form to create or replace a monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'How to Find Achievement IDs',
                    value: 'Go to the game page on RetroAchievements, hover over an achievement, and note the ID number in the URL.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('create_challenge_form')
                    .setLabel('Open Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ®')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'create_challenge_form') {
                    // Create modal for challenge creation
                    const modal = new ModalBuilder()
                        .setCustomId('create_challenge_modal')
                        .setTitle('Create Monthly Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add year input
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Create date for the first of the specified month
                            const challengeDate = new Date(year, month - 1, 1);

                            // Check if a challenge already exists for this month
                            const existingChallenge = await Challenge.findOneAndDelete({
                                date: {
                                    $gte: challengeDate,
                                    $lt: new Date(year, month, 1)
                                }
                            });

                            // Create new challenge
                            const challenge = new Challenge({
                                date: challengeDate,
                                monthly_challange_gameid: gameId,
                                monthly_challange_progression_achievements: progressionAchievements,
                                monthly_challange_win_achievements: winAchievements,
                                monthly_challange_game_total: totalAchievements,
                                shadow_challange_revealed: false // Keep shadow challenge hidden by default
                            });

                            await challenge.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Monthly Challenge Created')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (existingChallenge) {
                                resultEmbed.setDescription(`Monthly challenge replaced for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: existingChallenge.monthly_challange_gameid.toString() },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Monthly challenge created for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('add_shadow')
                                        .setLabel('Add Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ‘¥'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'add_shadow') {
                                        await this.handleShadowChallenge(resultI, { month, year });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error creating challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while creating the challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to create a challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleShadowChallenge(interaction, prefilledData = null) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Shadow Challenge')
            .setColor('#9932CC') // Dark purple
            .setDescription('Use this form to add or edit a shadow challenge for a specific month.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'Shadow Challenge Rules',
                    value: 'Shadow challenges are hidden mysteries that players can discover by guessing or playing the challenge games. They automatically reveal for past months.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('shadow_challenge_form')
                    .setLabel('Open Shadow Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸ‘¥')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'shadow_challenge_form') {
                    // Create modal for shadow challenge
                    const modal = new ModalBuilder()
                        .setCustomId('shadow_challenge_modal')
                        .setTitle('Add Shadow Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input with prefilled data if available
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.month) {
                        monthInput.setValue(prefilledData.month.toString());
                    } else {
                        // Default to current month
                        const now = new Date();
                        monthInput.setValue((now.getMonth() + 1).toString());
                    }

                    // Add year input with prefilled data if available
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.year) {
                        yearInput.setValue(prefilledData.year.toString());
                    } else {
                        // Default to current year
                        const now = new Date();
                        yearInput.setValue(now.getFullYear().toString());
                    }

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get date range for the specified month
                            const monthStart = new Date(year, month - 1, 1);
                            const nextMonthStart = new Date(year, month, 1);

                            // Find the target challenge
                            const targetChallenge = await Challenge.findOne({
                                date: {
                                    $gte: monthStart,
                                    $lt: nextMonthStart
                                }
                            });

                            if (!targetChallenge) {
                                return modalSubmission.editReply(`No challenge exists for ${month}/${year}. Create a monthly challenge first using /admin challenge create.`);
                            }

                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Check if there's an existing shadow game to be replaced
                            let replacedShadowGame = null;
                            if (targetChallenge.shadow_challange_gameid) {
                                try {
                                    const oldGameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
                                    replacedShadowGame = oldGameInfo.title;
                                } catch (error) {
                                    console.error('Error fetching old shadow game info:', error);
                                    replacedShadowGame = targetChallenge.shadow_challange_gameid;
                                }
                            }

                            // Update the challenge with shadow game information
                            targetChallenge.shadow_challange_gameid = gameId;
                            targetChallenge.shadow_challange_progression_achievements = progressionAchievements;
                            targetChallenge.shadow_challange_win_achievements = winAchievements;
                            targetChallenge.shadow_challange_game_total = totalAchievements;
                            
                            // Automatically reveal shadow games for past months
                            const now = new Date();
                            if (month < now.getMonth() + 1 || year < now.getFullYear()) {
                                targetChallenge.shadow_challange_revealed = true;
                            } else if (!targetChallenge.shadow_challange_revealed) {
                                // For current or future months, keep shadow games hidden by default
                                targetChallenge.shadow_challange_revealed = false;
                            }

                            await targetChallenge.save();

                            // Get month name for display
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Determine if it was auto-revealed
                            const autoRevealed = (month < now.getMonth() + 1 || year < now.getFullYear());
                            
                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#9932CC') // Dark purple for shadow challenges
                                .setTitle('Shadow Challenge Added')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (replacedShadowGame) {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} replaced`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: replacedShadowGame },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} created`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() },
                                { name: 'Visibility', value: targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden' + (autoRevealed ? ' (Auto-revealed as past challenge)' : '') }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('toggle_shadow')
                                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'toggle_shadow') {
                                        await this.handleToggleShadow(resultI, { month, year, force: true });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding shadow challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the shadow challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a shadow challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleToggleShadow(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            let force = options?.force || false;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                const now = new Date();
                month = now.getMonth() + 1; // 1-indexed month
                year = now.getFullYear();
            }
            
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the target challenge
            const targetChallenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!targetChallenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            if (!targetChallenge.shadow_challange_gameid) {
                return interaction.editReply(`No shadow challenge has been set for ${month}/${year}.`);
            }

            // Toggle the visibility
            targetChallenge.shadow_challange_revealed = !targetChallenge.shadow_challange_revealed;
            await targetChallenge.save();

            // Get game info for the response
            const gameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
            
            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Create response embed
            const resultEmbed = new EmbedBuilder()
                .setColor(targetChallenge.shadow_challange_revealed ? '#00FF00' : '#FF0000') // Green for revealed, red for hidden
                .setTitle(`Shadow Challenge ${targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden'}`)
                .setDescription(`The shadow challenge for ${monthName} ${year} is now ${targetChallenge.shadow_challange_revealed ? 'REVEALED' : 'HIDDEN'}.`)
                .setTimestamp();

            if (targetChallenge.shadow_challange_revealed) {
                resultEmbed.addFields(
                    { name: 'Game', value: gameInfo.title },
                    { name: 'Required Progression Achievements', value: targetChallenge.shadow_challange_progression_achievements.length.toString() },
                    { name: 'Required Win Achievements', value: targetChallenge.shadow_challange_win_achievements.length > 0 ? targetChallenge.shadow_challange_win_achievements.length.toString() : 'None' }
                );
                
                if (gameInfo.imageIcon) {
                    resultEmbed.setThumbnail(`https://retroachievements.org${gameInfo.imageIcon}`);
                }
            }

            // Add action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow_again')
                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                    new ButtonBuilder()
                        .setCustomId('view_challenge')
                        .setLabel('View Challenge Details')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ”')
                );

            // If we're force-updating from another command, use editReply
            // Otherwise, use standard reply
            if (force) {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            } else {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            }

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'toggle_shadow_again') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    } else if (i.customId === 'view_challenge') {
                        await this.handleViewChallenge(i, { month, year });
                    }
                }
            });

        } catch (error) {
            console.error('Error toggling shadow challenge visibility:', error);
            await interaction.editReply('An error occurred while toggling the shadow challenge visibility. Please try again.');
        }
    },

    async handleViewChallenge(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                // Open a form to select month/year
                const embed = new EmbedBuilder()
                    .setTitle('View Challenge Details')
                    .setColor('#3498DB')
                    .setDescription('Please select which challenge you want to view.')
                    .addFields(
                        {
                            name: 'Options',
                            value: 'You can view the current month\'s challenge or select a specific month.'
                        }
                    );

                // Create buttons
                const row = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('view_current_challenge')
                            .setLabel('Current Month')
                            .setStyle(ButtonStyle.Primary)
                            .setEmoji('ðŸ“…'),
                        new ButtonBuilder()
                            .setCustomId('select_month_challenge')
                            .setLabel('Select Month')
                            .setStyle(ButtonStyle.Secondary)
                            .setEmoji('ðŸ”')
                    );

                await interaction.editReply({
                    embeds: [embed],
                    components: [row]
                });

                // Set up collector for the buttons
                const message = await interaction.fetchReply();
                const buttonCollector = message.createMessageComponentCollector({
                    componentType: ComponentType.Button,
                    time: 300000 // 5 minutes timeout
                });

                buttonCollector.on('collect', async i => {
                    if (i.user.id === interaction.user.id) {
                        await i.deferUpdate();

                        if (i.customId === 'view_current_challenge') {
                            // Use current month
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                            
                            // Continue with viewing the challenge
                            await this.displayChallengeDetails(i, month, year);
                            
                            // Stop the collector
                            buttonCollector.stop();
                        } else if (i.customId === 'select_month_challenge') {
                            // Show modal to select month/year
                            const modal = new ModalBuilder()
                                .setCustomId('select_challenge_month_modal')
                                .setTitle('Select Challenge Month');

                            // Add month input
                            const monthInput = new TextInputBuilder()
                                .setCustomId('month')
                                .setLabel('Month (1-12)')
                                .setPlaceholder('Example: 5 (for May)')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add year input
                            const yearInput = new TextInputBuilder()
                                .setCustomId('year')
                                .setLabel('Year')
                                .setPlaceholder('Example: 2025')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add inputs to modal
                            const monthRow = new ActionRowBuilder().addComponents(monthInput);
                            const yearRow = new ActionRowBuilder().addComponents(yearInput);

                            modal.addComponents(monthRow, yearRow);

                            // Show the modal
                            await i.showModal(modal);

                            try {
                                // Wait for modal submission
                                const modalSubmission = await i.awaitModalSubmit({
                                    time: 300000 // 5 minutes to fill out the form
                                });

                                await modalSubmission.deferUpdate();

                                // Extract values from the modal
                                month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                                year = parseInt(modalSubmission.fields.getTextInputValue('year'));

                                // Validate inputs
                                if (isNaN(month) || month < 1 || month > 12) {
                                    return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                                }

                                if (isNaN(year) || year < 2000 || year > 2100) {
                                    return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                                }

                                // Continue with viewing the challenge
                                await this.displayChallengeDetails(modalSubmission, month, year);
                                
                                // Stop the collector
                                buttonCollector.stop();

                            } catch (modalError) {
                                console.error('Error handling modal submission:', modalError);
                                // Modal timed out or was cancelled
                            }
                        }
                    }
                });

                // Let the function end here and let the collector handle the rest
                return;
            }

            // If we have month/year, display the challenge
            await this.displayChallengeDetails(interaction, month, year);

        } catch (error) {
            console.error('Error viewing challenge:', error);
            await interaction.editReply('An error occurred while viewing the challenge. Please try again.');
        }
    },

    async displayChallengeDetails(interaction, month, year) {
        try {
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the challenge
            const challenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!challenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Get game info for monthly challenge
            let monthlyGameInfo = null;
            if (challenge.monthly_challange_gameid) {
                monthlyGameInfo = await retroAPI.getGameInfo(challenge.monthly_challange_gameid);
            }

            // Get game info for shadow challenge if revealed
            let shadowGameInfo = null;
            if (challenge.shadow_challange_gameid && challenge.shadow_challange_revealed) {
                shadowGameInfo = await retroAPI.getGameInfo(challenge.shadow_challange_gameid);
            }

            // Create main embed
            const embed = new EmbedBuilder()
                .setTitle(`Challenge Details: ${monthName} ${year}`)
                .setColor('#3498DB')
                .setDescription(`Here are the details for the ${monthName} ${year} challenges:`)
                .setTimestamp();

            // Add monthly challenge info
            if (monthlyGameInfo) {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: `**Game:** ${monthlyGameInfo.title}\n` +
                          `**Required Progression Achievements:** ${challenge.monthly_challange_progression_achievements.length}\n` +
                          `**Required Win Achievements:** ${challenge.monthly_challange_win_achievements.length}\n` +
                          `**Total Achievements:** ${challenge.monthly_challange_game_total}\n` +
                          `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.monthly_challange_gameid})`
                });

                if (monthlyGameInfo.imageIcon) {
                    embed.setThumbnail(`https://retroachievements.org${monthlyGameInfo.imageIcon}`);
                }
            } else {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: 'No monthly challenge set.'
                });
            }

            // Add shadow challenge info
            if (challenge.shadow_challange_gameid) {
                if (challenge.shadow_challange_revealed && shadowGameInfo) {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (REVEALED)',
                        value: `**Game:** ${shadowGameInfo.title}\n` +
                              `**Required Progression Achievements:** ${challenge.shadow_challange_progression_achievements.length}\n` +
                              `**Required Win Achievements:** ${challenge.shadow_challange_win_achievements.length}\n` +
                              `**Total Achievements:** ${challenge.shadow_challange_game_total}\n` +
                              `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.shadow_challange_gameid})`
                    });
                } else {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (HIDDEN)',
                        value: 'Shadow challenge exists but is currently hidden.\n' +
                              `Use \`/admin challenge toggle\` to reveal it.`
                    });
                }
            } else {
                embed.addFields({
                    name: 'ðŸ‘¥ Shadow Challenge',
                    value: 'No shadow challenge set.\n' +
                          `Use \`/admin challenge shadow\` to add one.`
                });
            }

            // Create action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('edit_monthly')
                        .setLabel('Edit Monthly Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('ðŸ†'),
                    new ButtonBuilder()
                        .setCustomId('edit_shadow')
                        .setLabel(challenge.shadow_challange_gameid ? 'Edit Shadow Challenge' : 'Add Shadow Challenge')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ‘¥')
                );

            // Add toggle button if shadow challenge exists
            if (challenge.shadow_challange_gameid) {
                actionRow.addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow')
                        .setLabel(challenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji(challenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸')
                );
            }

            await interaction.editReply({
                embeds: [embed],
                components: [actionRow]
            });

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'edit_monthly') {
                        await this.handleCreateChallenge(i);
                    } else if (i.customId === 'edit_shadow') {
                        await this.handleShadowChallenge(i, { month, year });
                    } else if (i.customId === 'toggle_shadow') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    }
                }
            });

        } catch (error) {
            console.error('Error displaying challenge details:', error);
            await interaction.editReply('An error occurred while retrieving challenge details. Please try again.');
        }
    },

    // ARCADE MANAGEMENT HANDLERS
    async handleArcadeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'add':
                await this.handleAddArcadeBoard(interaction);
                break;
            case 'racing':
                await this.handleAddRacingChallenge(interaction);
                break;
            case 'tiebreaker':
                await this.handleAddTiebreaker(interaction);
                break;
            case 'award':
                await this.handleAwardPoints(interaction);
                break;
            case 'announce':
                await this.handleAnnounceBoard(interaction);
                break;
            case 'view':
                await this.handleViewBoards(interaction);
                break;
            default:
                await interaction.editReply('Invalid arcade subcommand.');
        }
    },

    async handleAddArcadeBoard(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Arcade Board')
            .setColor('#9B59B6') // Purple
            .setDescription('Use this form to add a new arcade board to the community.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Board ID (unique identifier)\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description'
                },
                {
                    name: 'How to Find IDs',
                    value: '**Game ID**: The number at the end of the game URL on RetroAchievements\n**Leaderboard ID**: The number at the end of the leaderboard URL'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_arcade_form')
                    .setLabel('Open Arcade Board Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ¯')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_arcade_form') {
                    // Create modal for arcade board
                    const modal = new ModalBuilder()
                        .setCustomId('add_arcade_modal')
                        .setTitle('Add Arcade Board');

                    // Add board ID input
                    const boardIdInput = new TextInputBuilder()
                        .setCustomId('board_id')
                        .setLabel('Board ID (unique identifier)')
                        .setPlaceholder('Example: sonic3-special-stages')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this arcade board challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add inputs to modal
                    const boardIdRow = new ActionRowBuilder().addComponents(boardIdInput);
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);

                    modal.addComponents(boardIdRow, gameIdRow, leaderboardIdRow, descriptionRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const boardId = modalSubmission.fields.getTextInputValue('board_id');
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        try {
                            // Check if board ID already exists
                            const existingBoard = await ArcadeBoard.findOne({ boardId });
                            if (existingBoard) {
                                return modalSubmission.editReply(`A board with ID "${boardId}" already exists.`);
                            }

                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Create new board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'arcade',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description
                            });

                            await newBoard.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Arcade Board Added')
                                .setDescription(`Successfully added "${gameInfo.title}" arcade board!`)
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .addFields(
                                    { name: 'Board ID', value: boardId },
                                    { name: 'Game', value: gameInfo.title },
                                    { name: 'Console', value: gameInfo.consoleName || 'Unknown' },
                                    { name: 'Description', value: description }
                                )
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_board')
                                        .setLabel('Announce Board')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_board') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding arcade board:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the arcade board. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add an arcade board.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddRacingChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Racing Challenge')
            .setColor('#FF9900') // Orange
            .setDescription('Use this form to set up a monthly racing challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Track Name\nâ€¢ Description\nâ€¢ Month and Year (optional, defaults to current month)'
                },
                {
                    name: 'Racing Challenge Rules',
                    value: 'Racing challenges are monthly competitions where players compete on time-based leaderboards. The top 3 players will receive community points.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_racing_form')
                    .setLabel('Open Racing Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_racing_form') {
                    // Create modal for racing challenge
                    const modal = new ModalBuilder()
                        .setCustomId('add_racing_modal')
                        .setTitle('Add Racing Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add track name input
                    const trackNameInput = new TextInputBuilder()
                        .setCustomId('track_name')
                        .setLabel('Track Name')
                        .setPlaceholder('Example: Rainbow Road')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this racing challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add month/year input
                    const monthYearInput = new TextInputBuilder()
                        .setCustomId('month_year')
                        .setLabel('Month and Year (optional, MM/YYYY format)')
                        .setPlaceholder('Example: 05/2025 (defaults to current month)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const trackNameRow = new ActionRowBuilder().addComponents(trackNameInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthYearInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, trackNameRow, descriptionRow, monthYearRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const trackName = modalSubmission.fields.getTextInputValue('track_name');
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const monthYearInput = modalSubmission.fields.getTextInputValue('month_year');

                        // Parse month and year
                        let month, year;
                        if (monthYearInput && monthYearInput.trim()) {
                            const parts = monthYearInput.split('/');
                            if (parts.length === 2) {
                                month = parseInt(parts[0]);
                                year = parseInt(parts[1]);
                            } else {
                                // Invalid format, use current month/year
                                const now = new Date();
                                month = now.getMonth() + 1;
                                year = now.getFullYear();
                            }
                        } else {
                            // No input, use current month/year
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                        }

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Calculate start and end dates
                            // Start at beginning of specified month
                            const startDate = new Date(year, month - 1, 1);
                            
                            // End at the end of the specified month (23:59:59 on the last day)
                            const endDate = new Date(year, month, 0, 23, 59, 59);
                            
                            // Check if a racing challenge already exists for this month
                            const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                            const existingChallenge = await ArcadeBoard.findOne({
                                boardType: 'racing',
                                monthKey
                            });

                            if (existingChallenge) {
                                return modalSubmission.editReply(`A racing challenge already exists for ${monthKey}.`);
                            }

                            // Generate a unique board ID specifically for racing
                            // This format ensures no overlap with regular arcade boards
                            const boardId = `racing-${monthKey}`;

                            // Get the full game title and console name
                            const gameFull = `${gameInfo.title} (${gameInfo.consoleName})`;

                            // Create new racing board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'racing',
                                leaderboardId,
                                gameId,
                                gameTitle: gameFull,
                                trackName,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate,
                                endDate,
                                monthKey
                            });

                            await newBoard.save();

                            // Get month name for response
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF9900') // Orange for racing
                                .setTitle(`Racing Challenge Created: ${monthName} ${year}`)
                                .setDescription(
                                    `**Game:** ${gameFull}\n` +
                                    `**Track:** ${trackName}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Challenge Period:** ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `The top 3 players at the end of the month will receive award points!`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_racing')
                                        .setLabel('Announce Racing Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_racing') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding racing challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the racing challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a racing challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddTiebreaker(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Tiebreaker')
            .setColor('#FF0000') // Red
            .setDescription('Use this form to create a tiebreaker leaderboard for the monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description\nâ€¢ End Date (YYYY-MM-DD format)'
                },
                {
                    name: 'Tiebreaker Rules',
                    value: 'Tiebreakers are used to resolve ties in the monthly challenge leaderboard. Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_tiebreaker_form')
                    .setLabel('Open Tiebreaker Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('âš”ï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_tiebreaker_form') {
                    // Create modal for tiebreaker
                    const modal = new ModalBuilder()
                        .setCustomId('add_tiebreaker_modal')
                        .setTitle('Add Tiebreaker');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this tiebreaker challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add end date input
                    const endDateInput = new TextInputBuilder()
                        .setCustomId('end_date')
                        .setLabel('End Date (YYYY-MM-DD format)')
                        .setPlaceholder('Example: 2025-05-31')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const endDateRow = new ActionRowBuilder().addComponents(endDateInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, descriptionRow, endDateRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const endDateStr = modalSubmission.fields.getTextInputValue('end_date');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        // Parse end date
                        const endDate = new Date(endDateStr);
                        if (isNaN(endDate.getTime())) {
                            return modalSubmission.editReply('Invalid end date format. Please use YYYY-MM-DD.');
                        }

                        // Set end time to 23:59:59
                        endDate.setHours(23, 59, 59);

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Check if an active tiebreaker already exists
                            const now = new Date();
                            const activeTiebreaker = await ArcadeBoard.findOne({
                                boardType: 'tiebreaker',
                                startDate: { $lte: now },
                                endDate: { $gte: now }
                            });

                            if (activeTiebreaker) {
                                return modalSubmission.editReply('An active tiebreaker already exists. Please end it before creating a new one.');
                            }

                            // Generate a unique board ID based on month and year
                            const monthYear = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}`;
                            const boardId = `tiebreaker-${monthYear}`;

                            // Create new tiebreaker board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'tiebreaker',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate: now,
                                endDate,
                                // Add monthKey for consistency with racing challenges
                                monthKey: monthYear
                            });

                            await newBoard.save();

                            // Get the month name
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[now.getMonth()];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF0000') // Red for tiebreaker
                                .setTitle(`âš”ï¸ Tiebreaker Created: ${monthName} ${now.getFullYear()}`)
                                .setDescription(
                                    `**Game:** ${gameInfo.title}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Tiebreaker Period:** ${now.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `This tiebreaker will be used to resolve ties in the ${monthName} monthly challenge leaderboard. ` +
                                    `Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_tiebreaker')
                                        .setLabel('Announce Tiebreaker')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_tiebreaker') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding tiebreaker:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the tiebreaker. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a tiebreaker.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAwardPoints(interaction) {
        // Create select board form
        const embed = new EmbedBuilder()
            .setTitle('Award Points')
            .setColor('#32CD32') // Lime green
            .setDescription('Select a board to award points for.')
            .addFields(
                {
                    name: 'Award Points',
                    value: 'You can award points for completed racing challenges or arcade boards. For racing challenges, points are awarded to the top 3 players. For arcade boards, points are awarded annually.'
                }
            );

        // Find all racing boards and tiebreakers
        const racingBoards = await ArcadeBoard.find({ 
            boardType: 'racing',
            pointsAwarded: { $ne: true } // Only show boards that haven't been awarded points yet
        }).sort({ startDate: -1 });

        // Create options for racing boards
        const boardOptions = racingBoards.map(board => {
            const monthYear = board.monthKey || 'Unknown Date';
            return {
                label: `Racing: ${board.gameTitle}${board.trackName ? ` - ${board.trackName}` : ''}`,
                description: `${monthYear}`,
                value: `racing-${board.boardId}`
            };
        });

        // Add option for annual arcade awards if any arcade boards exist
        const arcadeBoards = await ArcadeBoard.find({ boardType: 'arcade' });
        if (arcadeBoards.length > 0) {
            boardOptions.push({
                label: 'Annual Arcade Awards',
                description: 'Award points for all arcade boards for the current year',
                value: 'arcade-annual'
            });
        }

        // Create dropdown if we have options
        if (boardOptions.length === 0) {
            return interaction.editReply('No eligible boards found for awarding points. All racing challenges have already been awarded points, or no racing challenges exist.');
        }

        // Create the dropdown
        const row = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('select_board_for_award')
                    .setPlaceholder('Select a board to award points')
                    .addOptions(boardOptions)
            );

        // Send the selection menu
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the dropdown selection
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.StringSelect,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                await i.deferUpdate();
                
                const selectedValue = i.values[0];
                
                if (selectedValue.startsWith('racing-')) {
                    // Extract board ID
                    const boardId = selectedValue.substring(7);
                    await this.awardRacingPoints(i, boardId);
                } else if (selectedValue === 'arcade-annual') {
                    await this.awardArcadePoints(i);
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        StringSelectMenuBuilder.from(row.components[0])
                            .setDisabled(true)
                            .setPlaceholder('Selection timed out')
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This selection has expired. Please run the command again if you still need to award points.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling dropdown:', error);
                }
            }
        });
    },

    async awardRacingPoints(interaction, boardId) {
        try {
            // Find the racing board
            const racingBoard = await ArcadeBoard.findOne({ 
                boardId,
                boardType: 'racing'
            });

            if (!racingBoard) {
                return interaction.editReply(`Racing board with ID "${boardId}" not found.`);
            }

            // Check if points have already been awarded
            if (racingBoard.pointsAwarded) {
                return interaction.editReply(`Points have already been awarded for this racing challenge.`);
            }

            // Check if the racing challenge has ended
            const now = new Date();
            if (racingBoard.endDate > now) {
                return interaction.editReply(`This racing challenge hasn't ended yet. It ends on ${racingBoard.endDate.toLocaleDateString()}.`);
            }

, 'i') }
            });

            if (!user) {
                return interaction.editReply(`User "${raUsername}" not found. Please check the username.`);
            }

            // Check if the user has any awards
            if (!user.communityAwards || user.communityAwards.length === 0) {
                return interaction.editReply(`User "${user.raUsername}" has no community awards to remove.`);
            }

            // Create index selection for awards
            const embed = new EmbedBuilder()
                .setTitle(`Select Award to Remove: ${user.raUsername}`)
                .setColor('#FF0000') // Red for danger
                .setDescription('Select the award you want to remove from this user.')
                .setTimestamp();
                
            // Create options for the dropdown
            const awardOptions = user.communityAwards.map((award, index) => {
                return {
                    label: `${index + 1}. ${award.title}`,
                    description: `${award.points} points - Awarded by ${award.awardedBy || 'System'}`,
                    value: index.toString()
                };
            });
            
            // Create the dropdown
            const row = new ActionRowBuilder()
                .addComponents(
                    new StringSelectMenuBuilder()
                        .setCustomId('select_award_to_remove')
                        .setPlaceholder('Select an award to remove')
                        .addOptions(awardOptions)
                );
                
            // Add cancel button
            const cancelRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('cancel_clear_award')
                        .setLabel('Cancel')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('âŒ')
                );
                
            await interaction.editReply({
                embeds: [embed],
                components: [row, cancelRow]
            });
            
            // Set up collector for the interactions
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                time: 300000 // 5 minutes timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'select_award_to_remove') {
                        const awardIndex = parseInt(i.values[0]);
                        
                        // Store the award details for confirmation
                        const award = user.communityAwards[awardIndex];
                        const awardTitle = award.title;
                        const awardPoints = award.points;
                        
                        // Create confirmation embed
                        const confirmEmbed = new EmbedBuilder()
                            .setTitle('Confirm Award Removal')
                            .setColor('#FF0000') // Red for danger
                            .setDescription(`Are you sure you want to remove this award from ${user.raUsername}?`)
                            .addFields(
                                {
                                    name: 'Award Details',
                                    value: `**Title:** ${awardTitle}\n` +
                                           `**Points:** ${awardPoints}\n` +
                                           `**Awarded By:** ${award.awardedBy || 'System'}\n` +
                                           `**Date:** ${award.awardedAt ? new Date(award.awardedAt).toLocaleDateString() : 'Unknown'}`
                                }
                            )
                            .setTimestamp();
                            
                        // Create confirmation buttons
                        const confirmRow = new ActionRowBuilder()
                            .addComponents(
                                new ButtonBuilder()
                                    .setCustomId(`confirm_remove_award_${awardIndex}`)
                                    .setLabel('Remove Award')
                                    .setStyle(ButtonStyle.Danger)
                                    .setEmoji('âœ…'),
                                new ButtonBuilder()
                                    .setCustomId('cancel_remove_award')
                                    .setLabel('Cancel')
                                    .setStyle(ButtonStyle.Secondary)
                                    .setEmoji('âŒ')
                            );
                            
                        await i.editReply({
                            embeds: [confirmEmbed],
                            components: [confirmRow]
                        });
                    } else if (i.customId === 'cancel_clear_award') {
                        // Go back to awards view
                        await this.displayUserAwards(i, raUsername);
                    } else if (i.customId.startsWith('confirm_remove_award_')) {
                        // Extract the award index from the button ID
                        const awardIndex = parseInt(i.customId.split('_').pop());
                        
                        // Store the award details for confirmation
                        const award = user.communityAwards[awardIndex];
                        const awardTitle = award.title;
                        const awardPoints = award.points;
                        
                        // Remove the award from the array
                        user.communityAwards.splice(awardIndex, 1);
                        await user.save();
                        
                        // Show success message
                        const successEmbed = new EmbedBuilder()
                            .setColor('#00FF00') // Green for success
                            .setTitle('Award Removed')
                            .setDescription(`Successfully removed award "${awardTitle}" (${awardPoints} points) from ${user.raUsername}.`)
                            .setTimestamp();
                            
                        await i.editReply({
                            embeds: [successEmbed],
                            components: []
                        });
                        
                        // Add a button to view all awards
                        const viewRow = new ActionRowBuilder()
                            .addComponents(
                                new ButtonBuilder()
                                    .setCustomId('view_all_awards')
                                    .setLabel('View All Awards')
                                    .setStyle(ButtonStyle.Primary)
                                    .setEmoji('ðŸ”')
                            );
                            
                        // Add the button after a short delay
                        setTimeout(async () => {
                            try {
                                await i.editReply({
                                    embeds: [successEmbed],
                                    components: [viewRow]
                                });
                                
                                // Set up collector for the view button
                                const viewMessage = await i.fetchReply();
                                const viewCollector = viewMessage.createMessageComponentCollector({
                                    componentType: ComponentType.Button,
                                    time: 60000 // 1 minute timeout
                                });
                                
                                viewCollector.on('collect', async viewI => {
                                    if (viewI.user.id === interaction.user.id) {
                                        await viewI.deferUpdate();
                                        
                                        if (viewI.customId === 'view_all_awards') {
                                            await this.displayUserAwards(viewI, raUsername);
                                        }
                                    }
                                });
                            } catch (error) {
                                console.error('Error adding view button:', error);
                            }
                        }, 2000);
                        
                    } else if (i.customId === 'cancel_remove_award') {
                        // Go back to awards view
                        await this.displayUserAwards(i, raUsername);
                    }
                }
            });
        } catch (error) {
            console.error('Error clearing user award:', error);
            await interaction.editReply('An error occurred while removing the award. Please try again.');
        }
    },

    async handleClearUserData(interaction) {
        // Create options selection for clearing user data
        const embed = new EmbedBuilder()
            .setTitle('Clear User Data')
            .setColor('#FF0000') // Red for danger
            .setDescription('Select which type of user data you want to clear.')
            .addFields(
                {
                    name: 'Available Options',
                    value: 'â€¢ Clear Nominations: Remove a user\'s current nominations\n' +
                           'â€¢ Clear User Awards: Remove specific awards from a user\n' +
                           'â€¢ Reset Achievements: Reset a user\'s achievement announcement history'
                }
            )
            .setTimestamp();
            
        // Create option buttons
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('clear_nominations')
                    .setLabel('Clear Nominations')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji('ðŸ—³ï¸'),
                new ButtonBuilder()
                    .setCustomId('clear_user_awards')
                    .setLabel('Clear User Awards')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji('ðŸ†'),
                new ButtonBuilder()
                    .setCustomId('reset_achievements')
                    .setLabel('Reset Achievements')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji('ðŸŽ®')
            );
            
        await interaction.editReply({
            embeds: [embed],
            components: [row]
        });
        
        // Set up collector for the button interactions
        const message = await interaction.fetchReply();
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });
        
        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                await i.deferUpdate();
                
                if (i.customId === 'clear_nominations') {
                    await this.handleClearNominations(i);
                } else if (i.customId === 'clear_user_awards') {
                    // Create modal for username input
                    const modal = new ModalBuilder()
                        .setCustomId('clear_awards_username_modal')
                        .setTitle('Clear User Awards');

                    // Add username input
                    const usernameInput = new TextInputBuilder()
                        .setCustomId('username')
                        .setLabel('RetroAchievements Username')
                        .setPlaceholder('Enter RA username...')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add inputs to modal
                    const usernameRow = new ActionRowBuilder().addComponents(usernameInput);

                    modal.addComponents(usernameRow);

                    // Show the modal
                    await i.showModal(modal);
                    
                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract username from the modal
                        const username = modalSubmission.fields.getTextInputValue('username');
                        
                        // Display user awards for clearing
                        await this.displayUserAwards(modalSubmission, username);
                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                } else if (i.customId === 'reset_achievements') {
                    await this.handleResetAchievements(i);
                }
            }
        });
    },

    async handleClearNominations(interaction) {
        // Create username input form
        const modal = new ModalBuilder()
            .setCustomId('clear_nominations_modal')
            .setTitle('Clear User Nominations');

        // Add username input
        const usernameInput = new TextInputBuilder()
            .setCustomId('username')
            .setLabel('RetroAchievements Username')
            .setPlaceholder('Enter RA username...')
            .setStyle(TextInputStyle.Short)
            .setRequired(true);

        // Add inputs to modal
        const usernameRow = new ActionRowBuilder().addComponents(usernameInput);
        modal.addComponents(usernameRow);

        // Show the modal
        await interaction.showModal(modal);
        
        try {
            // Wait for modal submission
            const modalSubmission = await interaction.awaitModalSubmit({
                time: 300000 // 5 minutes to fill out the form
            });

            await modalSubmission.deferUpdate();

            // Extract username from the modal
            const raUsername = modalSubmission.fields.getTextInputValue('username');
            
            // Find the user
            const user = await User.findOne({
                raUsername: { $regex: new RegExp(`^${raUsername}import { 
    SlashCommandBuilder, 
    EmbedBuilder, 
    ActionRowBuilder, 
    StringSelectMenuBuilder,
    ButtonBuilder,
    ButtonStyle,
    ComponentType,
    ModalBuilder,
    TextInputBuilder,
    TextInputStyle,
    PermissionFlagsBits
} from 'discord.js';
import { User } from '../../models/User.js';
import { Challenge } from '../../models/Challenge.js';
import { ArcadeBoard } from '../../models/ArcadeBoard.js';
import { Poll } from '../../models/Poll.js';
import retroAPI from '../../services/retroAPI.js';
import { config } from '../../config/config.js';

// Constants
const MEMBER_ROLE_ID = '1316292690870014002';

export default {
    data: new SlashCommandBuilder()
        .setName('admin')
        .setDescription('Admin dashboard for managing all aspects of the community')
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild) // Require admin permissions
        // Challenge Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('challenge')
                .setDescription('Manage monthly and shadow challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('create')
                        .setDescription('Create or replace a monthly challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('shadow')
                        .setDescription('Add or edit a shadow challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('toggle')
                        .setDescription('Toggle shadow challenge visibility')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View current challenge details')
                )
        )
        
        // Arcade Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('arcade')
                .setDescription('Manage arcade boards and racing challenges')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('add')
                        .setDescription('Add an arcade board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('racing')
                        .setDescription('Set up a racing challenge')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('tiebreaker')
                        .setDescription('Create a tiebreaker board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Award points for a completed board')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('announce')
                        .setDescription('Announce a board to the community')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('view')
                        .setDescription('View and manage existing boards')
                )
        )
        
        // User Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('user')
                .setDescription('Manage users, registrations, and awards')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('register')
                        .setDescription('Register a user')
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to register')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('unregister')
                        .setDescription('Unregister a user')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to unregister')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('purge')
                        .setDescription('Completely remove a user registration')
                        .addStringOption(option =>
                            option.setName('ra_username')
                            .setDescription('The RetroAchievements username to purge')
                            .setRequired(true))
                        .addUserOption(option =>
                            option.setName('discord_user')
                            .setDescription('The Discord user to purge (optional)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('award')
                        .setDescription('Give a community award to a user')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                        .addStringOption(option =>
                            option.setName('title')
                            .setDescription('The title of the award')
                            .setRequired(true))
                        .addIntegerOption(option =>
                            option.setName('points')
                            .setDescription('Number of points for this award')
                            .setRequired(true)
                            .setMinValue(1))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('awards')
                        .setDescription('View user awards')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('The RetroAchievements username')
                            .setRequired(true))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('clear')
                        .setDescription('Clear nominations or awards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('reset')
                        .setDescription('Reset user achievements')
                        .addStringOption(option =>
                            option.setName('username')
                            .setDescription('RetroAchievements username')
                            .setRequired(true))
                )
        )
        
        // Voting Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('voting')
                .setDescription('Manage voting processes')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('start')
                        .setDescription('Start a voting poll')
                        .addChannelOption(option =>
                            option.setName('channel')
                            .setDescription('The channel to create the poll announcement in')
                            .setRequired(true))
                        .addChannelOption(option =>
                            option.setName('results_channel')
                            .setDescription('The channel to announce results in (defaults to same channel)')
                            .setRequired(false))
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('cancel')
                        .setDescription('Cancel an active voting poll')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('status')
                        .setDescription('Check status of current voting')
                )
        )
        
        // System Management subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('system')
                .setDescription('System-level operations')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('update')
                        .setDescription('Force an update of all stats and leaderboards')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('suggestions')
                        .setDescription('Manage community suggestions')
                )
        )
        
        // Info display subcommand group
        .addSubcommandGroup(group => 
            group
                .setName('info')
                .setDescription('Display shareable information')
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('arcade')
                        .setDescription('Display arcade board information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('challenges')
                        .setDescription('Display challenge information')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('overview')
                        .setDescription('Display community overview')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('commands')
                        .setDescription('Display available commands')
                )
                .addSubcommand(subcommand => 
                    subcommand
                        .setName('rules')
                        .setDescription('Display community rules')
                )
        ),

    async execute(interaction) {
        // Check if user has admin role
        if (!interaction.member.roles.cache.has(config.bot.roles.admin)) {
            return interaction.reply({
                content: 'You do not have permission to use this command.',
                ephemeral: true
            });
        }

        await interaction.deferReply({ ephemeral: true });

        try {
            // Extract subcommand group and subcommand
            const subcommandGroup = interaction.options.getSubcommandGroup();
            const subcommand = interaction.options.getSubcommand();
            
            // Route to the appropriate handler based on subcommand group and subcommand
            switch (subcommandGroup) {
                case 'challenge':
                    await this.handleChallengeCommand(interaction, subcommand);
                    break;
                case 'arcade':
                    await this.handleArcadeCommand(interaction, subcommand);
                    break;
                case 'user':
                    await this.handleUserCommand(interaction, subcommand);
                    break;
                case 'voting':
                    await this.handleVotingCommand(interaction, subcommand);
                    break;
                case 'system':
                    await this.handleSystemCommand(interaction, subcommand);
                    break;
                case 'info':
                    await this.handleInfoCommand(interaction, subcommand);
                    break;
                default:
                    await interaction.editReply('Invalid subcommand group.');
            }
        } catch (error) {
            console.error('Error executing admin command:', error);
            await interaction.editReply('An error occurred while processing your request.');
        }
    },

    // CHALLENGE MANAGEMENT HANDLERS
    async handleChallengeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'create':
                await this.handleCreateChallenge(interaction);
                break;
            case 'shadow':
                await this.handleShadowChallenge(interaction);
                break;
            case 'toggle':
                await this.handleToggleShadow(interaction);
                break;
            case 'view':
                await this.handleViewChallenge(interaction);
                break;
            default:
                await interaction.editReply('Invalid challenge subcommand.');
        }
    },

    async handleCreateChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Create Monthly Challenge')
            .setColor('#32CD32')
            .setDescription('Use this form to create or replace a monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'How to Find Achievement IDs',
                    value: 'Go to the game page on RetroAchievements, hover over an achievement, and note the ID number in the URL.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('create_challenge_form')
                    .setLabel('Open Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ®')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'create_challenge_form') {
                    // Create modal for challenge creation
                    const modal = new ModalBuilder()
                        .setCustomId('create_challenge_modal')
                        .setTitle('Create Monthly Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add year input
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Create date for the first of the specified month
                            const challengeDate = new Date(year, month - 1, 1);

                            // Check if a challenge already exists for this month
                            const existingChallenge = await Challenge.findOneAndDelete({
                                date: {
                                    $gte: challengeDate,
                                    $lt: new Date(year, month, 1)
                                }
                            });

                            // Create new challenge
                            const challenge = new Challenge({
                                date: challengeDate,
                                monthly_challange_gameid: gameId,
                                monthly_challange_progression_achievements: progressionAchievements,
                                monthly_challange_win_achievements: winAchievements,
                                monthly_challange_game_total: totalAchievements,
                                shadow_challange_revealed: false // Keep shadow challenge hidden by default
                            });

                            await challenge.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Monthly Challenge Created')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (existingChallenge) {
                                resultEmbed.setDescription(`Monthly challenge replaced for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: existingChallenge.monthly_challange_gameid.toString() },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Monthly challenge created for ${month}/${year}`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('add_shadow')
                                        .setLabel('Add Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ‘¥'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'add_shadow') {
                                        await this.handleShadowChallenge(resultI, { month, year });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error creating challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while creating the challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to create a challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleShadowChallenge(interaction, prefilledData = null) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Shadow Challenge')
            .setColor('#9932CC') // Dark purple
            .setDescription('Use this form to add or edit a shadow challenge for a specific month.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Month and Year\nâ€¢ Progression Achievement IDs (comma-separated)\nâ€¢ Win Achievement IDs (optional, comma-separated)'
                },
                {
                    name: 'Shadow Challenge Rules',
                    value: 'Shadow challenges are hidden mysteries that players can discover by guessing or playing the challenge games. They automatically reveal for past months.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('shadow_challenge_form')
                    .setLabel('Open Shadow Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸ‘¥')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'shadow_challenge_form') {
                    // Create modal for shadow challenge
                    const modal = new ModalBuilder()
                        .setCustomId('shadow_challenge_modal')
                        .setTitle('Add Shadow Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add month input with prefilled data if available
                    const monthInput = new TextInputBuilder()
                        .setCustomId('month')
                        .setLabel('Month (1-12)')
                        .setPlaceholder('Example: 5 (for May)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.month) {
                        monthInput.setValue(prefilledData.month.toString());
                    } else {
                        // Default to current month
                        const now = new Date();
                        monthInput.setValue((now.getMonth() + 1).toString());
                    }

                    // Add year input with prefilled data if available
                    const yearInput = new TextInputBuilder()
                        .setCustomId('year')
                        .setLabel('Year')
                        .setPlaceholder('Example: 2025')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    if (prefilledData && prefilledData.year) {
                        yearInput.setValue(prefilledData.year.toString());
                    } else {
                        // Default to current year
                        const now = new Date();
                        yearInput.setValue(now.getFullYear().toString());
                    }

                    // Add progression achievements input
                    const progressionInput = new TextInputBuilder()
                        .setCustomId('progression_achievements')
                        .setLabel('Progression Achievement IDs (comma-separated)')
                        .setPlaceholder('Example: 123456, 123457, 123458')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add win achievements input
                    const winInput = new TextInputBuilder()
                        .setCustomId('win_achievements')
                        .setLabel('Win Achievement IDs (comma-separated, optional)')
                        .setPlaceholder('Example: 123459, 123460')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthInput, yearInput);
                    const progressionRow = new ActionRowBuilder().addComponents(progressionInput);
                    const winRow = new ActionRowBuilder().addComponents(winInput);

                    modal.addComponents(gameIdRow, monthYearRow, progressionRow, winRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                        const year = parseInt(modalSubmission.fields.getTextInputValue('year'));
                        const progressionAchievementsInput = modalSubmission.fields.getTextInputValue('progression_achievements');
                        const winAchievementsInput = modalSubmission.fields.getTextInputValue('win_achievements');

                        // Validate inputs
                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        // Parse progression and win achievements
                        const progressionAchievements = progressionAchievementsInput.split(',').map(id => id.trim()).filter(id => id);
                        const winAchievements = winAchievementsInput ? winAchievementsInput.split(',').map(id => id.trim()).filter(id => id) : [];
                        
                        if (progressionAchievements.length === 0) {
                            return modalSubmission.editReply('Please provide at least one progression achievement ID.');
                        }

                        try {
                            // Get date range for the specified month
                            const monthStart = new Date(year, month - 1, 1);
                            const nextMonthStart = new Date(year, month, 1);

                            // Find the target challenge
                            const targetChallenge = await Challenge.findOne({
                                date: {
                                    $gte: monthStart,
                                    $lt: nextMonthStart
                                }
                            });

                            if (!targetChallenge) {
                                return modalSubmission.editReply(`No challenge exists for ${month}/${year}. Create a monthly challenge first using /admin challenge create.`);
                            }

                            // Get game info to validate game exists
                            const gameInfo = await retroAPI.getGameInfoExtended(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }
                            
                            // Get game achievements to get the total count
                            const achievements = gameInfo.achievements;
                            if (!achievements) {
                                return modalSubmission.editReply('Could not retrieve achievements for this game. Please try again.');
                            }
                            
                            const totalAchievements = Object.keys(achievements).length;

                            // Check if there's an existing shadow game to be replaced
                            let replacedShadowGame = null;
                            if (targetChallenge.shadow_challange_gameid) {
                                try {
                                    const oldGameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
                                    replacedShadowGame = oldGameInfo.title;
                                } catch (error) {
                                    console.error('Error fetching old shadow game info:', error);
                                    replacedShadowGame = targetChallenge.shadow_challange_gameid;
                                }
                            }

                            // Update the challenge with shadow game information
                            targetChallenge.shadow_challange_gameid = gameId;
                            targetChallenge.shadow_challange_progression_achievements = progressionAchievements;
                            targetChallenge.shadow_challange_win_achievements = winAchievements;
                            targetChallenge.shadow_challange_game_total = totalAchievements;
                            
                            // Automatically reveal shadow games for past months
                            const now = new Date();
                            if (month < now.getMonth() + 1 || year < now.getFullYear()) {
                                targetChallenge.shadow_challange_revealed = true;
                            } else if (!targetChallenge.shadow_challange_revealed) {
                                // For current or future months, keep shadow games hidden by default
                                targetChallenge.shadow_challange_revealed = false;
                            }

                            await targetChallenge.save();

                            // Get month name for display
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Determine if it was auto-revealed
                            const autoRevealed = (month < now.getMonth() + 1 || year < now.getFullYear());
                            
                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#9932CC') // Dark purple for shadow challenges
                                .setTitle('Shadow Challenge Added')
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            if (replacedShadowGame) {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} replaced`);
                                resultEmbed.addFields(
                                    { name: 'Previous Game', value: replacedShadowGame },
                                    { name: 'New Game', value: gameInfo.title }
                                );
                            } else {
                                resultEmbed.setDescription(`Shadow challenge for ${monthName} ${year} created`);
                                resultEmbed.addFields(
                                    { name: 'Game', value: gameInfo.title }
                                );
                            }

                            resultEmbed.addFields(
                                { name: 'Required Progression Achievements', value: progressionAchievements.length.toString() },
                                { name: 'Required Win Achievements', value: winAchievements.length > 0 ? winAchievements.length.toString() : 'None' },
                                { name: 'Total Achievements', value: totalAchievements.toString() },
                                { name: 'Visibility', value: targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden' + (autoRevealed ? ' (Auto-revealed as past challenge)' : '') }
                            );

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('toggle_shadow')
                                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                                    new ButtonBuilder()
                                        .setCustomId('view_challenge')
                                        .setLabel('View Challenge Details')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'toggle_shadow') {
                                        await this.handleToggleShadow(resultI, { month, year, force: true });
                                    } else if (resultI.customId === 'view_challenge') {
                                        await this.handleViewChallenge(resultI, { month, year });
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding shadow challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the shadow challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a shadow challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleToggleShadow(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            let force = options?.force || false;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                const now = new Date();
                month = now.getMonth() + 1; // 1-indexed month
                year = now.getFullYear();
            }
            
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the target challenge
            const targetChallenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!targetChallenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            if (!targetChallenge.shadow_challange_gameid) {
                return interaction.editReply(`No shadow challenge has been set for ${month}/${year}.`);
            }

            // Toggle the visibility
            targetChallenge.shadow_challange_revealed = !targetChallenge.shadow_challange_revealed;
            await targetChallenge.save();

            // Get game info for the response
            const gameInfo = await retroAPI.getGameInfo(targetChallenge.shadow_challange_gameid);
            
            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Create response embed
            const resultEmbed = new EmbedBuilder()
                .setColor(targetChallenge.shadow_challange_revealed ? '#00FF00' : '#FF0000') // Green for revealed, red for hidden
                .setTitle(`Shadow Challenge ${targetChallenge.shadow_challange_revealed ? 'Revealed' : 'Hidden'}`)
                .setDescription(`The shadow challenge for ${monthName} ${year} is now ${targetChallenge.shadow_challange_revealed ? 'REVEALED' : 'HIDDEN'}.`)
                .setTimestamp();

            if (targetChallenge.shadow_challange_revealed) {
                resultEmbed.addFields(
                    { name: 'Game', value: gameInfo.title },
                    { name: 'Required Progression Achievements', value: targetChallenge.shadow_challange_progression_achievements.length.toString() },
                    { name: 'Required Win Achievements', value: targetChallenge.shadow_challange_win_achievements.length > 0 ? targetChallenge.shadow_challange_win_achievements.length.toString() : 'None' }
                );
                
                if (gameInfo.imageIcon) {
                    resultEmbed.setThumbnail(`https://retroachievements.org${gameInfo.imageIcon}`);
                }
            }

            // Add action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow_again')
                        .setLabel(targetChallenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji(targetChallenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸'),
                    new ButtonBuilder()
                        .setCustomId('view_challenge')
                        .setLabel('View Challenge Details')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ”')
                );

            // If we're force-updating from another command, use editReply
            // Otherwise, use standard reply
            if (force) {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            } else {
                await interaction.editReply({
                    embeds: [resultEmbed],
                    components: [actionRow]
                });
            }

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'toggle_shadow_again') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    } else if (i.customId === 'view_challenge') {
                        await this.handleViewChallenge(i, { month, year });
                    }
                }
            });

        } catch (error) {
            console.error('Error toggling shadow challenge visibility:', error);
            await interaction.editReply('An error occurred while toggling the shadow challenge visibility. Please try again.');
        }
    },

    async handleViewChallenge(interaction, options = null) {
        try {
            // If specific month/year provided, use those; otherwise use current month
            let month, year;
            
            if (options && options.month && options.year) {
                month = options.month;
                year = options.year;
            } else {
                // Open a form to select month/year
                const embed = new EmbedBuilder()
                    .setTitle('View Challenge Details')
                    .setColor('#3498DB')
                    .setDescription('Please select which challenge you want to view.')
                    .addFields(
                        {
                            name: 'Options',
                            value: 'You can view the current month\'s challenge or select a specific month.'
                        }
                    );

                // Create buttons
                const row = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('view_current_challenge')
                            .setLabel('Current Month')
                            .setStyle(ButtonStyle.Primary)
                            .setEmoji('ðŸ“…'),
                        new ButtonBuilder()
                            .setCustomId('select_month_challenge')
                            .setLabel('Select Month')
                            .setStyle(ButtonStyle.Secondary)
                            .setEmoji('ðŸ”')
                    );

                await interaction.editReply({
                    embeds: [embed],
                    components: [row]
                });

                // Set up collector for the buttons
                const message = await interaction.fetchReply();
                const buttonCollector = message.createMessageComponentCollector({
                    componentType: ComponentType.Button,
                    time: 300000 // 5 minutes timeout
                });

                buttonCollector.on('collect', async i => {
                    if (i.user.id === interaction.user.id) {
                        await i.deferUpdate();

                        if (i.customId === 'view_current_challenge') {
                            // Use current month
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                            
                            // Continue with viewing the challenge
                            await this.displayChallengeDetails(i, month, year);
                            
                            // Stop the collector
                            buttonCollector.stop();
                        } else if (i.customId === 'select_month_challenge') {
                            // Show modal to select month/year
                            const modal = new ModalBuilder()
                                .setCustomId('select_challenge_month_modal')
                                .setTitle('Select Challenge Month');

                            // Add month input
                            const monthInput = new TextInputBuilder()
                                .setCustomId('month')
                                .setLabel('Month (1-12)')
                                .setPlaceholder('Example: 5 (for May)')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add year input
                            const yearInput = new TextInputBuilder()
                                .setCustomId('year')
                                .setLabel('Year')
                                .setPlaceholder('Example: 2025')
                                .setStyle(TextInputStyle.Short)
                                .setRequired(true);

                            // Add inputs to modal
                            const monthRow = new ActionRowBuilder().addComponents(monthInput);
                            const yearRow = new ActionRowBuilder().addComponents(yearInput);

                            modal.addComponents(monthRow, yearRow);

                            // Show the modal
                            await i.showModal(modal);

                            try {
                                // Wait for modal submission
                                const modalSubmission = await i.awaitModalSubmit({
                                    time: 300000 // 5 minutes to fill out the form
                                });

                                await modalSubmission.deferUpdate();

                                // Extract values from the modal
                                month = parseInt(modalSubmission.fields.getTextInputValue('month'));
                                year = parseInt(modalSubmission.fields.getTextInputValue('year'));

                                // Validate inputs
                                if (isNaN(month) || month < 1 || month > 12) {
                                    return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                                }

                                if (isNaN(year) || year < 2000 || year > 2100) {
                                    return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                                }

                                // Continue with viewing the challenge
                                await this.displayChallengeDetails(modalSubmission, month, year);
                                
                                // Stop the collector
                                buttonCollector.stop();

                            } catch (modalError) {
                                console.error('Error handling modal submission:', modalError);
                                // Modal timed out or was cancelled
                            }
                        }
                    }
                });

                // Let the function end here and let the collector handle the rest
                return;
            }

            // If we have month/year, display the challenge
            await this.displayChallengeDetails(interaction, month, year);

        } catch (error) {
            console.error('Error viewing challenge:', error);
            await interaction.editReply('An error occurred while viewing the challenge. Please try again.');
        }
    },

    async displayChallengeDetails(interaction, month, year) {
        try {
            // Get date range for the specified month
            const monthStart = new Date(year, month - 1, 1);
            const nextMonthStart = new Date(year, month, 1);

            // Find the challenge
            const challenge = await Challenge.findOne({
                date: {
                    $gte: monthStart,
                    $lt: nextMonthStart
                }
            });

            if (!challenge) {
                return interaction.editReply(`No challenge exists for ${month}/${year}.`);
            }

            // Get month name for display
            const monthNames = ["January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
            const monthName = monthNames[month - 1];

            // Get game info for monthly challenge
            let monthlyGameInfo = null;
            if (challenge.monthly_challange_gameid) {
                monthlyGameInfo = await retroAPI.getGameInfo(challenge.monthly_challange_gameid);
            }

            // Get game info for shadow challenge if revealed
            let shadowGameInfo = null;
            if (challenge.shadow_challange_gameid && challenge.shadow_challange_revealed) {
                shadowGameInfo = await retroAPI.getGameInfo(challenge.shadow_challange_gameid);
            }

            // Create main embed
            const embed = new EmbedBuilder()
                .setTitle(`Challenge Details: ${monthName} ${year}`)
                .setColor('#3498DB')
                .setDescription(`Here are the details for the ${monthName} ${year} challenges:`)
                .setTimestamp();

            // Add monthly challenge info
            if (monthlyGameInfo) {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: `**Game:** ${monthlyGameInfo.title}\n` +
                          `**Required Progression Achievements:** ${challenge.monthly_challange_progression_achievements.length}\n` +
                          `**Required Win Achievements:** ${challenge.monthly_challange_win_achievements.length}\n` +
                          `**Total Achievements:** ${challenge.monthly_challange_game_total}\n` +
                          `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.monthly_challange_gameid})`
                });

                if (monthlyGameInfo.imageIcon) {
                    embed.setThumbnail(`https://retroachievements.org${monthlyGameInfo.imageIcon}`);
                }
            } else {
                embed.addFields({
                    name: 'ðŸ† Monthly Challenge',
                    value: 'No monthly challenge set.'
                });
            }

            // Add shadow challenge info
            if (challenge.shadow_challange_gameid) {
                if (challenge.shadow_challange_revealed && shadowGameInfo) {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (REVEALED)',
                        value: `**Game:** ${shadowGameInfo.title}\n` +
                              `**Required Progression Achievements:** ${challenge.shadow_challange_progression_achievements.length}\n` +
                              `**Required Win Achievements:** ${challenge.shadow_challange_win_achievements.length}\n` +
                              `**Total Achievements:** ${challenge.shadow_challange_game_total}\n` +
                              `[View Game on RetroAchievements](https://retroachievements.org/game/${challenge.shadow_challange_gameid})`
                    });
                } else {
                    embed.addFields({
                        name: 'ðŸ‘¥ Shadow Challenge (HIDDEN)',
                        value: 'Shadow challenge exists but is currently hidden.\n' +
                              `Use \`/admin challenge toggle\` to reveal it.`
                    });
                }
            } else {
                embed.addFields({
                    name: 'ðŸ‘¥ Shadow Challenge',
                    value: 'No shadow challenge set.\n' +
                          `Use \`/admin challenge shadow\` to add one.`
                });
            }

            // Create action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('edit_monthly')
                        .setLabel('Edit Monthly Challenge')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('ðŸ†'),
                    new ButtonBuilder()
                        .setCustomId('edit_shadow')
                        .setLabel(challenge.shadow_challange_gameid ? 'Edit Shadow Challenge' : 'Add Shadow Challenge')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ‘¥')
                );

            // Add toggle button if shadow challenge exists
            if (challenge.shadow_challange_gameid) {
                actionRow.addComponents(
                    new ButtonBuilder()
                        .setCustomId('toggle_shadow')
                        .setLabel(challenge.shadow_challange_revealed ? 'Hide Shadow Challenge' : 'Reveal Shadow Challenge')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji(challenge.shadow_challange_revealed ? 'ðŸ”’' : 'ðŸ‘ï¸')
                );
            }

            await interaction.editReply({
                embeds: [embed],
                components: [actionRow]
            });

            // Set up collector for the action buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });

            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();

                    if (i.customId === 'edit_monthly') {
                        await this.handleCreateChallenge(i);
                    } else if (i.customId === 'edit_shadow') {
                        await this.handleShadowChallenge(i, { month, year });
                    } else if (i.customId === 'toggle_shadow') {
                        await this.handleToggleShadow(i, { month, year, force: true });
                    }
                }
            });

        } catch (error) {
            console.error('Error displaying challenge details:', error);
            await interaction.editReply('An error occurred while retrieving challenge details. Please try again.');
        }
    },

    // ARCADE MANAGEMENT HANDLERS
    async handleArcadeCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'add':
                await this.handleAddArcadeBoard(interaction);
                break;
            case 'racing':
                await this.handleAddRacingChallenge(interaction);
                break;
            case 'tiebreaker':
                await this.handleAddTiebreaker(interaction);
                break;
            case 'award':
                await this.handleAwardPoints(interaction);
                break;
            case 'announce':
                await this.handleAnnounceBoard(interaction);
                break;
            case 'view':
                await this.handleViewBoards(interaction);
                break;
            default:
                await interaction.editReply('Invalid arcade subcommand.');
        }
    },

    async handleAddArcadeBoard(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Arcade Board')
            .setColor('#9B59B6') // Purple
            .setDescription('Use this form to add a new arcade board to the community.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Board ID (unique identifier)\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description'
                },
                {
                    name: 'How to Find IDs',
                    value: '**Game ID**: The number at the end of the game URL on RetroAchievements\n**Leaderboard ID**: The number at the end of the leaderboard URL'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_arcade_form')
                    .setLabel('Open Arcade Board Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽ¯')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_arcade_form') {
                    // Create modal for arcade board
                    const modal = new ModalBuilder()
                        .setCustomId('add_arcade_modal')
                        .setTitle('Add Arcade Board');

                    // Add board ID input
                    const boardIdInput = new TextInputBuilder()
                        .setCustomId('board_id')
                        .setLabel('Board ID (unique identifier)')
                        .setPlaceholder('Example: sonic3-special-stages')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this arcade board challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add inputs to modal
                    const boardIdRow = new ActionRowBuilder().addComponents(boardIdInput);
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);

                    modal.addComponents(boardIdRow, gameIdRow, leaderboardIdRow, descriptionRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const boardId = modalSubmission.fields.getTextInputValue('board_id');
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        try {
                            // Check if board ID already exists
                            const existingBoard = await ArcadeBoard.findOne({ boardId });
                            if (existingBoard) {
                                return modalSubmission.editReply(`A board with ID "${boardId}" already exists.`);
                            }

                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Create new board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'arcade',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description
                            });

                            await newBoard.save();

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Arcade Board Added')
                                .setDescription(`Successfully added "${gameInfo.title}" arcade board!`)
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .addFields(
                                    { name: 'Board ID', value: boardId },
                                    { name: 'Game', value: gameInfo.title },
                                    { name: 'Console', value: gameInfo.consoleName || 'Unknown' },
                                    { name: 'Description', value: description }
                                )
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_board')
                                        .setLabel('Announce Board')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_board') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding arcade board:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the arcade board. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add an arcade board.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddRacingChallenge(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Racing Challenge')
            .setColor('#FF9900') // Orange
            .setDescription('Use this form to set up a monthly racing challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Track Name\nâ€¢ Description\nâ€¢ Month and Year (optional, defaults to current month)'
                },
                {
                    name: 'Racing Challenge Rules',
                    value: 'Racing challenges are monthly competitions where players compete on time-based leaderboards. The top 3 players will receive community points.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_racing_form')
                    .setLabel('Open Racing Challenge Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('ðŸŽï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_racing_form') {
                    // Create modal for racing challenge
                    const modal = new ModalBuilder()
                        .setCustomId('add_racing_modal')
                        .setTitle('Add Racing Challenge');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add track name input
                    const trackNameInput = new TextInputBuilder()
                        .setCustomId('track_name')
                        .setLabel('Track Name')
                        .setPlaceholder('Example: Rainbow Road')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this racing challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add month/year input
                    const monthYearInput = new TextInputBuilder()
                        .setCustomId('month_year')
                        .setLabel('Month and Year (optional, MM/YYYY format)')
                        .setPlaceholder('Example: 05/2025 (defaults to current month)')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(false);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const trackNameRow = new ActionRowBuilder().addComponents(trackNameInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const monthYearRow = new ActionRowBuilder().addComponents(monthYearInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, trackNameRow, descriptionRow, monthYearRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const trackName = modalSubmission.fields.getTextInputValue('track_name');
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const monthYearInput = modalSubmission.fields.getTextInputValue('month_year');

                        // Parse month and year
                        let month, year;
                        if (monthYearInput && monthYearInput.trim()) {
                            const parts = monthYearInput.split('/');
                            if (parts.length === 2) {
                                month = parseInt(parts[0]);
                                year = parseInt(parts[1]);
                            } else {
                                // Invalid format, use current month/year
                                const now = new Date();
                                month = now.getMonth() + 1;
                                year = now.getFullYear();
                            }
                        } else {
                            // No input, use current month/year
                            const now = new Date();
                            month = now.getMonth() + 1;
                            year = now.getFullYear();
                        }

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        if (isNaN(month) || month < 1 || month > 12) {
                            return modalSubmission.editReply('Invalid month. Please provide a number between 1 and 12.');
                        }

                        if (isNaN(year) || year < 2000 || year > 2100) {
                            return modalSubmission.editReply('Invalid year. Please provide a valid year.');
                        }

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Calculate start and end dates
                            // Start at beginning of specified month
                            const startDate = new Date(year, month - 1, 1);
                            
                            // End at the end of the specified month (23:59:59 on the last day)
                            const endDate = new Date(year, month, 0, 23, 59, 59);
                            
                            // Check if a racing challenge already exists for this month
                            const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                            const existingChallenge = await ArcadeBoard.findOne({
                                boardType: 'racing',
                                monthKey
                            });

                            if (existingChallenge) {
                                return modalSubmission.editReply(`A racing challenge already exists for ${monthKey}.`);
                            }

                            // Generate a unique board ID specifically for racing
                            // This format ensures no overlap with regular arcade boards
                            const boardId = `racing-${monthKey}`;

                            // Get the full game title and console name
                            const gameFull = `${gameInfo.title} (${gameInfo.consoleName})`;

                            // Create new racing board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'racing',
                                leaderboardId,
                                gameId,
                                gameTitle: gameFull,
                                trackName,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate,
                                endDate,
                                monthKey
                            });

                            await newBoard.save();

                            // Get month name for response
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[month - 1];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF9900') // Orange for racing
                                .setTitle(`Racing Challenge Created: ${monthName} ${year}`)
                                .setDescription(
                                    `**Game:** ${gameFull}\n` +
                                    `**Track:** ${trackName}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Challenge Period:** ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `The top 3 players at the end of the month will receive award points!`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_racing')
                                        .setLabel('Announce Racing Challenge')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_racing') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding racing challenge:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the racing challenge. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a racing challenge.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAddTiebreaker(interaction) {
        // Create info embed
        const embed = new EmbedBuilder()
            .setTitle('Add Tiebreaker')
            .setColor('#FF0000') // Red
            .setDescription('Use this form to create a tiebreaker leaderboard for the monthly challenge.')
            .addFields(
                {
                    name: 'Required Information',
                    value: 'You\'ll need to provide:\nâ€¢ Game ID (from RetroAchievements)\nâ€¢ Leaderboard ID (from RetroAchievements)\nâ€¢ Description\nâ€¢ End Date (YYYY-MM-DD format)'
                },
                {
                    name: 'Tiebreaker Rules',
                    value: 'Tiebreakers are used to resolve ties in the monthly challenge leaderboard. Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.'
                }
            );

        // Create button to open the form
        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('add_tiebreaker_form')
                    .setLabel('Open Tiebreaker Form')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('âš”ï¸')
            );

        // Send the info and button
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the button click
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.Button,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                if (i.customId === 'add_tiebreaker_form') {
                    // Create modal for tiebreaker
                    const modal = new ModalBuilder()
                        .setCustomId('add_tiebreaker_modal')
                        .setTitle('Add Tiebreaker');

                    // Add game ID input
                    const gameIdInput = new TextInputBuilder()
                        .setCustomId('game_id')
                        .setLabel('Game ID (from RetroAchievements)')
                        .setPlaceholder('Example: 14402')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add leaderboard ID input
                    const leaderboardIdInput = new TextInputBuilder()
                        .setCustomId('leaderboard_id')
                        .setLabel('Leaderboard ID (from RetroAchievements)')
                        .setPlaceholder('Example: 2310')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add description input
                    const descriptionInput = new TextInputBuilder()
                        .setCustomId('description')
                        .setLabel('Description')
                        .setPlaceholder('Describe this tiebreaker challenge...')
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    // Add end date input
                    const endDateInput = new TextInputBuilder()
                        .setCustomId('end_date')
                        .setLabel('End Date (YYYY-MM-DD format)')
                        .setPlaceholder('Example: 2025-05-31')
                        .setStyle(TextInputStyle.Short)
                        .setRequired(true);

                    // Add inputs to modal
                    const gameIdRow = new ActionRowBuilder().addComponents(gameIdInput);
                    const leaderboardIdRow = new ActionRowBuilder().addComponents(leaderboardIdInput);
                    const descriptionRow = new ActionRowBuilder().addComponents(descriptionInput);
                    const endDateRow = new ActionRowBuilder().addComponents(endDateInput);

                    modal.addComponents(gameIdRow, leaderboardIdRow, descriptionRow, endDateRow);

                    // Show the modal
                    await i.showModal(modal);

                    try {
                        // Wait for modal submission
                        const modalSubmission = await i.awaitModalSubmit({
                            time: 300000 // 5 minutes to fill out the form
                        });

                        await modalSubmission.deferUpdate();

                        // Extract values from the modal
                        const gameId = modalSubmission.fields.getTextInputValue('game_id');
                        const leaderboardId = parseInt(modalSubmission.fields.getTextInputValue('leaderboard_id'));
                        const description = modalSubmission.fields.getTextInputValue('description');
                        const endDateStr = modalSubmission.fields.getTextInputValue('end_date');

                        // Validate inputs
                        if (isNaN(leaderboardId)) {
                            return modalSubmission.editReply('Invalid leaderboard ID. Please provide a valid number.');
                        }

                        // Parse end date
                        const endDate = new Date(endDateStr);
                        if (isNaN(endDate.getTime())) {
                            return modalSubmission.editReply('Invalid end date format. Please use YYYY-MM-DD.');
                        }

                        // Set end time to 23:59:59
                        endDate.setHours(23, 59, 59);

                        try {
                            // Validate game exists
                            const gameInfo = await retroAPI.getGameInfo(gameId);
                            if (!gameInfo) {
                                return modalSubmission.editReply('Game not found. Please check the game ID.');
                            }

                            // Check if an active tiebreaker already exists
                            const now = new Date();
                            const activeTiebreaker = await ArcadeBoard.findOne({
                                boardType: 'tiebreaker',
                                startDate: { $lte: now },
                                endDate: { $gte: now }
                            });

                            if (activeTiebreaker) {
                                return modalSubmission.editReply('An active tiebreaker already exists. Please end it before creating a new one.');
                            }

                            // Generate a unique board ID based on month and year
                            const monthYear = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}`;
                            const boardId = `tiebreaker-${monthYear}`;

                            // Create new tiebreaker board
                            const newBoard = new ArcadeBoard({
                                boardId,
                                boardType: 'tiebreaker',
                                leaderboardId,
                                gameId,
                                gameTitle: gameInfo.title,
                                consoleName: gameInfo.consoleName || 'Unknown',
                                description,
                                startDate: now,
                                endDate,
                                // Add monthKey for consistency with racing challenges
                                monthKey: monthYear
                            });

                            await newBoard.save();

                            // Get the month name
                            const monthNames = ["January", "February", "March", "April", "May", "June",
                                            "July", "August", "September", "October", "November", "December"];
                            const monthName = monthNames[now.getMonth()];

                            // Create response embed
                            const resultEmbed = new EmbedBuilder()
                                .setColor('#FF0000') // Red for tiebreaker
                                .setTitle(`âš”ï¸ Tiebreaker Created: ${monthName} ${now.getFullYear()}`)
                                .setDescription(
                                    `**Game:** ${gameInfo.title}\n` +
                                    `**Description:** ${description}\n\n` +
                                    `**Tiebreaker Period:** ${now.toLocaleDateString()} to ${endDate.toLocaleDateString()}\n\n` +
                                    `This tiebreaker will be used to resolve ties in the ${monthName} monthly challenge leaderboard. ` +
                                    `Any users who are tied in achievement count in the top 3 positions will be ranked based on their performance in this tiebreaker.`
                                )
                                .setThumbnail(gameInfo.imageIcon ? `https://retroachievements.org${gameInfo.imageIcon}` : null)
                                .setTimestamp();

                            // Add action buttons
                            const actionRow = new ActionRowBuilder()
                                .addComponents(
                                    new ButtonBuilder()
                                        .setCustomId('announce_tiebreaker')
                                        .setLabel('Announce Tiebreaker')
                                        .setStyle(ButtonStyle.Primary)
                                        .setEmoji('ðŸ“¢'),
                                    new ButtonBuilder()
                                        .setCustomId('view_boards')
                                        .setLabel('View All Boards')
                                        .setStyle(ButtonStyle.Secondary)
                                        .setEmoji('ðŸ”')
                                );

                            await modalSubmission.editReply({
                                embeds: [resultEmbed],
                                components: [actionRow]
                            });

                            // Set up collector for the action buttons
                            const resultMessage = await modalSubmission.fetchReply();
                            const resultCollector = resultMessage.createMessageComponentCollector({
                                componentType: ComponentType.Button,
                                time: 300000 // 5 minutes timeout
                            });

                            resultCollector.on('collect', async resultI => {
                                if (resultI.user.id === interaction.user.id) {
                                    await resultI.deferUpdate();

                                    if (resultI.customId === 'announce_tiebreaker') {
                                        await this.announceBoard(resultI, boardId);
                                    } else if (resultI.customId === 'view_boards') {
                                        await this.handleViewBoards(resultI);
                                    }
                                }
                            });

                        } catch (apiError) {
                            console.error('Error adding tiebreaker:', apiError);
                            return modalSubmission.editReply('An error occurred while adding the tiebreaker. Please try again.');
                        }

                    } catch (modalError) {
                        console.error('Error handling modal submission:', modalError);
                        // Modal timed out or was cancelled
                    }
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        ButtonBuilder.from(row.components[0]).setDisabled(true)
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This form has expired. Please run the command again if you still need to add a tiebreaker.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling button:', error);
                }
            }
        });
    },

    async handleAwardPoints(interaction) {
        // Create select board form
        const embed = new EmbedBuilder()
            .setTitle('Award Points')
            .setColor('#32CD32') // Lime green
            .setDescription('Select a board to award points for.')
            .addFields(
                {
                    name: 'Award Points',
                    value: 'You can award points for completed racing challenges or arcade boards. For racing challenges, points are awarded to the top 3 players. For arcade boards, points are awarded annually.'
                }
            );

        // Find all racing boards and tiebreakers
        const racingBoards = await ArcadeBoard.find({ 
            boardType: 'racing',
            pointsAwarded: { $ne: true } // Only show boards that haven't been awarded points yet
        }).sort({ startDate: -1 });

        // Create options for racing boards
        const boardOptions = racingBoards.map(board => {
            const monthYear = board.monthKey || 'Unknown Date';
            return {
                label: `Racing: ${board.gameTitle}${board.trackName ? ` - ${board.trackName}` : ''}`,
                description: `${monthYear}`,
                value: `racing-${board.boardId}`
            };
        });

        // Add option for annual arcade awards if any arcade boards exist
        const arcadeBoards = await ArcadeBoard.find({ boardType: 'arcade' });
        if (arcadeBoards.length > 0) {
            boardOptions.push({
                label: 'Annual Arcade Awards',
                description: 'Award points for all arcade boards for the current year',
                value: 'arcade-annual'
            });
        }

        // Create dropdown if we have options
        if (boardOptions.length === 0) {
            return interaction.editReply('No eligible boards found for awarding points. All racing challenges have already been awarded points, or no racing challenges exist.');
        }

        // Create the dropdown
        const row = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('select_board_for_award')
                    .setPlaceholder('Select a board to award points')
                    .addOptions(boardOptions)
            );

        // Send the selection menu
        const message = await interaction.editReply({
            embeds: [embed],
            components: [row]
        });

        // Set up collector for the dropdown selection
        const collector = message.createMessageComponentCollector({
            componentType: ComponentType.StringSelect,
            time: 300000 // 5 minutes timeout
        });

        collector.on('collect', async i => {
            if (i.user.id === interaction.user.id) {
                await i.deferUpdate();
                
                const selectedValue = i.values[0];
                
                if (selectedValue.startsWith('racing-')) {
                    // Extract board ID
                    const boardId = selectedValue.substring(7);
                    await this.awardRacingPoints(i, boardId);
                } else if (selectedValue === 'arcade-annual') {
                    await this.awardArcadePoints(i);
                }
            }
        });

        // When collector expires
        collector.on('end', async (collected, reason) => {
            if (reason === 'time') {
                try {
                    const disabledRow = new ActionRowBuilder().addComponents(
                        StringSelectMenuBuilder.from(row.components[0])
                            .setDisabled(true)
                            .setPlaceholder('Selection timed out')
                    );
                    
                    await interaction.editReply({
                        embeds: [embed.setFooter({ text: 'This selection has expired. Please run the command again if you still need to award points.' })],
                        components: [disabledRow]
                    });
                } catch (error) {
                    console.error('Error disabling dropdown:', error);
                }
            }
        });
    },

    async awardRacingPoints(interaction, boardId) {
        try {
            // Find the racing board
            const racingBoard = await ArcadeBoard.findOne({ 
                boardId,
                boardType: 'racing'
            });

            if (!racingBoard) {
                return interaction.editReply(`Racing board with ID "${boardId}" not found.`);
            }

            // Check if points have already been awarded
            if (racingBoard.pointsAwarded) {
                return interaction.editReply(`Points have already been awarded for this racing challenge.`);
            }

            // Check if the racing challenge has ended
            const now = new Date();
            if (racingBoard.endDate > now) {
                return interaction.editReply(`This racing challenge hasn't ended yet. It ends on ${racingBoard.endDate.toLocaleDateString()}.`);
            }

, 'i') }
            });

            if (!user) {
                return modalSubmission.editReply('User not found. Please check the username.');
            }

            // Get current nominations count before clearing
            const currentNominations = user.getCurrentNominations();
            const nominationCount = currentNominations.length;

            if (nominationCount === 0) {
                return modalSubmission.editReply(`${raUsername} has no current nominations to clear.`);
            }

            // Create confirmation embed
            const confirmEmbed = new EmbedBuilder()
                .setTitle(`Clear Nominations: ${user.raUsername}`)
                .setColor('#FF0000') // Red for danger
                .setDescription(`Are you sure you want to clear ${nominationCount} nomination${nominationCount !== 1 ? 's' : ''} for ${user.raUsername}?`)
                .setTimestamp();
                
            // Create confirmation buttons
            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('confirm_clear_nominations')
                        .setLabel('Clear Nominations')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('âœ…'),
                    new ButtonBuilder()
                        .setCustomId('cancel_clear_nominations')
                        .setLabel('Cancel')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('âŒ')
                );
                
            await modalSubmission.editReply({
                embeds: [confirmEmbed],
                components: [row]
            });
            
            // Set up collector for the confirmation buttons
            const message = await modalSubmission.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 60000 // 1 minute timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'confirm_clear_nominations') {
                        // Clear the nominations
                        user.clearCurrentNominations();
                        await user.save();
                        
                        // Show success message
                        const successEmbed = new EmbedBuilder()
                            .setColor('#00FF00') // Green for success
                            .setTitle('Nominations Cleared')
                            .setDescription(`Successfully cleared ${nominationCount} nomination${nominationCount !== 1 ? 's' : ''} for ${user.raUsername}. They can now nominate again.`)
                            .setTimestamp();
                            
                        await i.editReply({
                            embeds: [successEmbed],
                            components: []
                        });
                    } else if (i.customId === 'cancel_clear_nominations') {
                        // Show cancellation message
                        await i.editReply({
                            content: 'Operation cancelled.',
                            embeds: [],
                            components: []
                        });
                    }
                }
            });
        } catch (modalError) {
            console.error('Error handling modal submission:', modalError);
            // Modal timed out or was cancelled
        }
    },

    async handleResetAchievements(interaction) {
        try {
            // Create username input form
            const modal = new ModalBuilder()
                .setCustomId('reset_achievements_modal')
                .setTitle('Reset User Achievements');

            // Add username input
            const usernameInput = new TextInputBuilder()
                .setCustomId('username')
                .setLabel('RetroAchievements Username')
                .setPlaceholder('Enter RA username...')
                .setStyle(TextInputStyle.Short)
                .setRequired(true);

            // Add inputs to modal
            const usernameRow = new ActionRowBuilder().addComponents(usernameInput);
            modal.addComponents(usernameRow);

            // Show the modal
            await interaction.showModal(modal);
            
            try {
                // Wait for modal submission
                const modalSubmission = await interaction.awaitModalSubmit({
                    time: 300000 // 5 minutes to fill out the form
                });

                await modalSubmission.deferUpdate();

                // Extract username from the modal
                const raUsername = modalSubmission.fields.getTextInputValue('username');
                
                // Create confirmation embed
                const confirmEmbed = new EmbedBuilder()
                    .setTitle(`Reset Achievements: ${raUsername}`)
                    .setColor('#FF0000') // Red for danger
                    .setDescription(`Are you sure you want to reset the achievement announcement history for ${raUsername}?\n\nThis will allow all their achievements to be announced again, even if they were previously announced.`)
                    .setTimestamp();
                    
                // Create confirmation buttons
                const row = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('confirm_reset_achievements')
                            .setLabel('Reset Achievements')
                            .setStyle(ButtonStyle.Danger)
                            .setEmoji('âœ…'),
                        new ButtonBuilder()
                            .setCustomId('cancel_reset_achievements')
                            .setLabel('Cancel')
                            .setStyle(ButtonStyle.Secondary)
                            .setEmoji('âŒ')
                    );
                    
                await modalSubmission.editReply({
                    embeds: [confirmEmbed],
                    components: [row]
                });
                
                // Set up collector for the confirmation buttons
                const message = await modalSubmission.fetchReply();
                const collector = message.createMessageComponentCollector({
                    componentType: ComponentType.Button,
                    time: 60000 // 1 minute timeout
                });
                
                collector.on('collect', async i => {
                    if (i.user.id === interaction.user.id) {
                        await i.deferUpdate();
                        
                        if (i.customId === 'confirm_reset_achievements') {
                            // Call the achievement feed service
                            const achievementFeedService = (await import('../../services/achievementFeedService.js')).default;
                            
                            try {
                                // Call the clearUserAchievements method
                                const success = await achievementFeedService.clearUserAchievements(raUsername);
                                
                                if (success) {
                                    // Show success message
                                    const successEmbed = new EmbedBuilder()
                                        .setColor('#00FF00') // Green for success
                                        .setTitle('Achievements Reset')
                                        .setDescription(`Successfully reset achievement history for ${raUsername}.`)
                                        .setTimestamp();
                                        
                                    await i.editReply({
                                        embeds: [successEmbed],
                                        components: []
                                    });
                                } else {
                                    // Show error message
                                    const errorEmbed = new EmbedBuilder()
                                        .setColor('#FF0000') // Red for error
                                        .setTitle('Reset Failed')
                                        .setDescription(`Failed to reset achievement history for ${raUsername}. Please check the username and try again.`)
                                        .setTimestamp();
                                        
                                    await i.editReply({
                                        embeds: [errorEmbed],
                                        components: []
                                    });
                                }
                            } catch (resetError) {
                                console.error('Error resetting achievements:', resetError);
                                await i.editReply('An error occurred while resetting achievements. Please try again.');
                            }
                        } else if (i.customId === 'cancel_reset_achievements') {
                            // Show cancellation message
                            await i.editReply({
                                content: 'Operation cancelled.',
                                embeds: [],
                                components: []
                            });
                        }
                    }
                });
            } catch (modalError) {
                console.error('Error handling modal submission:', modalError);
                // Modal timed out or was cancelled
            }
        } catch (error) {
            console.error('Error resetting achievements:', error);
            await interaction.editReply('An error occurred while resetting achievements. Please try again.');
        }
    },

    // VOTING MANAGEMENT HANDLERS
    async handleVotingCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'start':
                await this.handleStartVoting(interaction);
                break;
            case 'cancel':
                await this.handleCancelVoting(interaction);
                break;
            case 'status':
                await this.handleVotingStatus(interaction);
                break;
            default:
                await interaction.editReply('Invalid voting subcommand.');
        }
    },

    async handleStartVoting(interaction) {
        try {
            const channel = interaction.options.getChannel('channel');
            const resultsChannel = interaction.options.getChannel('results_channel') || channel;

            // Check if there's already an active poll
            const existingPoll = await Poll.findActivePoll();
            if (existingPoll) {
                return interaction.editReply('There is already an active voting poll. You must wait for it to end or cancel it first.');
            }

            // Create confirmation embed
            const confirmEmbed = new EmbedBuilder()
                .setTitle('Start Voting Poll')
                .setColor('#FF69B4') // Hot pink
                .setDescription(`Are you sure you want to start a voting poll in ${channel}?`)
                .addFields(
                    {
                        name: 'Process',
                        value: 'This will start a voting poll for the next month\'s challenge. ' +
                              'The system will randomly select 10 games from all nominations and create a poll where users can vote for their favorites.'
                    },
                    {
                        name: 'Configuration',
                        value: `**Announcement Channel:** ${channel}\n` +
                              `**Results Channel:** ${resultsChannel}`
                    }
                )
                .setTimestamp();
                
            // Create confirmation buttons
            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('confirm_start_voting')
                        .setLabel('Start Voting')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('ðŸ—³ï¸'),
                    new ButtonBuilder()
                        .setCustomId('cancel_start_voting')
                        .setLabel('Cancel')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('âŒ')
                );
                
            await interaction.editReply({
                embeds: [confirmEmbed],
                components: [row]
            });
            
            // Set up collector for the confirmation buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 60000 // 1 minute timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'confirm_start_voting') {
                        // Show a loading message
                        await i.editReply({
                            content: 'Starting voting process... This may take a moment.',
                            embeds: [],
                            components: []
                        });
                        
                        try {
                            // Calculate start and end dates
                            const now = new Date();
                            const currentMonth = now.getMonth();
                            const currentYear = now.getFullYear();
                            
                            // Calculate the last day of the current month
                            const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0);
                            
                            // Set end date to 24 hours before the end of the month
                            const endDate = new Date(lastDayOfMonth);
                            endDate.setDate(endDate.getDate() - 1);
                            
                            // If we're already within 8 days of the end of the month, move to next month
                            const startDate = new Date();
                            if ((lastDayOfMonth - now) / (1000 * 60 * 60 * 24) < 8) {
                                console.log("Less than 8 days left in month, scheduling for next month");
                                const nextMonth = (currentMonth + 1) % 12;
                                const yearForNextMonth = nextMonth === 0 ? currentYear + 1 : currentYear;
                                
                                // Set end date to 24 hours before the end of next month
                                const lastDayOfNextMonth = new Date(yearForNextMonth, nextMonth + 1, 0);
                                endDate.setTime(lastDayOfNextMonth.getTime());
                                endDate.setDate(endDate.getDate() - 1);
                            }
                            
                            // Set start date to 8 days before the end date
                            startDate.setTime(endDate.getTime());
                            startDate.setDate(startDate.getDate() - 7);
                            
                            // If start date is in the future, inform admin and do not start yet
                            if (startDate > now) {
                                return i.editReply(
                                    `Voting should start on ${startDate.toLocaleDateString()} ` +
                                    `(8 days before the end of the month) and end on ${endDate.toLocaleDateString()} ` +
                                    `(24 hours before the end of the month). Please try again on the start date.`
                                );
                            }

                            // Get all users
                            const users = await User.find({});

                            // Get all current nominations
                            let allNominations = [];
                            for (const user of users) {
                                const nominations = user.getCurrentNominations();
                                allNominations.push(...nominations.map(nom => ({
                                    gameId: nom.gameId,
                                    title: nom.gameTitle,
                                    consoleName: nom.consoleName
                                })));
                            }

                            // Remove duplicates by gameId
                            const uniqueNominations = Array.from(
                                new Map(allNominations.map(item => [item.gameId, item])).values()
                            );

                            if (uniqueNominations.length === 0) {
                                return i.editReply('No games have been nominated for next month.');
                            }

                            // Randomly select 10 games (or less if there aren't enough nominations)
                            const selectedCount = Math.min(10, uniqueNominations.length);
                            const selectedGames = [];
                            const selectedIndices = new Set();
                            
                            while (selectedGames.length < selectedCount) {
                                const randomIndex = Math.floor(Math.random() * uniqueNominations.length);
                                
                                if (!selectedIndices.has(randomIndex)) {
                                    selectedIndices.add(randomIndex);
                                    const game = uniqueNominations[randomIndex];
                                    
                                    // Get extended game info to get the image icon
                                    try {
                                        const gameInfo = await retroAPI.getGameInfoExtended(game.gameId);
                                        selectedGames.push({
                                            gameId: game.gameId,
                                            title: game.title,
                                            consoleName: game.consoleName,
                                            imageIcon: gameInfo.imageIcon || null
                                        });
                                    } catch (error) {
                                        console.error(`Error getting extended game info for ${game.title}:`, error);
                                        // Add without the image if we can't get extended info
                                        selectedGames.push({
                                            gameId: game.gameId,
                                            title: game.title,
                                            consoleName: game.consoleName,
                                            imageIcon: null
                                        });
                                    }
                                }
                            }

                            // Create embed for the poll announcement
                            const pollEmbed = new EmbedBuilder()
                                .setTitle('ðŸŽ® Monthly Challenge Voting Started!')
                                .setDescription(
                                    `Voting for next month's challenge has begun! The following games have been nominated:\n\n` +
                                    selectedGames.map((game, index) => 
                                        `**${index + 1}. [${game.title}](https://retroachievements.org/game/${game.gameId})** (${game.consoleName})`
                                    ).join('\n\n') +
                                    `\n\n**How to vote:**\n` +
                                    `Use the \`/vote\` command to cast up to two votes for your favorite games!\n` +
                                    `Example: \`/vote first:1 second:3\` to vote for games #1 and #3\n\n` +
                                    `Voting ends <t:${Math.floor(endDate.getTime() / 1000)}:R>`
                                )
                                .setColor('#FF69B4')
                                .setFooter({ text: `Voting ends ${endDate.toLocaleDateString()}` });

                            // Send the poll message
                            const pollMessage = await channel.send({ embeds: [pollEmbed] });

                            // Create the poll in the database
                            const poll = new Poll({
                                messageId: pollMessage.id,
                                channelId: channel.id,
                                resultsChannelId: resultsChannel.id, // Store results channel ID
                                selectedGames: selectedGames,
                                endDate: endDate
                            });

                            await poll.save();

                            // Try to schedule job if node-schedule is available
                            try {
                                // Dynamically import node-schedule
                                const schedule = await import('node-schedule').catch(() => {
                                    console.warn('node-schedule package not available, skipping automatic end scheduling');
                                    return null;
                                });
                                
                                if (schedule) {
                                    // Schedule the end of voting event
                                    const jobDate = new Date(endDate.getTime());
                                    console.log(`Scheduling automatic vote ending for: ${jobDate}`);
                                    
                                    // Add a named job that can be identified and canceled if needed
                                    const jobName = `end-poll-${poll._id}`;
                                    const job = schedule.default.scheduleJob(jobName, jobDate, async function() {
                                        try {
                                            // We'll manually handle this by retrieving the poll ID from the database
                                            console.log(`Scheduled job for poll ${poll._id} triggered`);
                                            
                                            // Logic will be handled by a manual process instead
                                            // Just log that it was triggered
                                        } catch (error) {
                                            console.error('Error in scheduled job for ending voting:', error);
                                        }
                                    });
                                    
                                    // Store the job name with the poll for potential cancellation
                                    poll.scheduledJobName = jobName;
                                    await poll.save();
                                    
                                    console.log(`Scheduled job created with name: ${jobName}`);
                                }
                            } catch (scheduleError) {
                                console.error('Error setting up scheduled job:', scheduleError);
                                // Continue without scheduling - this is optional functionality
                            }

                            // Show success message
                            const successEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Voting Poll Created')
                                .setDescription(`Voting poll has been created in ${channel}!`)
                                .addFields(
                                    {
                                        name: 'Configuration',
                                        value: `**Games Selected:** ${selectedGames.length}\n` +
                                              `**End Date:** ${endDate.toLocaleDateString()}\n` +
                                              `**Results Channel:** ${resultsChannel}`
                                    }
                                )
                                .setTimestamp();
                                
                            await i.editReply({
                                content: null,
                                embeds: [successEmbed],
                                components: []
                            });
                        } catch (error) {
                            console.error('Error starting voting:', error);
                            await i.editReply('An error occurred while starting the voting process. Please try again.');
                        }
                    } else if (i.customId === 'cancel_start_voting') {
                        // Show cancellation message
                        await i.editReply({
                            content: 'Voting start cancelled.',
                            embeds: [],
                            components: []
                        });
                    }
                }
            });
        } catch (error) {
            console.error('Error starting voting:', error);
            await interaction.editReply('An error occurred while setting up the voting process. Please try again.');
        }
    },

    async handleCancelVoting(interaction) {
        try {
            // Find the active poll
            const activePoll = await Poll.findActivePoll();
            if (!activePoll) {
                return interaction.editReply('There is no active voting poll to cancel.');
            }

            // Create confirmation embed
            const confirmEmbed = new EmbedBuilder()
                .setTitle('Cancel Voting Poll')
                .setColor('#FF0000') // Red for danger
                .setDescription('Are you sure you want to cancel the current voting poll? This action cannot be undone.')
                .addFields(
                    {
                        name: 'Poll Information',
                        value: `**Started:** ${new Date(activePoll.createdAt).toLocaleDateString()}\n` +
                              `**Ends:** ${new Date(activePoll.endDate).toLocaleDateString()}\n` +
                              `**Games:** ${activePoll.selectedGames.length}`
                    }
                )
                .setTimestamp();
                
            // Create confirmation buttons
            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('confirm_cancel_voting')
                        .setLabel('Cancel Voting')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('âœ…'),
                    new ButtonBuilder()
                        .setCustomId('abort_cancel_voting')
                        .setLabel('Keep Voting Active')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('âŒ')
                );
                
            await interaction.editReply({
                embeds: [confirmEmbed],
                components: [row]
            });
            
            // Set up collector for the confirmation buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 60000 // 1 minute timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'confirm_cancel_voting') {
                        // Show a loading message
                        await i.editReply({
                            content: 'Cancelling voting poll... This may take a moment.',
                            embeds: [],
                            components: []
                        });
                        
                        try {
                            // Cancel the scheduled job if it exists
                            if (activePoll.scheduledJobName) {
                                try {
                                    // Dynamically import node-schedule only if needed
                                    const schedule = await import('node-schedule').catch(() => {
                                        console.warn('node-schedule package not available, cannot cancel scheduled job');
                                        return { scheduledJobs: {} };
                                    });
                                    
                                    const job = schedule.scheduledJobs?.[activePoll.scheduledJobName];
                                    if (job) {
                                        job.cancel();
                                        console.log(`Canceled scheduled job: ${activePoll.scheduledJobName}`);
                                    }
                                } catch (scheduleError) {
                                    console.error('Error canceling scheduled job:', scheduleError);
                                    // Continue with poll cancellation even if job cancellation fails
                                }
                            }

                            // Mark the poll as processed so it doesn't get picked up again
                            activePoll.isProcessed = true;
                            await activePoll.save();

                            // Update the original poll message
                            try {
                                const pollChannel = interaction.client.channels.cache.get(activePoll.channelId);
                                if (pollChannel) {
                                    const pollMessage = await pollChannel.messages.fetch(activePoll.messageId);
                                    
                                    if (pollMessage) {
                                        const updatedEmbed = new EmbedBuilder()
                                            .setTitle('ðŸŽ® Monthly Challenge Voting (CANCELED)')
                                            .setDescription(
                                                `This voting poll has been canceled by an administrator.`
                                            )
                                            .setColor('#FF0000') // Red to indicate it's canceled
                                            .setFooter({ text: 'Voting has been canceled' });
                                        
                                        await pollMessage.edit({ embeds: [updatedEmbed] });
                                    }
                                }
                            } catch (messageError) {
                                console.error('Error updating original poll message:', messageError);
                                // Continue even if updating the message fails
                            }

                            // Show success message
                            const successEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Voting Poll Cancelled')
                                .setDescription('The voting poll has been cancelled successfully.')
                                .setTimestamp();
                                
                            await i.editReply({
                                content: null,
                                embeds: [successEmbed],
                                components: []
                            });
                        } catch (error) {
                            console.error('Error cancelling voting:', error);
                            await i.editReply('An error occurred while cancelling the voting process. Please try again.');
                        }
                    } else if (i.customId === 'abort_cancel_voting') {
                        // Show abort message
                        await i.editReply({
                            content: 'Voting cancellation aborted. The voting poll remains active.',
                            embeds: [],
                            components: []
                        });
                    }
                }
            });
        } catch (error) {
            console.error('Error cancelling voting:', error);
            await interaction.editReply('An error occurred while processing the voting cancellation. Please try again.');
        }
    },

    async handleVotingStatus(interaction) {
        try {
            // Find the active poll
            const activePoll = await Poll.findActivePoll();
            
            if (!activePoll) {
                return interaction.editReply('There is no active voting poll at this time.');
            }
            
            // Get the votes from the database
            const votes = activePoll.votes || [];
            
            // Count votes for each game
            const voteCounts = {};
            activePoll.selectedGames.forEach((game, index) => {
                voteCounts[index + 1] = { 
                    gameId: game.gameId,
                    title: game.title, 
                    consoleName: game.consoleName,
                    count: 0 
                };
            });
            
            // Count first and second votes
            votes.forEach(vote => {
                if (vote.firstChoice) {
                    voteCounts[vote.firstChoice].count += 2; // First choice gets 2 points
                }
                if (vote.secondChoice) {
                    voteCounts[vote.secondChoice].count += 1; // Second choice gets 1 point
                }
            });
            
            // Sort games by vote count (descending)
            const sortedVotes = Object.values(voteCounts).sort((a, b) => b.count - a.count);
            
            // Create the status embed
            const statusEmbed = new EmbedBuilder()
                .setTitle('Voting Status')
                .setColor('#FF69B4') // Hot pink
                .setDescription(`Current status of the voting poll for next month's challenge.`)
                .addFields(
                    {
                        name: 'Poll Information',
                        value: `**Started:** ${new Date(activePoll.createdAt).toLocaleDateString()}\n` +
                              `**Ends:** ${new Date(activePoll.endDate).toLocaleDateString()}\n` +
                              `**Games:** ${activePoll.selectedGames.length}\n` +
                              `**Total Votes:** ${votes.length}`
                    }
                )
                .setTimestamp();
                
            // Add current standings
            let standingsText = '';
            sortedVotes.forEach((game, index) => {
                standingsText += `${index + 1}. **${game.title}** (${game.consoleName}): ${game.count} point${game.count !== 1 ? 's' : ''}\n`;
            });
            
            statusEmbed.addFields({
                name: 'Current Standings',
                value: standingsText || 'No votes yet'
            });
            
            // Add information about end date
            const now = new Date();
            const timeRemaining = activePoll.endDate - now;
            const daysRemaining = Math.floor(timeRemaining / (1000 * 60 * 60 * 24));
            const hoursRemaining = Math.floor((timeRemaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            
            statusEmbed.addFields({
                name: 'Time Remaining',
                value: `${daysRemaining} day${daysRemaining !== 1 ? 's' : ''} and ${hoursRemaining} hour${hoursRemaining !== 1 ? 's' : ''} until voting ends.\n` +
                      `Voting ends <t:${Math.floor(activePoll.endDate.getTime() / 1000)}:R>`
            });
            
            // Create action buttons
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('cancel_voting')
                        .setLabel('Cancel Voting')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('âŒ'),
                    new ButtonBuilder()
                        .setCustomId('refresh_status')
                        .setLabel('Refresh Status')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('ðŸ”„')
                );
                
            await interaction.editReply({
                embeds: [statusEmbed],
                components: [actionRow]
            });
            
            // Set up collector for the button interactions
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 300000 // 5 minutes timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'cancel_voting') {
                        await this.handleCancelVoting(i);
                    } else if (i.customId === 'refresh_status') {
                        await this.handleVotingStatus(i);
                    }
                }
            });
        } catch (error) {
            console.error('Error getting voting status:', error);
            await interaction.editReply('An error occurred while retrieving the voting status. Please try again.');
        }
    },

    // SYSTEM MANAGEMENT HANDLERS
    async handleSystemCommand(interaction, subcommand) {
        switch (subcommand) {
            case 'update':
                await this.handleForceUpdate(interaction);
                break;
            case 'suggestions':
                await this.handleManageSuggestions(interaction);
                break;
            default:
                await interaction.editReply('Invalid system subcommand.');
        }
    },

    async handleForceUpdate(interaction) {
        try {
            // Create confirmation embed
            const confirmEmbed = new EmbedBuilder()
                .setTitle('Force Update')
                .setColor('#3498DB') // Blue
                .setDescription('Are you sure you want to force an immediate update of all user stats and leaderboards?')
                .addFields(
                    {
                        name: 'Warning',
                        value: 'This operation can be resource-intensive and may take several minutes to complete, depending on the number of users and their achievements.'
                    }
                )
                .setTimestamp();
                
            // Create confirmation buttons
            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('confirm_force_update')
                        .setLabel('Force Update')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('âš¡'),
                    new ButtonBuilder()
                        .setCustomId('cancel_force_update')
                        .setLabel('Cancel')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('âŒ')
                );
                
            await interaction.editReply({
                embeds: [confirmEmbed],
                components: [row]
            });
            
            // Set up collector for the confirmation buttons
            const message = await interaction.fetchReply();
            const collector = message.createMessageComponentCollector({
                componentType: ComponentType.Button,
                time: 60000 // 1 minute timeout
            });
            
            collector.on('collect', async i => {
                if (i.user.id === interaction.user.id) {
                    await i.deferUpdate();
                    
                    if (i.customId === 'confirm_force_update') {
                        // Show a loading message
                        await i.editReply({
                            content: 'Starting stats update. This may take a few minutes...',
                            embeds: [],
                            components: []
                        });
                        
                        try {
                            // Import the stats update service
                            const statsUpdateService = (await import('../../services/statsUpdateService.js')).default;
                            
                            // Check if an update is already in progress
                            if (statsUpdateService.isUpdating) {
                                return i.editReply('An update is already in progress. Please wait for it to complete.');
                            }

                            // Force the update by bypassing the isUpdating check
                            const originalIsUpdating = statsUpdateService.isUpdating;
                            statsUpdateService.isUpdating = false;
                            
                            await statsUpdateService.start();
                            
                            // Restore the original state
                            statsUpdateService.isUpdating = originalIsUpdating;

                            // Show success message
                            const successEmbed = new EmbedBuilder()
                                .setColor('#00FF00') // Green for success
                                .setTitle('Update Completed')
                                .setDescription('Stats update completed successfully!')
                                .setTimestamp();
                                
                            await i.editReply({
                                content: null,
                                embeds: [successEmbed],
                                components: []
                            });
                        } catch (error) {
                            console.error('Error forcing stats update:', error);
                            await i.editReply('An error occurred while updating stats. Please try again.');
                        }
                    } else if (i.customId === 'cancel_force_update') {
                        // Show cancellation message
                        await i.editReply({
                            content: 'Update cancelled.',
                            embeds: [],
                            components: []
                        });
                    }
                }
            });
        } catch (error) {
            console.error('Error forcing update:', error);
            await interaction.editReply('An error occurred while setting up the force update. Please try again.');
        }
    },

    async handleManageSuggestions(interaction) {
        try {
            // Show loading message while we load the suggestion management system
            await interaction.editReply('Loading suggestion management system...');
            
            // Import the suggestAdmin module
            const suggestAdmin = (await import('./suggestAdmin.js')).default;
            
            // Call the showMainMenu function from suggestAdmin
            await suggestAdmin.showMainMenu(interaction);
        } catch (error) {
            console.error('Error loading suggestion management:', error);
            await interaction.editReply('An error occurred while loading the suggestion management system. Please try again.');
        }
    },

    // INFO DISPLAY HANDLERS
    async handleInfoCommand(interaction, subcommand) {
        try {
            // Import the adminInfo module
            const adminInfo = (await import('./adminInfo.js')).default;
            
            // Call the appropriate function based on the subcommand
            switch (subcommand) {
                case 'arcade':
                    await adminInfo.handleArcadeBoards(interaction);
                    break;
                case 'challenges':
                    await adminInfo.handleChallenges(interaction);
                    break;
                case 'overview':
                    await adminInfo.handleOverview(interaction);
                    break;
                case 'commands':
                    await adminInfo.handleCommands(interaction);
                    break;
                case 'rules':
                    await adminInfo.handleRules(interaction);
                    break;
                default:
                    await interaction.editReply('Invalid info subcommand.');
            }
        } catch (error) {
            console.error('Error handling info command:', error);
            await interaction.editReply('An error occurred while processing the info command. Please try again.');
        }
    }
};
